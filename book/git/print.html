<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Rust and GTK 4</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">2.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">3.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="gobject_concepts.html"><strong aria-hidden="true">4.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gobject_memory_management.html"><strong aria-hidden="true">4.1.</strong> Memory management</a></li><li class="chapter-item expanded "><a href="gobject_subclassing.html"><strong aria-hidden="true">4.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="gobject_properties.html"><strong aria-hidden="true">4.3.</strong> Properties</a></li><li class="chapter-item expanded "><a href="gobject_signals.html"><strong aria-hidden="true">4.4.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">5.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">6.</strong> Settings</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Save Window State of our App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Media Support</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Images</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Videos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Interface Builder</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> GtkBuilder</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Templates</div></li></ol></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">10.</strong> Resources</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Actions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Shortcuts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> App with Persistent Image Selection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Accessibility</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Internationalization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Models &amp; Views</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Building a simple To-do App</div></li><li class="chapter-item expanded affix "><li class="part-title">Useful Libraries</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> GtkSourceView</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> GStreamer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Libadwaita</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Webkit2Gtk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Zbus and Ashpd</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gui-development-with-rust-and-gtk-4"><a class="header" href="#gui-development-with-rust-and-gtk-4">GUI development with Rust and GTK 4</a></h1>
<p><em>by Julian Hofer, with contributions from the community</em></p>
<p>GTK 4 is the newest version of a popular cross-platform widget toolkit written in C.
Thanks to GObject-Introspection, GTK's API can be easily targeted by various programming languages.
The API even describes the ownership of its parameters!</p>
<p>Managing ownership without giving up speed is one of Rust's greatest strengths, which makes it an excellent choice to develop GTK apps with.
With this combination you do not have to worry about hitting bottlenecks mid-project anymore.
Additionally, with Rust you will have nice things like:</p>
<ul>
<li>Thread safety</li>
<li>Memory safety</li>
<li>Sensible dependency management</li>
<li>Excellent third party libraries, which benefit from the same points as mentioned above</li>
</ul>
<p>The <code>gtk-rs</code> project provides bindings to many GTK-related libraries which we will be using throughout this book.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book assumes that you know your way around Rust code.
If this is not already the case, reading <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> is an enjoyable way to get you to that stage.
If you have experience with another low-level language such as C or C++ you
might find that reading <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half hour to learn Rust</a> gives you sufficient information as well.</p>
<p>Luckily, this — together with the wish to develop graphical applications — is all that is necessary to benefit from this book. </p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. However, if you are using it as a reference for a certain topic,
you might find it useful to just jump into it.</p>
<p>There are two kinds of chapters in this book: concept chapters and project
chapters.
In concept chapters, you will learn about an aspect of GTK development.
In project chapters, we will build small programs together, applying what you have learned so far.</p>
<p>The book strives to explain essential GTK concepts paired with practical examples.
However, if a concept can be better conveyed with a less practical example, we took this path most of the time.
If you are interested in contained and useful examples, we refer you to the corresponding <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/examples">section</a> of gtk4-rs.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The book itself is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported license</a>.
The only exception are the code snippets which are licensed under the <a href="https://gitlab.gnome.org/Hofer-Julian/gtk-rs-book/-/blob/main/LICENSE">MIT license</a>.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>There are a few recommended ways to set up your workstation in order to develop <code>gtk-rs</code> applications.
Let us go through them one by one.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a> is Rust's build system and package manager.
If following the book is all you care about, using only Cargo will work fine for you.</p>
<p>Let us begin by installing all necessary tools.
First follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.</p>
<p>Now create a new project by executing:</p>
<pre><code class="language-bash">cargo new my-gtk-app
</code></pre>
<p>Add the following lines to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies.gtk]
version = &quot;0.1&quot;
package = &quot;gtk4&quot;
</code></pre>
<p>Now you can run your application by executing:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="cargo--meson"><a class="header" href="#cargo--meson">Cargo + Meson</a></h2>
<p>Cargo is <em>nearly</em> enough, but it is not well suited for handling resources such as icons or UI files.
That is why we recommend to use <a href="https://mesonbuild.com/">Meson</a> on top of it.
It is cross-platform and its syntax is very readable.
Meson takes care of</p>
<ul>
<li>translations</li>
<li>building and installing <a href="resources.html">resources</a></li>
<li>installing auxiliary files such as icons and <a href="settings.html">settings schemas</a></li>
</ul>
<p>Here as well, you first follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.
Finally, install Meson by following the instructions on the <a href="https://mesonbuild.com/Getting-meson.html">Meson website</a>.</p>
<p>You can download a ready-to-use gtk-rust-template <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">here</a>.
Follow the instructions in the README to initialize your own application.
Then configure your project.</p>
<pre><code class="language-bash">meson --prefix=/usr build
</code></pre>
<p>In order to compile and install it run the following commands.
You have to execute it every time you modify your application.</p>
<pre><code class="language-bash">ninja -C build &amp;&amp; ninja -C build install
</code></pre>
<p>Now the application should be in a folder included in your system path.
You can either start it with the application launcher of your choice or in the terminal.</p>
<h2 id="cargo--meson--flatpak"><a class="header" href="#cargo--meson--flatpak">Cargo + Meson + Flatpak</a></h2>
<p>If you develop on Linux, using Flatpak is the most convenient option.
With Flatpak your whole workflow is containerized and your users get the very same application you develop on (including all dependencies). 
First, assure that Flatpak is installed on your system, check this <a href="https://flatpak.org/setup/">website</a> to see if any steps are necessary on your distribution.
Then download the <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">gtk-rust-template</a> and follow the instructions in its README.</p>
<p>Then either install:</p>
<ul>
<li><a href="https://flathub.org/apps/details/org.gnome.Builder">GNOME Builder</a> or</li>
<li><a href="https://flathub.org/apps/details/com.vscodium.codium">VSCodium</a> together with the <a href="https://open-vsx.org/extension/matklad/rust-analyzer">rust-analyzer</a> and <a href="https://open-vsx.org/extension/bilelmoussaoui/flatpak-vscode">flatpak</a> extensions.</li>
</ul>
<p>That is it.
The build dependencies can be downloaded by the IDE.
With GNOME Builder, you only have to press the run button for that.</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Now that we have got a working installation, let us get right into it!</p>
<p>At the very least, we need to create an <code>Application</code> instance, with an application id and the default application flags.
<a href="https://wiki.gnome.org/HowDoI/ChooseApplicationID">This guide</a> helps you find a suitable application id for your app.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
use gtk::Application;

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);

    // Run the application
    app.run();
}
</code></pre></pre>
<p>It builds fine, but nothing appears on our screen.
GTK warns us, that it would have expected that something would be called in its <code>activate</code> step.
So let us create a window there.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
use gtk::{Application, ApplicationWindow};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);
    app.connect_activate(on_activate);

    // Run the application
    app.run();
}

// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindow::new(application);

    // Set the window title
    window.set_title(Some(&quot;My GTK App&quot;));

    window.present();
}
</code></pre></pre>
<p>That is better!</p>
<div style="text-align:center"><img src="img/hello_world_empty.png" /></div>
<p>Normally we expect to be able to interact with the user interface.
Also, the name of the chapter suggests that the phrase &quot;Hello World!&quot; will be involved.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindow::new(application);

    // Set the window title
    window.set_title(Some(&quot;My GTK App&quot;));

    // Create a button
    let button = Button::with_label(&quot;Press me!&quot;);

    // Set the button margins
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>There is now a button and if we click on it, its label becomes &quot;Hello World!&quot;.</p>
<div style="text-align:center"><img src="img/hello_world_button.png" /></div>
<p>Was not that hard to create our first <code>gtk-rs</code> app, right?
Let us now get a better understanding of what we did here.</p>
<h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are the components that make up a GTK application.
GTK offers many-preexisting ones and if those do not fit, you can even create custom ones.
There are display widgets, buttons, containers and windows.
One kind of widget might be able to contain other widgets, it might present information and it might react to interaction.</p>
<p>The <a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> is useful to find out which widget fits your needs.
Let us say we want to add a button to our app.
We have quite a bit of choice here, but let us take the simplest one — a <code>Button</code>.</p>
<div style="text-align:center"><img src="img/widgets_button.png" /></div>
<p>GTK is an object-oriented framework, so all widgets are part of an inheritance tree with <code>GObject</code> at the top.
The inheritance tree of a <code>Button</code> looks like this:</p>
<pre><code class="language-console">GObject
╰── Widget
    ╰── Button
</code></pre>
<p>The <a href="https://docs.gtk.org/gtk4/class.Button.html">GTK documentation</a> also tells us that <code>Button</code> implements the interfaces <code>GtkAccessible</code>, <code>GtkActionable</code>, <code>GtkBuildable</code>, <code>GtkConstraintTarget</code>.</p>
<p>Now let us compare that with the corresponding <code>Button</code> struct in <code>gtk-rs</code>.
The <a href="https://gtk-rs.org/gtk4-rs/gtk4/struct.Button.html#implements">gtk-rs documentation</a> tells us which methods and traits it implements.
We find that these traits either have a corresponding base class or interface in the GTK docs.
In the &quot;Hello World&quot; app we wanted to react to a button click.
This behavior is specific to a button, so we expect to find a suitable method in the <code>ButtonExt</code> trait.
And indeed, <code>ButtonExt</code> includes the method <a href="https://gtk-rs.org/gtk4-rs/gtk4/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindow::new(application);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span>    // Create a button
    let button = Button::with_label(&quot;Press me!&quot;);

    // Set the button margins
    button.set_margin_top(18);
    button.set_margin_bottom(18);
    button.set_margin_start(18);
    button.set_margin_end(18);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Please note that Rust requires bringing traits into scope, before using one of its methods.
In our example we did that by adding the following line:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
<span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindow::new(application);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::with_label(&quot;Press me!&quot;);
</span><span class="boring">
</span><span class="boring">    // Set the button margins
</span><span class="boring">    button.set_margin_top(18);
</span><span class="boring">    button.set_margin_bottom(18);
</span><span class="boring">    button.set_margin_start(18);
</span><span class="boring">    button.set_margin_end(18);
</span><span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>With it, we import all necessary traits for dealing with widgets.
You probably want to bring the prelude into scope in most of your source files.</p>
<p>This is also a good moment to mention that all <code>gtk-rs</code> widgets support <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">the builder pattern</a>.
This is especially nice for creating widgets where multiple widget characteristics are already known during its creation.
We can make our button creation neater, by replacing <code>gtk::Button</code> with <a href="https://gtk-rs.org/gtk4-rs/gtk4/struct.ButtonBuilder.html"><code>gtk::ButtonBuilder</code></a>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create a button
    let button = ButtonBuilder::new()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();
<span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="gobject-concepts"><a class="header" href="#gobject-concepts">GObject Concepts</a></h1>
<p>GTK is an object-oriented framework.
It is written in C, which does not support object-orientation out of the box.
That is why, GTK relies on the GObject library to provide the object system.</p>
<p>We already learned, that <code>gtk-rs</code> maps GObject concepts like inheritance and interfaces to Rust traits.
In this chapter we will additionally find out:</p>
<ul>
<li>How to manage the memory of GObjects.</li>
<li>How to create our own GObjects via subclassing.</li>
<li>How to use properties.</li>
<li>How to use signals.</li>
</ul>
<h1 id="memory-management-of-gobjects"><a class="header" href="#memory-management-of-gobjects">Memory management of GObjects</a></h1>
<p>GObjects are reference-counted, mutable objects, so they behave very similar to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.
Let us see in a set of real life examples which consequences this has.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindow, Button, Orientation};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);
    app.connect_activate(on_activate);
    
    // Run the application
    app.run();
}

// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindow::new(application);

    // Create two buttons
    let button_increase = Button::with_label(&quot;Increase&quot;);
    let button_decrease = Button::with_label(&quot;Decrease&quot;);

    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(|_| number += 1);
    button_decrease.connect_clicked(|_| number -= 1);

    // Add buttons
    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
    window.set_child(Some(&amp;gtk_box));
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
    window.present();
}
</code></pre></pre>
<p>Here we would like to create a simple app with two buttons.
If we click on one button, an integer number should be increased. If we press the other one, it should be decreased.
The Rust compiler refuses to compile it though.</p>
<p>For once the borrow checker kicked in:</p>
<pre><code class="language-console">error[E0499]: cannot borrow `number` as mutable more than once at a time
  --&gt; main.rs:27:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ------------------------------------------------
   |     |                               |   |
   |     |                               |   first borrow occurs due to use of `number` in closure
   |     |                               first mutable borrow occurs here
   |     argument requires that `number` is borrowed for `'static`
27 |     button_decrease.connect_clicked(|_| number -= 1);
   |                                     ^^^ ------ second borrow occurs due to use of `number` in closure
   |                                     |
   |                                     second mutable borrow occurs here
</code></pre>
<p>Also, the compiler tells us that our closures may outlive <code>number</code>:</p>
<pre><code class="language-console">
error[E0373]: closure may outlive the current function, but it borrows `number`, which is owned by the current function
  --&gt; main.rs:26:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |                                     ^^^ ------ `number` is borrowed here
   |                                     |
   |                                     may outlive borrowed value `number`
   |
note: function requires argument type to outlive `'static`
  --&gt; main.rs:26:5
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `number` (and any other referenced variables), use the `move` keyword
   |
26 |     button_increase.connect_clicked(move |_| number += 1);
   |                                     ^^^^^^^^
</code></pre>
<p>Thinking about the second error message, it makes sense that the closure requires the lifetimes of references to be <code>'static</code>.
The compiler cannot know when the user presses a button, so references must live forever.
And our <code>number</code> gets immediately deallocated after it reaches the end of its scope.
The error message is also suggesting that we could take ownership of <code>number</code>.
But is there actually a way that both closures could take ownership of the same value?</p>
<p>Yes! That is exactly what the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> type is there for.
The <code>Rc</code> counts the number of strong references created via <code>Clone::clone</code> and released via <code>Drop::drop</code>, and only deallocates it when this number drops to zero.
We call every object containing a strong reference a shared owner of the value.
If we want to modify the content of our <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>,
we can use the <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> type.
<code>RefCell</code> then checks Rust's borrow rules during run time, namely that there can only be one mutable borrow at a time or multiple immutable borrows.
<code>RefCell</code> panics if these rules are violated.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Reference-counted object with inner-mutability
    let number = Rc::new(RefCell::new(0));

    // Connect callbacks, when a button is clicked `number` will be changed
    let number_copy_1 = number.clone();
    button_increase.connect_clicked(move |_| *number_copy_1.borrow_mut() += 1);
    button_decrease.connect_clicked(move |_| *number.borrow_mut() -= 1);
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>It is not very nice though to fill the scope with temporary variables like <code>number_copy_1</code>.
We can improve that by using the <code>glib::clone!</code> macro.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` will be changed
</span>    button_increase.connect_clicked(clone!(@strong number =&gt; move |_| {
        *number.borrow_mut() += 1;
    }));
    button_decrease.connect_clicked(move |_| {
        *number.borrow_mut() -= 1;
    });
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Just like <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, GObjects are reference-counted and mutable.
Therefore, we can pass the buttons the same way to the closure as we did with <code>number</code>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@strong number, @strong button_decrease =&gt;
        move |_| {
            *number.borrow_mut() += 1;
            button_decrease.set_label(&amp;number.borrow().to_string());
    }));
    button_decrease.connect_clicked(clone!(@strong button_increase =&gt;
        move |_| {
            *number.borrow_mut() -= 1;
            button_increase.set_label(&amp;number.borrow().to_string());
    }));
<span class="boring">
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we now click on one button, the other button's label gets changed.</p>
<p>But whoops!
Did we forget about one annoyance of reference-counted systems?
Yes we did: <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycles</a>.
<code>button_increase</code> holds a strong reference to <code>button_decrease</code> and vice-versa.
A strong reference keeps the referenced value from being deallocated.
If this chain leads to a circle, none of the values in this cycle ever get deallocated.
With weak references we can break this cycle, because they do not keep their value alive but instead provide a way to retrieve a strong reference if the value is still alive.
Since we want our apps to free unneeded memory, we should use weak references for the buttons instead<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
        move |_| {
            *number.borrow_mut() += 1;
            button_decrease.set_label(&amp;number.borrow().to_string());
    }));
    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
        move |_| {
            *number.borrow_mut() -= 1;
            button_increase.set_label(&amp;number.borrow().to_string());
    }));
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The reference cycle is broken.
Every time the button is clicked, <code>glib::clone</code> tries to upgrade the weak reference.
If we now for example click on one button and the other button is not there anymore, <code>upgrade</code> will return <code>None</code>.
Per default, it immediately returns from the closure with <code>()</code> as return value.
In case the closure expects a different return value or a panic is preferred <code>@default-return</code> or <code>@default-panic</code>.
For more information about <code>glib::clone</code>, please have a look at the <a href="https://docs.rs/glib/latest/glib/macro.clone.html">docs</a>.</p>
<p>Notice that we kept the <em>strong</em> reference to <code>number</code>.
If we had a <em>weak</em> reference, no one would have kept <code>number</code> alive and the closure would have never been called.
Thinking about this, <code>button_increase</code> and <code>button_decrease</code> are also dropped at the end of the scope of <code>on_activate</code>.
Who then keeps the buttons alive?</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() += 1;
</span><span class="boring">            button_decrease.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() -= 1;
</span><span class="boring">            button_increase.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span>    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
<span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>When we append the buttons to the <code>gtk_box</code>, <code>gtk_box</code> keeps a strong reference to them.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() += 1;
</span><span class="boring">            button_decrease.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() -= 1;
</span><span class="boring">            button_increase.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span>    window.set_child(Some(&amp;gtk_box));
<span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>When we set <code>gtk_box</code> as child of <code>window</code>, <code>window</code> keeps a strong reference to it.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindowBuilder, ButtonBuilder, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span>    let window = ApplicationWindowBuilder::new()
        .application(application)
        .title(&quot;My GTK App&quot;)
        .build();
<span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(RefCell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() += 1;
</span><span class="boring">            button_decrease.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            *number.borrow_mut() -= 1;
</span><span class="boring">            button_increase.set_label(&amp;number.borrow().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>During the creation of our <code>window</code>, we pass <code>application</code> to it.
Because of that, <code>application</code> holds a strong reference to <code>window</code>.
<code>application</code> lives for the whole lifetime of our program, which explains why weak references within our closures are sufficient.</p>
<p>As long as you use weak references whenever possible you will find it perfectly doable to avoid memory cycles within your application.
Then, you can fully rely on GTK to properly manage the memory of GObjects you pass to it.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In this simple example, GTK actually resolves the reference cycle on its own once you close the window.
However, the general point to avoid strong references whenever possible remains valid.</p>
</div>
<h1 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h1>
<p>GObjects rely heavily on inheritance.
Therefore, it makes sense that if we want to create a custom GObject, this is done via subclassing.
Let us see how this works by replacing the button in our &quot;Hello World!&quot; app with a custom one.</p>
<p>First, we need to create an implementation struct that holds the state and overrides the virtual methods.
It is advised to keep it in a private module, since its state and methods are only meant to be used by the GObject itself.
It therefore corresponds to the private section of objects in languages like Java and C++.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">
</span>// Implementation of our custom GObject
mod imp {
    // Import parent scope
    use super::*;
    // Import necessary traits for subclassing
    use gtk::subclass::prelude::*;

    // Object holding the state
    #[derive(Default)]
    pub struct CustomButton;

    // The central trait for subclassing a GObject
    #[glib::object_subclass]
    impl ObjectSubclass for CustomButton {
        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
        type Type = super::CustomButton;
        type ParentType = gtk::Button;
    }

    // Trait shared by all GObjects
    impl ObjectImpl for CustomButton {}

    // Trait shared by all widgets
    impl WidgetImpl for CustomButton {}

    // Trait shared by all buttons
    impl ButtonImpl for CustomButton {}
}
<span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::with_label(&quot;Press me!&quot;);
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The description of the subclassing is in <code>ObjectSubclass</code>.</p>
<ul>
<li><code>NAME</code> should consist of crate-name, module-path and object-name in order to avoid name collisions. Use <a href="https://wiki.c2.com/?PascalCase">PascalCase</a> here.</li>
<li><code>Type</code> refers to the actual GObject that will be created afterwards.</li>
<li><code>ParentType</code> is the GObject we inherit of.</li>
</ul>
<p>After that, we would have the option to override the virtual methods of our ancestors.
Since we only want to have a plain button for now, we override nothing.
We still have to add the empty <code>impl</code> though.
Next, we describe our custom GObject.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary traits for subclassing
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton;
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {}
</span><span class="boring">}
</span>glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
    }
    pub fn with_label(label: &amp;str) -&gt; Self {
        let button = Self::new();
        button.set_label(label);
        button
    }
}
<span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::with_label(&quot;Press me!&quot;);
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p><code>glib::wrapper!</code> does the most of the work of subclassing for us.
We only have to point to the implementation struct and which ancestor GObjects we extend.
Please note that the list of ancestor GObjects does not mention <code>glib::Object</code>.
This is because <code>glib::Object</code> is <em>always</em> the base class in the object hierarchy and therefore already implied.</p>
<p>After these steps, nothing is stopping us anymore from replacing <code>gtk::Button</code> with our <code>CustomButton</code>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary traits for subclassing
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton;
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {}
</span><span class="boring">}
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span>fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);
    app.connect_activate(on_activate);

    // Run the application
    app.run();
}

// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindowBuilder::new()
        .application(application)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = CustomButton::with_label(&quot;Press me!&quot;);
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>We are able to use <code>CustomButton</code> as a drop-in replacement for <code>gtk::Button</code>.
This is cool, but also not very tempting to do in a real application.
For the gain of zero benefits, it did involve quite a bit of boilerplate after all.</p>
<p>So let us make it a bit more interesting!
<code>gtk::Button</code> does not hold much state, but we can let <code>CustomButton</code> hold a number.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span>// Implementation of our custom GObject
mod imp {
    // Import parent scope
    use super::*;
    // Import necessary traits for subclassing
    use gtk::subclass::prelude::*;

    // Object holding the state
    #[derive(Default)]
    pub struct CustomButton {
        number: RefCell&lt;i32&gt;,
    }

    // The central trait for subclassing a GObject
    #[glib::object_subclass]
    impl ObjectSubclass for CustomButton {
        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
        type Type = super::CustomButton;
        type ParentType = gtk::Button;
    }

    // Trait shared by all GObjects
    impl ObjectImpl for CustomButton {
        fn constructed(&amp;self, obj: &amp;Self::Type) {
            self.parent_constructed(obj);
            obj.set_label(&amp;self.number.borrow().to_string());
        }
    }

    // Trait shared by all widgets
    impl WidgetImpl for CustomButton {}

    // Trait shared by all buttons
    impl ButtonImpl for CustomButton {
        fn clicked(&amp;self, button: &amp;Self::Type) {
            *self.number.borrow_mut() += 1;
            button.set_label(&amp;self.number.borrow().to_string())
        }
    }
}
<span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>We override <code>constructed</code> in <code>ObjectImpl</code> so that the label of the button initializes with <code>number</code>.
We also override <code>clicked</code> in <code>ButtonImpl</code> so that every click increases <code>number</code> and updates the label.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary traits for subclassing
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            *self.number.borrow_mut() += 1;
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span>// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindowBuilder::new()
        .application(application)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = CustomButton::new();
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>In <code>on_activate</code> we stop calling <code>connect_clicked</code>, and that was it.
After a rebuild, the app now features our <code>CustomButton</code> with the label &quot;0&quot;.
Every time we click on the button, the number displayed by the label increases by 1.</p>
<div style="text-align:center"><img src="img/gobject_subclassing.png" /></div>
<p>So, when do we want to inherit from GObject?</p>
<ul>
<li>We want to use a certain widget, but with added state and overridden virtual functions.</li>
<li>We want to pass a Rust object to a function, but the function expects a GObject.</li>
<li>We want to add properties or signals to an object.</li>
</ul>
<h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<p>Properties allow us to access state of GObjects.</p>
<p>Let us see how this is done by experimenting with the <code>Switch</code> widget.
One of its properties is the <a href="https://docs.gtk.org/gtk4/property.Switch.state.html">state</a>.
It can be read and be written to.
We do that by calling the <code>get_property</code> and <code>set_property</code> methods.
Since all of this is highly dynamic, checks occur at runtime and the code involves a bit of boilerplate.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, BoxBuilder, Orientation, Switch};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the switch
    let switch = Switch::new();

    switch.set_property(&quot;state&quot;, &amp;true).unwrap();

    let current_state = switch
        .get_property(&quot;state&quot;)
        .unwrap()
        .get::&lt;bool&gt;()
        .unwrap()
        .unwrap();
    // This current state will be true
    println!(&quot;The current state is {}&quot;, current_state);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Properties can also be bound to each other.
Let us see how would bind the properties of two <code>Switch</code> instances.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the switches
    let switch_1 = Switch::new();
    let switch_2 = Switch::new();
<span class="boring">
</span><span class="boring">    switch_1
</span><span class="boring">        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>In our case, we want to bind the &quot;state&quot; property of <code>switch_1</code> to the &quot;state&quot; property of <code>switch_2</code>.
We also want the binding to be bidirectional, so we specify this with the <a href="http://gtk-rs.org/docs/glib/struct.BindingFlags.html"><code>BindingFlags</code></a>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the switches
</span><span class="boring">    let switch_1 = Switch::new();
</span><span class="boring">    let switch_2 = Switch::new();
</span><span class="boring">
</span>    switch_1
        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
        .flags(BindingFlags::BIDIRECTIONAL)
        .build();
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Whenever we now click on one of the two switches, the other one gets toggled as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_switches.png" /></div>
<p>We can also add properties to custom GObjects.
We can demonstrate that, by binding the <code>number</code> of our <code>CustomButton</code> to a property.</p>
<p>However, we first need to add <code>once_cell</code> to our dependencies.
With this, we can <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily evaluate</a> expressions, which we often need when working with custom GObjects.</p>
<pre><code class="language-toml">[dependencies]
once_cell = &quot;1&quot;
</code></pre>
<p>Then we have to define the property within the <code>ObjectImpl</code> implementation.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::{ParamFlags, ParamSpec, Value};
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span>    // Trait shared by all GObjects
    impl ObjectImpl for CustomButton {
        fn constructed(&amp;self, obj: &amp;Self::Type) {
            self.parent_constructed(obj);
            obj.set_label(&amp;self.number.borrow().to_string());
        }

        fn properties() -&gt; &amp;'static [ParamSpec] {
            static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
                vec![ParamSpec::int(
                    // Name
                    &quot;number&quot;,
                    // Nickname
                    &quot;number&quot;,
                    // Short description
                    &quot;number&quot;,
                    // Minimum value
                    i32::MIN,
                    // Maximum value
                    i32::MAX,
                    // Default value
                    0,
                    // The property can be read and written to
                    ParamFlags::READWRITE,
                )]
            });
            PROPERTIES.as_ref()
        }
        fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
            match pspec.get_name() {
                &quot;number&quot; =&gt; {
                    let input_number = value.get().unwrap().unwrap();
                    self.number.replace(input_number);
                }
                _ =&gt; unimplemented!(),
            }
        }

        fn get_property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
            match pspec.get_name() {
                &quot;number&quot; =&gt; self.number.borrow().to_value(),
                _ =&gt; unimplemented!(),
            }
        }
    }
<span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            let incremented_number = self.number.borrow().clone() + 1;
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number).unwrap();
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;label&quot;, &amp;button_2, &quot;label&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .get_property(&quot;number&quot;)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .unwrap()
</span><span class="boring">            .unwrap();
</span><span class="boring">        println!(&quot;The current number is {}&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>properties</code> method describes our set of properties.
When naming our property, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
Then, we describe its type, range and default value.
We also declare that the property can be read and be written to.
<code>set_property</code> describes how the underlying values can be changed.
<code>get_property</code> takes care of returning the underlying value.
The formerly private <code>number</code> is now accessible via the <code>get_property</code> and <code>set_property</code> methods.</p>
<p>Let us see what we can do with this by creating two custom buttons.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::{ParamFlags, ParamSpec, Value};
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">            static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">                vec![ParamSpec::int(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Minimum value
</span><span class="boring">                    i32::MIN,
</span><span class="boring">                    // Maximum value
</span><span class="boring">                    i32::MAX,
</span><span class="boring">                    // Default value
</span><span class="boring">                    0,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                )]
</span><span class="boring">            });
</span><span class="boring">            PROPERTIES.as_ref()
</span><span class="boring">        }
</span><span class="boring">        fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; {
</span><span class="boring">                    let input_number = value.get().unwrap().unwrap();
</span><span class="boring">                    self.number.replace(input_number);
</span><span class="boring">                }
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; self.number.borrow().to_value(),
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            let incremented_number = self.number.borrow().clone() + 1;
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number).unwrap();
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the buttons
    let button_1 = CustomButton::new();
    let button_2 = CustomButton::new();
<span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;label&quot;, &amp;button_2, &quot;label&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .get_property(&quot;number&quot;)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .unwrap()
</span><span class="boring">            .unwrap();
</span><span class="boring">        println!(&quot;The current number is {}&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The numbers of the two buttons can now be bound to each other.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::{ParamFlags, ParamSpec, Value};
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">            static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">                vec![ParamSpec::int(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Minimum value
</span><span class="boring">                    i32::MIN,
</span><span class="boring">                    // Maximum value
</span><span class="boring">                    i32::MAX,
</span><span class="boring">                    // Default value
</span><span class="boring">                    0,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                )]
</span><span class="boring">            });
</span><span class="boring">            PROPERTIES.as_ref()
</span><span class="boring">        }
</span><span class="boring">        fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; {
</span><span class="boring">                    let input_number = value.get().unwrap().unwrap();
</span><span class="boring">                    self.number.replace(input_number);
</span><span class="boring">                }
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; self.number.borrow().to_value(),
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            let incremented_number = self.number.borrow().clone() + 1;
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number).unwrap();
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span>    button_1
        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
        .flags(BindingFlags::BIDIRECTIONAL)
        .build();
<span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;label&quot;, &amp;button_2, &quot;label&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .get_property(&quot;number&quot;)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .unwrap()
</span><span class="boring">            .unwrap();
</span><span class="boring">        println!(&quot;The current number is {}&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The numbers are bound to each other, but if we now press on one button, the label of the other one does not get updated.
Luckily, &quot;label&quot; is a built-in property of <code>Button</code>, the class from which <code>CustomButton</code> inherits of.
All we have to do is to bind the &quot;label&quot; property of <code>button_1</code> to the &quot;label&quot; property of <code>button_2</code>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::{ParamFlags, ParamSpec, Value};
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">            static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">                vec![ParamSpec::int(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Minimum value
</span><span class="boring">                    i32::MIN,
</span><span class="boring">                    // Maximum value
</span><span class="boring">                    i32::MAX,
</span><span class="boring">                    // Default value
</span><span class="boring">                    0,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                )]
</span><span class="boring">            });
</span><span class="boring">            PROPERTIES.as_ref()
</span><span class="boring">        }
</span><span class="boring">        fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; {
</span><span class="boring">                    let input_number = value.get().unwrap().unwrap();
</span><span class="boring">                    self.number.replace(input_number);
</span><span class="boring">                }
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; self.number.borrow().to_value(),
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            let incremented_number = self.number.borrow().clone() + 1;
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number).unwrap();
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    button_1
        .bind_property(&quot;label&quot;, &amp;button_2, &quot;label&quot;)
        .flags(BindingFlags::BIDIRECTIONAL)
        .build();
<span class="boring">
</span><span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .get_property(&quot;number&quot;)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .unwrap()
</span><span class="boring">            .unwrap();
</span><span class="boring">        println!(&quot;The current number is {}&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we now click on one button, the &quot;number&quot; and &quot;label&quot; properties of the other button change as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_buttons.png"/></div>
<p>The final nice feature of properties is, that you can connect a callback to the event when a property gets changed.
We can do this like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, BoxBuilder};
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::{ParamFlags, ParamSpec, Value};
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">            static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">                vec![ParamSpec::int(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;number&quot;,
</span><span class="boring">                    // Minimum value
</span><span class="boring">                    i32::MIN,
</span><span class="boring">                    // Maximum value
</span><span class="boring">                    i32::MAX,
</span><span class="boring">                    // Default value
</span><span class="boring">                    0,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                )]
</span><span class="boring">            });
</span><span class="boring">            PROPERTIES.as_ref()
</span><span class="boring">        }
</span><span class="boring">        fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; {
</span><span class="boring">                    let input_number = value.get().unwrap().unwrap();
</span><span class="boring">                    self.number.replace(input_number);
</span><span class="boring">                }
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">            match pspec.get_name() {
</span><span class="boring">                &quot;number&quot; =&gt; self.number.borrow().to_value(),
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            let incremented_number = self.number.borrow().clone() + 1;
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number).unwrap();
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;label&quot;, &amp;button_2, &quot;label&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span>
    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
        let number = button
            .get_property(&quot;number&quot;)
            .unwrap()
            .get::&lt;i32&gt;()
            .unwrap()
            .unwrap();
        println!(&quot;The current number is {}&quot;, number);
    });
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = BoxBuilder::new()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, whenever the &quot;number&quot; property gets changed, the closure gets executed and prints the current value of &quot;number&quot;.</p>
<p>You will want to introduce properties to your custom GObjects whenever you want</p>
<ul>
<li>to allow consumers to be able to access internal state,</li>
<li>to bind state of (different) GObjects or</li>
<li>to notify consumers whenever the property gets set.</li>
</ul>
<h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>GObject signals are a system for registering callbacks for specific events.
For example, if we press on a button, the &quot;clicked&quot; signal will be emitted.
The signal then takes care that all the registered callbacks will be executed.</p>
<p><code>gtk-rs</code> provides convenience methods for registering callbacks.
In our &quot;Hello World&quot; example we <a href="../docs//trait.ButtonExt.html#tymethod.connect_clicked">connected</a> the &quot;clicked&quot; signal to a closure which sets the label of the button to &quot;Hello World&quot; as soon as it gets called.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindow::new(application);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we wanted to, we could have connected to it with the general (but much more verbose) <code>connect_local</code> method.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindow::new(application);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button
        .connect_local(&quot;clicked&quot;, false, move |args| {
            // Get the button from the arguments
            let button = args.get(0).unwrap().get::&lt;Button&gt;().unwrap().unwrap();
            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
            button.set_label(&quot;Hello World!&quot;);
            None
        })
        .unwrap();
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The advantage of <code>connect_local</code> is, that it also works with custom signals.</p>
<p>Let us see how we can create our own signals.
Again, we do that by extending our <code>CustomButton</code>.
First we override the necessary methods in <code>ObjectImpl</code>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::subclass::Signal;
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span>    // Trait shared by all GObjects
    impl ObjectImpl for CustomButton {
        fn constructed(&amp;self, obj: &amp;Self::Type) {
            self.parent_constructed(obj);
            obj.set_label(&amp;self.number.borrow().to_string());
        }

        fn signals() -&gt; &amp;'static [Signal] {
            static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
                vec![Signal::builder(
                    // Signal name
                    &quot;max-number-reached&quot;,
                    // Types of the values which will be sent to the receiver
                    &amp;[i32::static_type().into()],
                    // Type of the value the receiver sends back
                    &lt;()&gt;::static_type().into(),
                )
                .build()]
            });
            SIGNALS.as_ref()
        }
    }
<span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">    static MAX_NUMBER: i32 = 8;
</span><span class="boring">    // Trait shared by all buttons
</span><span class="boring">    impl ButtonImpl for CustomButton {
</span><span class="boring">        fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">            // Increase `number` by 1
</span><span class="boring">            *self.number.borrow_mut() += 1;
</span><span class="boring">            // If `number` reached `MAX_NUMBER`,
</span><span class="boring">            // emit &quot;max-number-reached&quot; signal and set `number` back to 0
</span><span class="boring">            if *self.number.borrow() == MAX_NUMBER {
</span><span class="boring">                button
</span><span class="boring">                    .emit_by_name(&quot;max-number-reached&quot;, &amp;[&amp;*self.number.borrow()])
</span><span class="boring">                    .unwrap();
</span><span class="boring">                self.number.replace(0);
</span><span class="boring">            }
</span><span class="boring">            // Set label of `button`
</span><span class="boring">            button.set_label(&amp;self.number.borrow().to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span><span class="boring">    button
</span><span class="boring">        .connect_local(&quot;max-number-reached&quot;, false, move |args| {
</span><span class="boring">            // Get the number from the arguments
</span><span class="boring">            // args.get(0) would return the `CustomButton` instance
</span><span class="boring">            let number = args.get(1).unwrap().get::&lt;i32&gt;().unwrap().unwrap();
</span><span class="boring">            println!(&quot;The maximum number {} has been reached&quot;, number);
</span><span class="boring">            None
</span><span class="boring">        })
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>signal</code> method is responsible for defining a set of signals.
In our case, we only create a single signal named &quot;max-number-reached&quot;.
When naming our signal, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
When emitted, it sends a single <code>i32</code> value and expects nothing in return.</p>
<p>We want the signal to be emitted, whenever <code>number</code> reaches <code>MAX_NUMBER</code>.
Together with the signal we send the value <code>number</code> currently holds.
After we did that, we set <code>number</code> back to 0.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Implementation of our custom GObject
</span><span class="boring">mod imp {
</span><span class="boring">    // Import parent scope
</span><span class="boring">    use super::*;
</span><span class="boring">    // Import necessary objects and traits for subclassing
</span><span class="boring">    use glib::subclass::Signal;
</span><span class="boring">    use gtk::subclass::prelude::*;
</span><span class="boring">    use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">    // Object holding the state
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct CustomButton {
</span><span class="boring">        number: RefCell&lt;i32&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // The central trait for subclassing a GObject
</span><span class="boring">    #[glib::object_subclass]
</span><span class="boring">    impl ObjectSubclass for CustomButton {
</span><span class="boring">        const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">        type Type = super::CustomButton;
</span><span class="boring">        type ParentType = gtk::Button;
</span><span class="boring">    }
</span><span class="boring">    // Trait shared by all GObjects
</span><span class="boring">    impl ObjectImpl for CustomButton {
</span><span class="boring">        fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">            self.parent_constructed(obj);
</span><span class="boring">            obj.set_label(&amp;self.number.borrow().to_string());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn signals() -&gt; &amp;'static [Signal] {
</span><span class="boring">            static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
</span><span class="boring">                vec![Signal::builder(
</span><span class="boring">                    // Signal name
</span><span class="boring">                    &quot;max-number-reached&quot;,
</span><span class="boring">                    // Types of the values which will be sent to the receiver
</span><span class="boring">                    &amp;[i32::static_type().into()],
</span><span class="boring">                    // Type of the value the receiver sends back
</span><span class="boring">                    &lt;()&gt;::static_type().into(),
</span><span class="boring">                )
</span><span class="boring">                .build()]
</span><span class="boring">            });
</span><span class="boring">            SIGNALS.as_ref()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Trait shared by all widgets
</span><span class="boring">    impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>    static MAX_NUMBER: i32 = 8;
    // Trait shared by all buttons
    impl ButtonImpl for CustomButton {
        fn clicked(&amp;self, button: &amp;Self::Type) {
            // Increase `number` by 1
            *self.number.borrow_mut() += 1;
            // If `number` reached `MAX_NUMBER`,
            // emit &quot;max-number-reached&quot; signal and set `number` back to 0
            if *self.number.borrow() == MAX_NUMBER {
                button
                    .emit_by_name(&quot;max-number-reached&quot;, &amp;[&amp;*self.number.borrow()])
                    .unwrap();
                self.number.replace(0);
            }
            // Set label of `button`
            button.set_label(&amp;self.number.borrow().to_string())
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
</span><span class="boring">        @extends gtk::Button, gtk::Widget;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        glib::Object::new(&amp;[]).expect(&quot;Failed to create Button&quot;)
</span><span class="boring">    }
</span><span class="boring">    pub fn with_label(label: &amp;str) -&gt; Self {
</span><span class="boring">        let button = Self::new();
</span><span class="boring">        button.set_label(label);
</span><span class="boring">        button
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span><span class="boring">    button
</span><span class="boring">        .connect_local(&quot;max-number-reached&quot;, false, move |args| {
</span><span class="boring">            // Get the number from the arguments
</span><span class="boring">            // args.get(0) would return the `CustomButton` instance
</span><span class="boring">            let number = args.get(1).unwrap().get::&lt;i32&gt;().unwrap().unwrap();
</span><span class="boring">            println!(&quot;The maximum number {} has been reached&quot;, number);
</span><span class="boring">            None
</span><span class="boring">        })
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we now press on the button, the number of its label increases until it reaches <code>MAX_NUMBER</code>.
Then it starts from 0 again and so on.</p>
<p>Custom signals are especially useful, if you want to notify consumers of your GObject that a certain event occurred.</p>
<h1 id="the-main-event-loop"><a class="header" href="#the-main-event-loop">The main event loop</a></h1>
<p>We now got comfortable using callbacks, but how do they actually work?
All of this happens asynchronously, so there must be something managing the events and scheduling the responses.
Unsurprisingly, this is called the main event loop.</p>
<div style="text-align:center"><img src="img/main_event_loop.png" /></div>
<p>The main loop manages all kinds of events — from mouse clicks and keyboard presses to file events.
It does all of that within the same thread.
Quickly iterating between all tasks gives the illusion of parallelism.
That is why you can move the window at the same time as a progress bar is growing.</p>
<p>However, you surely saw GUIs that became unresponsive, at least for a few seconds.
That happens when a single task takes too long.
Let us look at one example.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindowBuilder, ButtonBuilder};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);
    app.connect_activate(on_activate);

    // Run the application
    app.run();
}

// When the application is launched…
fn on_activate(application: &amp;Application) {
    // … create a new window …
    let window = ApplicationWindowBuilder::new()
        .application(application)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = ButtonBuilder::new()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect callback
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        std::thread::sleep(five_seconds);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>After we press the button, the GUI is completely frozen for five seconds.
We can't even move the window.
The <code>sleep</code> call is an artificial example,
but it is not unusual wanting to run a slightly longer operation in one go.
For that we just need to spawn a new thread and let the operation run there.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If you come from another language than Rust, you might be uncomfortable with the thought of spawning new threads before even looking at other options.
Luckily, Rust's safety guarantees allow you to stop worrying about the nasty bugs that concurrency tends to bring.</p>
<p>Normally we want to keep track of the work in the thread.
In our case, we don't want the user to spawn additional threads while an existing one is still running.
In order to achieve that we can create a channel.
The main loop allows us to send a message from multiple places to a single receiver at the main thread.
We want to send a <code>bool</code> to inform, whether we want the button to react to clicks or not.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect callback
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            sender.send(false).unwrap();
            let ten_seconds = Duration::from_secs(10);
            thread::sleep(ten_seconds);
            // Activate the button again
            sender.send(true).unwrap();
        });
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Spawning threads is not the only way to run operations asynchronously.
You can also let the main loop take care of running <code>async</code> functions.
If you do that from the main thread use <a href="http://gtk-rs.org/docs/glib/struct.MainContext.html#method.spawn_local"><code>spawn_local</code></a>, from other threads <a href="http://gtk-rs.org/docs/glib/struct.MainContext.html#method.spawn"><code>spawn</code></a> has to be used.
The converted code looks and behaves very similar to the multi-threaded code.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{clone, timeout_future_seconds, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect callback
    button.connect_clicked(move |_| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@strong sender =&gt; async move {
            // Deactivate the button until the operation is done
            sender.send(false).unwrap();
            timeout_future_seconds(5).await;
            // Activate the button again
            sender.send(true).unwrap();
        }));
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Since we are single-threaded again, we could even get rid of the channels while achieving the same result.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{clone, timeout_future_seconds, MainContext};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |button| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@weak button =&gt; async move {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            timeout_future_seconds(5).await;
            // Activate the button again
            button.set_sensitive(true);
        }));
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>But why did we not do the same thing with our multi-threaded example?</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindowBuilder, ButtonBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = ButtonBuilder::new()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE
    
    // Connect callback
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Simply because we would get this error message:</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>After reference cycles we found the second disadvantage of GTK GObjects: They are not thread safe.</p>
<p>So when should you spawn an <code>async</code> block and when should you spawn a thread?</p>
<ul>
<li>If you have <code>async</code> functions for your IO-bound operations at your disposal, feel free to spawn them on the main loop.</li>
<li>If your operation is computation-bound or there is no <code>async</code> function available, you have to spawn threads.</li>
</ul>
<h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>We have now learned multiple ways to handle states.
However, every time we close the application all of it is gone.
Let us learn how to use <code>GSettings</code> by storing the state of a <a href="https://gtk-rs.org/gtk4-rs/gtk4/struct.Switch.html"><code>Switch</code></a> in it.</p>
<p>At the very beginning we have to create a <code>GSchema</code> xml file in order to describe the kind of data our application plans to store in the settings.</p>
<p><span class="filename">Filename: org.gtk.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk.example&quot; path=&quot;/org/gtk/example/&quot;&gt;
    &lt;key name=&quot;is-switch-enabled&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default switch state&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Let us get through it step by step.
The <code>id</code> is the same application id we used when we created our application.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindowBuilder, SwitchBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
        .expect(&quot;Initialization failed...&quot;);
<span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.get_boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = SwitchBuilder::new()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .unwrap();
</span><span class="boring">        // We do not want to inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>path</code> must start and end with a forward slash character ('/') and must not contain two sequential slash characters.
When creating a <code>path</code>, we advise to take the <code>id</code>, replace the '.' with '/' and add '/' at the front and end of it.</p>
<p>We only want to store a single key with the <code>name</code> &quot;is-switch-enabled&quot;.
This is a boolean value so its <code>type</code> is &quot;b&quot; (see <a href="https://developer.gnome.org/glib/stable/gvariant-format-strings.html">GVariant Format Strings</a> for the other options).
Finally, we define its default value and add a summary.</p>
<p>Now we have to install the <code>GSchema</code> by executing the following commands:</p>
<pre><code class="language-bash">$ sudo install -D org.gtk.example.gschema.xml /usr/share/glib-2.0/schemas/
$ sudo glib-compile-schemas /usr/share/glib-2.0/schemas/
</code></pre>
<p>This has to be repeated every time we change the <code>GSchema</code>.
That is why we probably want to use a build system like <a href="https://mesonbuild.com/">Meson</a> to do it for us.</p>
<p>We initialize the <code>Settings</code> object by specifying the application id.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindowBuilder, SwitchBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Initialize settings
    let settings = Settings::new(&quot;org.gtk.example&quot;);
<span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.get_boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = SwitchBuilder::new()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .unwrap();
</span><span class="boring">        // We do not want to inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Then we get the settings key and use it when we create our <code>Switch</code>.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindowBuilder, SwitchBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span>    // Get the last switch state from the settings
    let is_switch_enabled = settings.get_boolean(&quot;is-switch-enabled&quot;);

    // Create a switch
    let switch = SwitchBuilder::new()
        .margin_top(48)
        .margin_bottom(48)
        .margin_start(48)
        .margin_end(48)
        .valign(Align::Center)
        .halign(Align::Center)
        .state(is_switch_enabled)
        .build();
<span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .unwrap();
</span><span class="boring">        // We do not want to inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Finally, we assure that the switch state is stored in the settings whenever we click on it.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindowBuilder, SwitchBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.get_boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = SwitchBuilder::new()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    switch.connect_state_set(move |_, is_enabled| {
        // Save changed switch state in the settings
        settings
            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
            .unwrap();
        // We do not want to inhibit the the default handler
        Inhibit(false)
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>Switch</code> now retains its state even after closing the application.
But we can make this even better.
The <code>Switch</code> has a property &quot;state&quot; and <code>Settings</code> allows us to bind properties to a specific setting.
So let us do exactly that.</p>
<p>We can remove the <code>get_boolean</code> call before initializing the <code>Switch</code> as well as the <code>connect_state_set</code> call.
We then bind the setting to the property by specifying the key, object and name of the property.
We also specify <a href="https://gtk-rs.org/docs/gio/struct.SettingsBindFlags.html"><code>SettingsBindFlags</code></a> to control the direction in which the binding works.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::{Settings, SettingsBindFlags};
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Application, ApplicationWindowBuilder, SwitchBuilder};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default())
</span><span class="boring">        .expect(&quot;Initialization failed...&quot;);
</span><span class="boring">    app.connect_activate(on_activate);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn on_activate(application: &amp;Application) {
</span><span class="boring">    // … create a new window …
</span><span class="boring">    let window = ApplicationWindowBuilder::new()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = SwitchBuilder::new()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    settings
        .bind(&quot;is-switch-enabled&quot;, &amp;switch, &quot;state&quot;)
        .flags(SettingsBindFlags::DEFAULT)
        .build();
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Whenever you have a property which nicely correspond to a setting, you probably want to bind it to it.
In other cases, interacting with the settings via the getter and setter methods tends to be the right choice.</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
