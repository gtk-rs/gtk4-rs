// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskBlendMode")]
pub enum BlendMode {
    #[doc(alias = "GSK_BLEND_MODE_DEFAULT")]
    Default,
    #[doc(alias = "GSK_BLEND_MODE_MULTIPLY")]
    Multiply,
    #[doc(alias = "GSK_BLEND_MODE_SCREEN")]
    Screen,
    #[doc(alias = "GSK_BLEND_MODE_OVERLAY")]
    Overlay,
    #[doc(alias = "GSK_BLEND_MODE_DARKEN")]
    Darken,
    #[doc(alias = "GSK_BLEND_MODE_LIGHTEN")]
    Lighten,
    #[doc(alias = "GSK_BLEND_MODE_COLOR_DODGE")]
    ColorDodge,
    #[doc(alias = "GSK_BLEND_MODE_COLOR_BURN")]
    ColorBurn,
    #[doc(alias = "GSK_BLEND_MODE_HARD_LIGHT")]
    HardLight,
    #[doc(alias = "GSK_BLEND_MODE_SOFT_LIGHT")]
    SoftLight,
    #[doc(alias = "GSK_BLEND_MODE_DIFFERENCE")]
    Difference,
    #[doc(alias = "GSK_BLEND_MODE_EXCLUSION")]
    Exclusion,
    #[doc(alias = "GSK_BLEND_MODE_COLOR")]
    Color,
    #[doc(alias = "GSK_BLEND_MODE_HUE")]
    Hue,
    #[doc(alias = "GSK_BLEND_MODE_SATURATION")]
    Saturation,
    #[doc(alias = "GSK_BLEND_MODE_LUMINOSITY")]
    Luminosity,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BlendMode {
    type GlibType = ffi::GskBlendMode;

    fn into_glib(self) -> ffi::GskBlendMode {
        match self {
            Self::Default => ffi::GSK_BLEND_MODE_DEFAULT,
            Self::Multiply => ffi::GSK_BLEND_MODE_MULTIPLY,
            Self::Screen => ffi::GSK_BLEND_MODE_SCREEN,
            Self::Overlay => ffi::GSK_BLEND_MODE_OVERLAY,
            Self::Darken => ffi::GSK_BLEND_MODE_DARKEN,
            Self::Lighten => ffi::GSK_BLEND_MODE_LIGHTEN,
            Self::ColorDodge => ffi::GSK_BLEND_MODE_COLOR_DODGE,
            Self::ColorBurn => ffi::GSK_BLEND_MODE_COLOR_BURN,
            Self::HardLight => ffi::GSK_BLEND_MODE_HARD_LIGHT,
            Self::SoftLight => ffi::GSK_BLEND_MODE_SOFT_LIGHT,
            Self::Difference => ffi::GSK_BLEND_MODE_DIFFERENCE,
            Self::Exclusion => ffi::GSK_BLEND_MODE_EXCLUSION,
            Self::Color => ffi::GSK_BLEND_MODE_COLOR,
            Self::Hue => ffi::GSK_BLEND_MODE_HUE,
            Self::Saturation => ffi::GSK_BLEND_MODE_SATURATION,
            Self::Luminosity => ffi::GSK_BLEND_MODE_LUMINOSITY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskBlendMode> for BlendMode {
    unsafe fn from_glib(value: ffi::GskBlendMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_BLEND_MODE_DEFAULT => Self::Default,
            ffi::GSK_BLEND_MODE_MULTIPLY => Self::Multiply,
            ffi::GSK_BLEND_MODE_SCREEN => Self::Screen,
            ffi::GSK_BLEND_MODE_OVERLAY => Self::Overlay,
            ffi::GSK_BLEND_MODE_DARKEN => Self::Darken,
            ffi::GSK_BLEND_MODE_LIGHTEN => Self::Lighten,
            ffi::GSK_BLEND_MODE_COLOR_DODGE => Self::ColorDodge,
            ffi::GSK_BLEND_MODE_COLOR_BURN => Self::ColorBurn,
            ffi::GSK_BLEND_MODE_HARD_LIGHT => Self::HardLight,
            ffi::GSK_BLEND_MODE_SOFT_LIGHT => Self::SoftLight,
            ffi::GSK_BLEND_MODE_DIFFERENCE => Self::Difference,
            ffi::GSK_BLEND_MODE_EXCLUSION => Self::Exclusion,
            ffi::GSK_BLEND_MODE_COLOR => Self::Color,
            ffi::GSK_BLEND_MODE_HUE => Self::Hue,
            ffi::GSK_BLEND_MODE_SATURATION => Self::Saturation,
            ffi::GSK_BLEND_MODE_LUMINOSITY => Self::Luminosity,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BlendMode {
    #[inline]
    #[doc(alias = "gsk_blend_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_blend_mode_get_type()) }
    }
}

impl glib::HasParamSpec for BlendMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BlendMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BlendMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BlendMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BlendMode> for glib::Value {
    #[inline]
    fn from(v: BlendMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskCorner")]
pub enum Corner {
    #[doc(alias = "GSK_CORNER_TOP_LEFT")]
    TopLeft,
    #[doc(alias = "GSK_CORNER_TOP_RIGHT")]
    TopRight,
    #[doc(alias = "GSK_CORNER_BOTTOM_RIGHT")]
    BottomRight,
    #[doc(alias = "GSK_CORNER_BOTTOM_LEFT")]
    BottomLeft,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Corner {
    type GlibType = ffi::GskCorner;

    #[inline]
    fn into_glib(self) -> ffi::GskCorner {
        match self {
            Self::TopLeft => ffi::GSK_CORNER_TOP_LEFT,
            Self::TopRight => ffi::GSK_CORNER_TOP_RIGHT,
            Self::BottomRight => ffi::GSK_CORNER_BOTTOM_RIGHT,
            Self::BottomLeft => ffi::GSK_CORNER_BOTTOM_LEFT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskCorner> for Corner {
    #[inline]
    unsafe fn from_glib(value: ffi::GskCorner) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_CORNER_TOP_LEFT => Self::TopLeft,
            ffi::GSK_CORNER_TOP_RIGHT => Self::TopRight,
            ffi::GSK_CORNER_BOTTOM_RIGHT => Self::BottomRight,
            ffi::GSK_CORNER_BOTTOM_LEFT => Self::BottomLeft,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Corner {
    #[inline]
    #[doc(alias = "gsk_corner_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_corner_get_type()) }
    }
}

impl glib::HasParamSpec for Corner {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Corner {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Corner {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Corner {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Corner> for glib::Value {
    #[inline]
    fn from(v: Corner) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskFillRule")]
pub enum FillRule {
    #[doc(alias = "GSK_FILL_RULE_WINDING")]
    Winding,
    #[doc(alias = "GSK_FILL_RULE_EVEN_ODD")]
    EvenOdd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for FillRule {
    type GlibType = ffi::GskFillRule;

    #[inline]
    fn into_glib(self) -> ffi::GskFillRule {
        match self {
            Self::Winding => ffi::GSK_FILL_RULE_WINDING,
            Self::EvenOdd => ffi::GSK_FILL_RULE_EVEN_ODD,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GskFillRule> for FillRule {
    #[inline]
    unsafe fn from_glib(value: ffi::GskFillRule) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_FILL_RULE_WINDING => Self::Winding,
            ffi::GSK_FILL_RULE_EVEN_ODD => Self::EvenOdd,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for FillRule {
    #[inline]
    #[doc(alias = "gsk_fill_rule_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_fill_rule_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for FillRule {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for FillRule {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for FillRule {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for FillRule {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<FillRule> for glib::Value {
    #[inline]
    fn from(v: FillRule) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskGLUniformType")]
pub enum GLUniformType {
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_NONE")]
    None,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_FLOAT")]
    Float,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_INT")]
    Int,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_UINT")]
    Uint,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_BOOL")]
    Bool,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_VEC2")]
    Vec2,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_VEC3")]
    Vec3,
    #[doc(alias = "GSK_GL_UNIFORM_TYPE_VEC4")]
    Vec4,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GLUniformType {
    type GlibType = ffi::GskGLUniformType;

    #[inline]
    fn into_glib(self) -> ffi::GskGLUniformType {
        match self {
            Self::None => ffi::GSK_GL_UNIFORM_TYPE_NONE,
            Self::Float => ffi::GSK_GL_UNIFORM_TYPE_FLOAT,
            Self::Int => ffi::GSK_GL_UNIFORM_TYPE_INT,
            Self::Uint => ffi::GSK_GL_UNIFORM_TYPE_UINT,
            Self::Bool => ffi::GSK_GL_UNIFORM_TYPE_BOOL,
            Self::Vec2 => ffi::GSK_GL_UNIFORM_TYPE_VEC2,
            Self::Vec3 => ffi::GSK_GL_UNIFORM_TYPE_VEC3,
            Self::Vec4 => ffi::GSK_GL_UNIFORM_TYPE_VEC4,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskGLUniformType> for GLUniformType {
    #[inline]
    unsafe fn from_glib(value: ffi::GskGLUniformType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_GL_UNIFORM_TYPE_NONE => Self::None,
            ffi::GSK_GL_UNIFORM_TYPE_FLOAT => Self::Float,
            ffi::GSK_GL_UNIFORM_TYPE_INT => Self::Int,
            ffi::GSK_GL_UNIFORM_TYPE_UINT => Self::Uint,
            ffi::GSK_GL_UNIFORM_TYPE_BOOL => Self::Bool,
            ffi::GSK_GL_UNIFORM_TYPE_VEC2 => Self::Vec2,
            ffi::GSK_GL_UNIFORM_TYPE_VEC3 => Self::Vec3,
            ffi::GSK_GL_UNIFORM_TYPE_VEC4 => Self::Vec4,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for GLUniformType {
    #[inline]
    #[doc(alias = "gsk_gl_uniform_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_gl_uniform_type_get_type()) }
    }
}

impl glib::HasParamSpec for GLUniformType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for GLUniformType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GLUniformType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for GLUniformType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<GLUniformType> for glib::Value {
    #[inline]
    fn from(v: GLUniformType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskLineCap")]
pub enum LineCap {
    #[doc(alias = "GSK_LINE_CAP_BUTT")]
    Butt,
    #[doc(alias = "GSK_LINE_CAP_ROUND")]
    Round,
    #[doc(alias = "GSK_LINE_CAP_SQUARE")]
    Square,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for LineCap {
    type GlibType = ffi::GskLineCap;

    #[inline]
    fn into_glib(self) -> ffi::GskLineCap {
        match self {
            Self::Butt => ffi::GSK_LINE_CAP_BUTT,
            Self::Round => ffi::GSK_LINE_CAP_ROUND,
            Self::Square => ffi::GSK_LINE_CAP_SQUARE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GskLineCap> for LineCap {
    #[inline]
    unsafe fn from_glib(value: ffi::GskLineCap) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_LINE_CAP_BUTT => Self::Butt,
            ffi::GSK_LINE_CAP_ROUND => Self::Round,
            ffi::GSK_LINE_CAP_SQUARE => Self::Square,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for LineCap {
    #[inline]
    #[doc(alias = "gsk_line_cap_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_line_cap_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for LineCap {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for LineCap {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for LineCap {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for LineCap {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<LineCap> for glib::Value {
    #[inline]
    fn from(v: LineCap) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskLineJoin")]
pub enum LineJoin {
    #[doc(alias = "GSK_LINE_JOIN_MITER")]
    Miter,
    #[doc(alias = "GSK_LINE_JOIN_ROUND")]
    Round,
    #[doc(alias = "GSK_LINE_JOIN_BEVEL")]
    Bevel,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for LineJoin {
    type GlibType = ffi::GskLineJoin;

    #[inline]
    fn into_glib(self) -> ffi::GskLineJoin {
        match self {
            Self::Miter => ffi::GSK_LINE_JOIN_MITER,
            Self::Round => ffi::GSK_LINE_JOIN_ROUND,
            Self::Bevel => ffi::GSK_LINE_JOIN_BEVEL,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GskLineJoin> for LineJoin {
    #[inline]
    unsafe fn from_glib(value: ffi::GskLineJoin) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_LINE_JOIN_MITER => Self::Miter,
            ffi::GSK_LINE_JOIN_ROUND => Self::Round,
            ffi::GSK_LINE_JOIN_BEVEL => Self::Bevel,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for LineJoin {
    #[inline]
    #[doc(alias = "gsk_line_join_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_line_join_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for LineJoin {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for LineJoin {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for LineJoin {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for LineJoin {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<LineJoin> for glib::Value {
    #[inline]
    fn from(v: LineJoin) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskMaskMode")]
pub enum MaskMode {
    #[doc(alias = "GSK_MASK_MODE_ALPHA")]
    Alpha,
    #[doc(alias = "GSK_MASK_MODE_INVERTED_ALPHA")]
    InvertedAlpha,
    #[doc(alias = "GSK_MASK_MODE_LUMINANCE")]
    Luminance,
    #[doc(alias = "GSK_MASK_MODE_INVERTED_LUMINANCE")]
    InvertedLuminance,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl IntoGlib for MaskMode {
    type GlibType = ffi::GskMaskMode;

    #[inline]
    fn into_glib(self) -> ffi::GskMaskMode {
        match self {
            Self::Alpha => ffi::GSK_MASK_MODE_ALPHA,
            Self::InvertedAlpha => ffi::GSK_MASK_MODE_INVERTED_ALPHA,
            Self::Luminance => ffi::GSK_MASK_MODE_LUMINANCE,
            Self::InvertedLuminance => ffi::GSK_MASK_MODE_INVERTED_LUMINANCE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GskMaskMode> for MaskMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GskMaskMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_MASK_MODE_ALPHA => Self::Alpha,
            ffi::GSK_MASK_MODE_INVERTED_ALPHA => Self::InvertedAlpha,
            ffi::GSK_MASK_MODE_LUMINANCE => Self::Luminance,
            ffi::GSK_MASK_MODE_INVERTED_LUMINANCE => Self::InvertedLuminance,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl StaticType for MaskMode {
    #[inline]
    #[doc(alias = "gsk_mask_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_mask_mode_get_type()) }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::HasParamSpec for MaskMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::value::ValueType for MaskMode {
    type Type = Self;
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for MaskMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl ToValue for MaskMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl From<MaskMode> for glib::Value {
    #[inline]
    fn from(v: MaskMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskPathDirection")]
pub enum PathDirection {
    #[doc(alias = "GSK_PATH_FROM_START")]
    FromStart,
    #[doc(alias = "GSK_PATH_TO_START")]
    ToStart,
    #[doc(alias = "GSK_PATH_TO_END")]
    ToEnd,
    #[doc(alias = "GSK_PATH_FROM_END")]
    FromEnd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for PathDirection {
    type GlibType = ffi::GskPathDirection;

    #[inline]
    fn into_glib(self) -> ffi::GskPathDirection {
        match self {
            Self::FromStart => ffi::GSK_PATH_FROM_START,
            Self::ToStart => ffi::GSK_PATH_TO_START,
            Self::ToEnd => ffi::GSK_PATH_TO_END,
            Self::FromEnd => ffi::GSK_PATH_FROM_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GskPathDirection> for PathDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::GskPathDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_PATH_FROM_START => Self::FromStart,
            ffi::GSK_PATH_TO_START => Self::ToStart,
            ffi::GSK_PATH_TO_END => Self::ToEnd,
            ffi::GSK_PATH_FROM_END => Self::FromEnd,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for PathDirection {
    #[inline]
    #[doc(alias = "gsk_path_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_path_direction_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for PathDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for PathDirection {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for PathDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for PathDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<PathDirection> for glib::Value {
    #[inline]
    fn from(v: PathDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskPathOperation")]
pub enum PathOperation {
    #[doc(alias = "GSK_PATH_MOVE")]
    Move,
    #[doc(alias = "GSK_PATH_CLOSE")]
    Close,
    #[doc(alias = "GSK_PATH_LINE")]
    Line,
    #[doc(alias = "GSK_PATH_QUAD")]
    Quad,
    #[doc(alias = "GSK_PATH_CUBIC")]
    Cubic,
    #[doc(alias = "GSK_PATH_CONIC")]
    Conic,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for PathOperation {
    type GlibType = ffi::GskPathOperation;

    #[inline]
    fn into_glib(self) -> ffi::GskPathOperation {
        match self {
            Self::Move => ffi::GSK_PATH_MOVE,
            Self::Close => ffi::GSK_PATH_CLOSE,
            Self::Line => ffi::GSK_PATH_LINE,
            Self::Quad => ffi::GSK_PATH_QUAD,
            Self::Cubic => ffi::GSK_PATH_CUBIC,
            Self::Conic => ffi::GSK_PATH_CONIC,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GskPathOperation> for PathOperation {
    #[inline]
    unsafe fn from_glib(value: ffi::GskPathOperation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_PATH_MOVE => Self::Move,
            ffi::GSK_PATH_CLOSE => Self::Close,
            ffi::GSK_PATH_LINE => Self::Line,
            ffi::GSK_PATH_QUAD => Self::Quad,
            ffi::GSK_PATH_CUBIC => Self::Cubic,
            ffi::GSK_PATH_CONIC => Self::Conic,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for PathOperation {
    #[inline]
    #[doc(alias = "gsk_path_operation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_path_operation_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for PathOperation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for PathOperation {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for PathOperation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for PathOperation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<PathOperation> for glib::Value {
    #[inline]
    fn from(v: PathOperation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskRenderNodeType")]
pub enum RenderNodeType {
    #[doc(alias = "GSK_NOT_A_RENDER_NODE")]
    NotARenderNode,
    #[doc(alias = "GSK_CONTAINER_NODE")]
    ContainerNode,
    #[doc(alias = "GSK_CAIRO_NODE")]
    CairoNode,
    #[doc(alias = "GSK_COLOR_NODE")]
    ColorNode,
    #[doc(alias = "GSK_LINEAR_GRADIENT_NODE")]
    LinearGradientNode,
    #[doc(alias = "GSK_REPEATING_LINEAR_GRADIENT_NODE")]
    RepeatingLinearGradientNode,
    #[doc(alias = "GSK_RADIAL_GRADIENT_NODE")]
    RadialGradientNode,
    #[doc(alias = "GSK_REPEATING_RADIAL_GRADIENT_NODE")]
    RepeatingRadialGradientNode,
    #[doc(alias = "GSK_CONIC_GRADIENT_NODE")]
    ConicGradientNode,
    #[doc(alias = "GSK_BORDER_NODE")]
    BorderNode,
    #[doc(alias = "GSK_TEXTURE_NODE")]
    TextureNode,
    #[doc(alias = "GSK_INSET_SHADOW_NODE")]
    InsetShadowNode,
    #[doc(alias = "GSK_OUTSET_SHADOW_NODE")]
    OutsetShadowNode,
    #[doc(alias = "GSK_TRANSFORM_NODE")]
    TransformNode,
    #[doc(alias = "GSK_OPACITY_NODE")]
    OpacityNode,
    #[doc(alias = "GSK_COLOR_MATRIX_NODE")]
    ColorMatrixNode,
    #[doc(alias = "GSK_REPEAT_NODE")]
    RepeatNode,
    #[doc(alias = "GSK_CLIP_NODE")]
    ClipNode,
    #[doc(alias = "GSK_ROUNDED_CLIP_NODE")]
    RoundedClipNode,
    #[doc(alias = "GSK_SHADOW_NODE")]
    ShadowNode,
    #[doc(alias = "GSK_BLEND_NODE")]
    BlendNode,
    #[doc(alias = "GSK_CROSS_FADE_NODE")]
    CrossFadeNode,
    #[doc(alias = "GSK_TEXT_NODE")]
    TextNode,
    #[doc(alias = "GSK_BLUR_NODE")]
    BlurNode,
    #[doc(alias = "GSK_DEBUG_NODE")]
    DebugNode,
    #[doc(alias = "GSK_GL_SHADER_NODE")]
    GlShaderNode,
    #[cfg(feature = "v4_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
    #[doc(alias = "GSK_TEXTURE_SCALE_NODE")]
    TextureScaleNode,
    #[cfg(feature = "v4_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
    #[doc(alias = "GSK_MASK_NODE")]
    MaskNode,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GSK_FILL_NODE")]
    FillNode,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GSK_STROKE_NODE")]
    StrokeNode,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GSK_SUBSURFACE_NODE")]
    SubsurfaceNode,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RenderNodeType {
    type GlibType = ffi::GskRenderNodeType;

    fn into_glib(self) -> ffi::GskRenderNodeType {
        match self {
            Self::NotARenderNode => ffi::GSK_NOT_A_RENDER_NODE,
            Self::ContainerNode => ffi::GSK_CONTAINER_NODE,
            Self::CairoNode => ffi::GSK_CAIRO_NODE,
            Self::ColorNode => ffi::GSK_COLOR_NODE,
            Self::LinearGradientNode => ffi::GSK_LINEAR_GRADIENT_NODE,
            Self::RepeatingLinearGradientNode => ffi::GSK_REPEATING_LINEAR_GRADIENT_NODE,
            Self::RadialGradientNode => ffi::GSK_RADIAL_GRADIENT_NODE,
            Self::RepeatingRadialGradientNode => ffi::GSK_REPEATING_RADIAL_GRADIENT_NODE,
            Self::ConicGradientNode => ffi::GSK_CONIC_GRADIENT_NODE,
            Self::BorderNode => ffi::GSK_BORDER_NODE,
            Self::TextureNode => ffi::GSK_TEXTURE_NODE,
            Self::InsetShadowNode => ffi::GSK_INSET_SHADOW_NODE,
            Self::OutsetShadowNode => ffi::GSK_OUTSET_SHADOW_NODE,
            Self::TransformNode => ffi::GSK_TRANSFORM_NODE,
            Self::OpacityNode => ffi::GSK_OPACITY_NODE,
            Self::ColorMatrixNode => ffi::GSK_COLOR_MATRIX_NODE,
            Self::RepeatNode => ffi::GSK_REPEAT_NODE,
            Self::ClipNode => ffi::GSK_CLIP_NODE,
            Self::RoundedClipNode => ffi::GSK_ROUNDED_CLIP_NODE,
            Self::ShadowNode => ffi::GSK_SHADOW_NODE,
            Self::BlendNode => ffi::GSK_BLEND_NODE,
            Self::CrossFadeNode => ffi::GSK_CROSS_FADE_NODE,
            Self::TextNode => ffi::GSK_TEXT_NODE,
            Self::BlurNode => ffi::GSK_BLUR_NODE,
            Self::DebugNode => ffi::GSK_DEBUG_NODE,
            Self::GlShaderNode => ffi::GSK_GL_SHADER_NODE,
            #[cfg(feature = "v4_10")]
            Self::TextureScaleNode => ffi::GSK_TEXTURE_SCALE_NODE,
            #[cfg(feature = "v4_10")]
            Self::MaskNode => ffi::GSK_MASK_NODE,
            #[cfg(feature = "v4_14")]
            Self::FillNode => ffi::GSK_FILL_NODE,
            #[cfg(feature = "v4_14")]
            Self::StrokeNode => ffi::GSK_STROKE_NODE,
            #[cfg(feature = "v4_14")]
            Self::SubsurfaceNode => ffi::GSK_SUBSURFACE_NODE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskRenderNodeType> for RenderNodeType {
    unsafe fn from_glib(value: ffi::GskRenderNodeType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_NOT_A_RENDER_NODE => Self::NotARenderNode,
            ffi::GSK_CONTAINER_NODE => Self::ContainerNode,
            ffi::GSK_CAIRO_NODE => Self::CairoNode,
            ffi::GSK_COLOR_NODE => Self::ColorNode,
            ffi::GSK_LINEAR_GRADIENT_NODE => Self::LinearGradientNode,
            ffi::GSK_REPEATING_LINEAR_GRADIENT_NODE => Self::RepeatingLinearGradientNode,
            ffi::GSK_RADIAL_GRADIENT_NODE => Self::RadialGradientNode,
            ffi::GSK_REPEATING_RADIAL_GRADIENT_NODE => Self::RepeatingRadialGradientNode,
            ffi::GSK_CONIC_GRADIENT_NODE => Self::ConicGradientNode,
            ffi::GSK_BORDER_NODE => Self::BorderNode,
            ffi::GSK_TEXTURE_NODE => Self::TextureNode,
            ffi::GSK_INSET_SHADOW_NODE => Self::InsetShadowNode,
            ffi::GSK_OUTSET_SHADOW_NODE => Self::OutsetShadowNode,
            ffi::GSK_TRANSFORM_NODE => Self::TransformNode,
            ffi::GSK_OPACITY_NODE => Self::OpacityNode,
            ffi::GSK_COLOR_MATRIX_NODE => Self::ColorMatrixNode,
            ffi::GSK_REPEAT_NODE => Self::RepeatNode,
            ffi::GSK_CLIP_NODE => Self::ClipNode,
            ffi::GSK_ROUNDED_CLIP_NODE => Self::RoundedClipNode,
            ffi::GSK_SHADOW_NODE => Self::ShadowNode,
            ffi::GSK_BLEND_NODE => Self::BlendNode,
            ffi::GSK_CROSS_FADE_NODE => Self::CrossFadeNode,
            ffi::GSK_TEXT_NODE => Self::TextNode,
            ffi::GSK_BLUR_NODE => Self::BlurNode,
            ffi::GSK_DEBUG_NODE => Self::DebugNode,
            ffi::GSK_GL_SHADER_NODE => Self::GlShaderNode,
            #[cfg(feature = "v4_10")]
            ffi::GSK_TEXTURE_SCALE_NODE => Self::TextureScaleNode,
            #[cfg(feature = "v4_10")]
            ffi::GSK_MASK_NODE => Self::MaskNode,
            #[cfg(feature = "v4_14")]
            ffi::GSK_FILL_NODE => Self::FillNode,
            #[cfg(feature = "v4_14")]
            ffi::GSK_STROKE_NODE => Self::StrokeNode,
            #[cfg(feature = "v4_14")]
            ffi::GSK_SUBSURFACE_NODE => Self::SubsurfaceNode,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for RenderNodeType {
    #[inline]
    #[doc(alias = "gsk_render_node_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_render_node_type_get_type()) }
    }
}

impl glib::HasParamSpec for RenderNodeType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for RenderNodeType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RenderNodeType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RenderNodeType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RenderNodeType> for glib::Value {
    #[inline]
    fn from(v: RenderNodeType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskScalingFilter")]
pub enum ScalingFilter {
    #[doc(alias = "GSK_SCALING_FILTER_LINEAR")]
    Linear,
    #[doc(alias = "GSK_SCALING_FILTER_NEAREST")]
    Nearest,
    #[doc(alias = "GSK_SCALING_FILTER_TRILINEAR")]
    Trilinear,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ScalingFilter {
    type GlibType = ffi::GskScalingFilter;

    #[inline]
    fn into_glib(self) -> ffi::GskScalingFilter {
        match self {
            Self::Linear => ffi::GSK_SCALING_FILTER_LINEAR,
            Self::Nearest => ffi::GSK_SCALING_FILTER_NEAREST,
            Self::Trilinear => ffi::GSK_SCALING_FILTER_TRILINEAR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskScalingFilter> for ScalingFilter {
    #[inline]
    unsafe fn from_glib(value: ffi::GskScalingFilter) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_SCALING_FILTER_LINEAR => Self::Linear,
            ffi::GSK_SCALING_FILTER_NEAREST => Self::Nearest,
            ffi::GSK_SCALING_FILTER_TRILINEAR => Self::Trilinear,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ScalingFilter {
    #[inline]
    #[doc(alias = "gsk_scaling_filter_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_scaling_filter_get_type()) }
    }
}

impl glib::HasParamSpec for ScalingFilter {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ScalingFilter {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ScalingFilter {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ScalingFilter {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ScalingFilter> for glib::Value {
    #[inline]
    fn from(v: ScalingFilter) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskSerializationError")]
pub enum SerializationError {
    #[doc(alias = "GSK_SERIALIZATION_UNSUPPORTED_FORMAT")]
    UnsupportedFormat,
    #[doc(alias = "GSK_SERIALIZATION_UNSUPPORTED_VERSION")]
    UnsupportedVersion,
    #[doc(alias = "GSK_SERIALIZATION_INVALID_DATA")]
    InvalidData,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SerializationError {
    type GlibType = ffi::GskSerializationError;

    #[inline]
    fn into_glib(self) -> ffi::GskSerializationError {
        match self {
            Self::UnsupportedFormat => ffi::GSK_SERIALIZATION_UNSUPPORTED_FORMAT,
            Self::UnsupportedVersion => ffi::GSK_SERIALIZATION_UNSUPPORTED_VERSION,
            Self::InvalidData => ffi::GSK_SERIALIZATION_INVALID_DATA,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskSerializationError> for SerializationError {
    #[inline]
    unsafe fn from_glib(value: ffi::GskSerializationError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_SERIALIZATION_UNSUPPORTED_FORMAT => Self::UnsupportedFormat,
            ffi::GSK_SERIALIZATION_UNSUPPORTED_VERSION => Self::UnsupportedVersion,
            ffi::GSK_SERIALIZATION_INVALID_DATA => Self::InvalidData,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for SerializationError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gsk_serialization_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for SerializationError {
    #[inline]
    #[doc(alias = "gsk_serialization_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_serialization_error_get_type()) }
    }
}

impl glib::HasParamSpec for SerializationError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SerializationError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SerializationError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SerializationError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SerializationError> for glib::Value {
    #[inline]
    fn from(v: SerializationError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GskTransformCategory")]
pub enum TransformCategory {
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_UNKNOWN")]
    Unknown,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_ANY")]
    Any,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_3D")]
    _3d,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_2D")]
    _2d,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_2D_AFFINE")]
    _2dAffine,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_2D_TRANSLATE")]
    _2dTranslate,
    #[doc(alias = "GSK_TRANSFORM_CATEGORY_IDENTITY")]
    Identity,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransformCategory {
    type GlibType = ffi::GskTransformCategory;

    #[inline]
    fn into_glib(self) -> ffi::GskTransformCategory {
        match self {
            Self::Unknown => ffi::GSK_TRANSFORM_CATEGORY_UNKNOWN,
            Self::Any => ffi::GSK_TRANSFORM_CATEGORY_ANY,
            Self::_3d => ffi::GSK_TRANSFORM_CATEGORY_3D,
            Self::_2d => ffi::GSK_TRANSFORM_CATEGORY_2D,
            Self::_2dAffine => ffi::GSK_TRANSFORM_CATEGORY_2D_AFFINE,
            Self::_2dTranslate => ffi::GSK_TRANSFORM_CATEGORY_2D_TRANSLATE,
            Self::Identity => ffi::GSK_TRANSFORM_CATEGORY_IDENTITY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GskTransformCategory> for TransformCategory {
    #[inline]
    unsafe fn from_glib(value: ffi::GskTransformCategory) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GSK_TRANSFORM_CATEGORY_UNKNOWN => Self::Unknown,
            ffi::GSK_TRANSFORM_CATEGORY_ANY => Self::Any,
            ffi::GSK_TRANSFORM_CATEGORY_3D => Self::_3d,
            ffi::GSK_TRANSFORM_CATEGORY_2D => Self::_2d,
            ffi::GSK_TRANSFORM_CATEGORY_2D_AFFINE => Self::_2dAffine,
            ffi::GSK_TRANSFORM_CATEGORY_2D_TRANSLATE => Self::_2dTranslate,
            ffi::GSK_TRANSFORM_CATEGORY_IDENTITY => Self::Identity,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransformCategory {
    #[inline]
    #[doc(alias = "gsk_transform_category_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gsk_transform_category_get_type()) }
    }
}

impl glib::HasParamSpec for TransformCategory {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransformCategory {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransformCategory {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransformCategory {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransformCategory> for glib::Value {
    #[inline]
    fn from(v: TransformCategory) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
