// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{FillRule, PathDirection, PathForeachFlags, PathOperation, PathPoint, Stroke};
use glib::translate::*;
use std::fmt;

glib::wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Path(Shared<ffi::GskPath>);

    match fn {
        ref => |ptr| ffi::gsk_path_ref(ptr),
        unref => |ptr| ffi::gsk_path_unref(ptr),
        type_ => || ffi::gsk_path_get_type(),
    }
}

impl Path {
    #[doc(alias = "gsk_path_foreach")]
    pub fn foreach<P: FnMut(&PathOperation, &graphene::Point, usize) -> bool>(
        &self,
        flags: PathForeachFlags,
        func: P,
    ) -> bool {
        let func_data: P = func;
        unsafe extern "C" fn func_func<
            P: FnMut(&PathOperation, &graphene::Point, usize) -> bool,
        >(
            op: ffi::GskPathOperation,
            pts: *const graphene::ffi::graphene_point_t,
            n_pts: libc::size_t,
            user_data: glib::ffi::gpointer,
        ) -> glib::ffi::gboolean {
            let op = from_glib_borrow(op);
            let pts = from_glib_borrow(pts);
            let callback: *mut P = user_data as *const _ as usize as *mut P;
            (*callback)(&op, &pts, n_pts).into_glib()
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: &P = &func_data;
        unsafe {
            from_glib(ffi::gsk_path_foreach(
                self.to_glib_none().0,
                flags.into_glib(),
                func,
                super_callback0 as *const _ as usize as *mut _,
            ))
        }
    }

    #[doc(alias = "gsk_path_get_bounds")]
    #[doc(alias = "get_bounds")]
    pub fn bounds(&self) -> Option<graphene::Rect> {
        unsafe {
            let mut bounds = graphene::Rect::uninitialized();
            let ret = from_glib(ffi::gsk_path_get_bounds(
                self.to_glib_none().0,
                bounds.to_glib_none_mut().0,
            ));
            if ret {
                Some(bounds)
            } else {
                None
            }
        }
    }

    #[doc(alias = "gsk_path_get_closest_point")]
    #[doc(alias = "get_closest_point")]
    pub fn closest_point(&self, point: &graphene::Point, threshold: f32) -> Option<PathPoint> {
        unsafe {
            let mut result = PathPoint::uninitialized();
            let ret = from_glib(ffi::gsk_path_get_closest_point(
                self.to_glib_none().0,
                point.to_glib_none().0,
                threshold,
                result.to_glib_none_mut().0,
            ));
            if ret {
                Some(result)
            } else {
                None
            }
        }
    }

    #[doc(alias = "gsk_path_get_end_point")]
    #[doc(alias = "get_end_point")]
    pub fn end_point(&self) -> Option<PathPoint> {
        unsafe {
            let mut result = PathPoint::uninitialized();
            let ret = from_glib(ffi::gsk_path_get_end_point(
                self.to_glib_none().0,
                result.to_glib_none_mut().0,
            ));
            if ret {
                Some(result)
            } else {
                None
            }
        }
    }

    #[doc(alias = "gsk_path_get_start_point")]
    #[doc(alias = "get_start_point")]
    pub fn start_point(&self) -> Option<PathPoint> {
        unsafe {
            let mut result = PathPoint::uninitialized();
            let ret = from_glib(ffi::gsk_path_get_start_point(
                self.to_glib_none().0,
                result.to_glib_none_mut().0,
            ));
            if ret {
                Some(result)
            } else {
                None
            }
        }
    }

    #[doc(alias = "gsk_path_get_stroke_bounds")]
    #[doc(alias = "get_stroke_bounds")]
    pub fn stroke_bounds(&self, stroke: &Stroke) -> Option<graphene::Rect> {
        unsafe {
            let mut bounds = graphene::Rect::uninitialized();
            let ret = from_glib(ffi::gsk_path_get_stroke_bounds(
                self.to_glib_none().0,
                stroke.to_glib_none().0,
                bounds.to_glib_none_mut().0,
            ));
            if ret {
                Some(bounds)
            } else {
                None
            }
        }
    }

    #[doc(alias = "gsk_path_in_fill")]
    pub fn in_fill(&self, point: &graphene::Point, fill_rule: FillRule) -> bool {
        unsafe {
            from_glib(ffi::gsk_path_in_fill(
                self.to_glib_none().0,
                point.to_glib_none().0,
                fill_rule.into_glib(),
            ))
        }
    }

    #[doc(alias = "gsk_path_is_closed")]
    pub fn is_closed(&self) -> bool {
        unsafe { from_glib(ffi::gsk_path_is_closed(self.to_glib_none().0)) }
    }

    #[doc(alias = "gsk_path_is_empty")]
    pub fn is_empty(&self) -> bool {
        unsafe { from_glib(ffi::gsk_path_is_empty(self.to_glib_none().0)) }
    }

    #[doc(alias = "gsk_path_point_get_curvature")]
    pub fn point_get_curvature(&self, point: &PathPoint) -> (f32, Option<graphene::Point>) {
        unsafe {
            let mut center = graphene::Point::uninitialized();
            let ret = ffi::gsk_path_point_get_curvature(
                self.to_glib_none().0,
                point.to_glib_none().0,
                center.to_glib_none_mut().0,
            );
            (ret, center)
        }
    }

    #[doc(alias = "gsk_path_point_get_position")]
    pub fn point_get_position(&self, point: &PathPoint) -> graphene::Point {
        unsafe {
            let mut position = graphene::Point::uninitialized();
            ffi::gsk_path_point_get_position(
                self.to_glib_none().0,
                point.to_glib_none().0,
                position.to_glib_none_mut().0,
            );
            position
        }
    }

    #[doc(alias = "gsk_path_point_get_tangent")]
    pub fn point_get_tangent(&self, point: &PathPoint, direction: PathDirection) -> graphene::Vec2 {
        unsafe {
            let mut tangent = graphene::Vec2::uninitialized();
            ffi::gsk_path_point_get_tangent(
                self.to_glib_none().0,
                point.to_glib_none().0,
                direction.into_glib(),
                tangent.to_glib_none_mut().0,
            );
            tangent
        }
    }

    #[doc(alias = "gsk_path_print")]
    pub fn print(&self, string: &mut glib::String) {
        unsafe {
            ffi::gsk_path_print(self.to_glib_none().0, string.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gsk_path_to_cairo")]
    pub fn to_cairo(&self, cr: &mut cairo::Context) {
        unsafe {
            ffi::gsk_path_to_cairo(self.to_glib_none().0, cr.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gsk_path_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(&self) -> glib::GString {
        unsafe { from_glib_full(ffi::gsk_path_to_string(self.to_glib_none().0)) }
    }

    #[doc(alias = "gsk_path_parse")]
    pub fn parse(string: &str) -> Option<Path> {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::gsk_path_parse(string.to_glib_none().0)) }
    }
}

impl fmt::Display for Path {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}
