<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding Collections - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adding-collections"><a class="header" href="#adding-collections">Adding Collections</a></h1>
<h2 id="sidebar"><a class="header" href="#sidebar">Sidebar</a></h2>
<p>Using Libadwaita on its own was already a big leap forward when it came to the look and feel of the To-Do app.
Let us go one step further by adding a way to group tasks into collections.
These collections will get their own sidebar on the left of the app.
We will start by adding an empty sidebar without any functionality.</p>
<div style="text-align:center"><img src="img/todo_7_sidebar.png" alt="To-Do app with an empty sidebar"/></div>
<p>There are a couple of steps we have to go through to get to this state.
First, we have to replace <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ApplicationWindow.html"><code>adw::ApplicationWindow</code></a>.
The main difference between those two is that <code>adw::ApplicationWindow</code> has no titlebar area.
That comes in handy when we build up our interface with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.NavigationSplitView.html"><code>adw::NavigationSplitView</code></a>.
In the screenshot above, the <code>NavigationSplitView</code> adds a sidebar for the collection view to the left, while the task view occupies the space on the right.
When using <code>adw::ApplicationWindow</code> the collection view and task view have their own <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.HeaderBar.html"><code>adw::HeaderBar</code></a> and the separator spans over the whole window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt;      
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
        &lt;property name="min-sidebar-width"&gt;200&lt;/property&gt;
        &lt;property name="sidebar"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Collection view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
        &lt;property name="content"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Task view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p><code>NavigationSplitView</code> also helps with making your app <a href="https://developer.gnome.org/hig/guidelines/adaptive.html">adaptive</a>/
As soon as the requested size is too small to fit all children at the same time, the splitview collapses, and starts behaving like a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
This means that it only displays one of its children at a time.
The adaptive behavior of the leaflet allows the To-Do app to work on smaller screen sizes (like e.g. phones) even with the added collection view.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_7_navigation_sidebar.webm" type="video/webm">
   <p>A video which shows that reducing the width of the app let's the sidebar collapse</p>
 </video>
</div>
<p>We add the necessary UI elements for the collection view, such as a header bar with a button to add a new collection, as well as the list box <code>collections_list</code> to display the collections later on.
We also add the style <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/style-classes.html#sidebars">navigations-sidebar</a> to <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" bind-source="TodoWindow"
    bind-property="title" bind-flags="sync-create" /&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;child type="start"&gt;
            &lt;object class="GtkToggleButton"&gt;
              &lt;property name="icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;New Collection&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkListBox" id="collections_list"&gt;
              &lt;style&gt;
                &lt;class name="navigation-sidebar" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
</code></pre>
<p>We also add a header bar to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" translatable="yes"&gt;Tasks&lt;/property&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;property name="show-title"&gt;False&lt;/property&gt;
          &lt;child type="end"&gt;
            &lt;object class="GtkMenuButton"&gt;
              &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
              &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;Main Menu&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="AdwClamp"&gt;
              &lt;property name="maximum-size"&gt;400&lt;/property&gt;
              &lt;property name="tightening-threshold"&gt;300&lt;/property&gt;
              &lt;property name="child"&gt;
                &lt;object class="GtkBox"&gt;
                  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
                  &lt;property name="margin-start"&gt;12&lt;/property&gt;
                  &lt;property name="margin-end"&gt;12&lt;/property&gt;
                  &lt;property name="spacing"&gt;12&lt;/property&gt;
                  &lt;child&gt;
                    &lt;object class="GtkEntry" id="entry"&gt;
                      &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
                      &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                  &lt;child&gt;
                    &lt;object class="GtkListBox" id="tasks_list"&gt;
                      &lt;property name="visible"&gt;False&lt;/property&gt;
                      &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;style&gt;
                        &lt;class name="boxed-list" /&gt;
                      &lt;/style&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                &lt;/object&gt;
              &lt;/property&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/property&gt;
&lt;/object&gt;
</code></pre>
<p>We also have to adapt the window implementation.
For example, the parent type of our window is now <code>adw::ApplicationWindow</code> instead of <code>gtk::ApplicationWindow</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    //                👇 changed
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>That also means that we have to implement the trait <code>AdwApplicationWindowImpl</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    //                👇 changed
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all adwaita application windows
impl AdwApplicationWindowImpl for Window {}</code></pre>
<p>Finally, we add <code>adw::ApplicationWindow</code> to the ancestors of <code>Window</code> in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/mod.rs">listings/todo/7/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        //       👇 changed
        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="placeholder-page"><a class="header" href="#placeholder-page">Placeholder Page</a></h2>
<p>Even before we start to populate the collection view, we ought to think about a different challenge: the empty state of our To-Do app.
Before, the empty state without a single task was quite okay.
It was clear that you had to add tasks in the entry bar.
However, now the situation is different.
Users will have to add a collection first, and we have to make that clear.
The GNOME HIG suggests to use a <a href="https://developer.gnome.org/hig/patterns/feedback/placeholders.html">placeholder page</a> for that.
In our case, this placeholder page will be presented to the user if they open the app without any collections present.</p>
<div style="text-align:center"><img src="img/todo_8_placeholder_page.png" alt="The placeholder page"/></div>
<p>We now wrap our UI in a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
One stack page describes the placeholder page, the other describes the main page.
We will later wire up the logic to display the correct stack page in the Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt; 
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="GtkStack" id="stack"&gt;
        &lt;property name="transition-type"&gt;crossfade&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;placeholder&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="GtkBox"&gt;
                &lt;!--Placeholder page implementation--&gt; 
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;main&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
                &lt;!--Main page implementation--&gt;
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to create the pageholder page as displayed before, we combine a flat header bar with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StatusPage.html"><code>adw::StatusPage</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="GtkBox"&gt;
  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
  &lt;child&gt;
    &lt;object class="GtkHeaderBar"&gt;
      &lt;style&gt;
        &lt;class name="flat" /&gt;
      &lt;/style&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class="GtkWindowHandle"&gt;
      &lt;property name="vexpand"&gt;True&lt;/property&gt;
      &lt;property name="child"&gt;
        &lt;object class="AdwStatusPage"&gt;
          &lt;property name="icon-name"&gt;checkbox-checked-symbolic&lt;/property&gt;
          &lt;property name="title" translatable="yes"&gt;No Tasks&lt;/property&gt;
          &lt;property name="description" translatable="yes"&gt;Create some tasks to start using the app.&lt;/property&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkButton"&gt;
              &lt;property name="label" translatable="yes"&gt;_New Collection&lt;/property&gt;
              &lt;property name="use-underline"&gt;True&lt;/property&gt;
              &lt;property name="halign"&gt;center&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
              &lt;style&gt;
                &lt;class name="pill" /&gt;
                &lt;class name="suggested-action" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<p>We still need a way to store our collections.
Just like we have already created <code>TaskObject</code>, we will now introduce <code>CollectionObject</code>.
It will have the members <code>title</code> and <code>tasks</code>, both of which will be exposed as properties.
As usual, the full implementation can be seen by clicking at the eye symbol at the top right of the snippet.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/imp.rs">listings/todo/8/collection_object/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CollectionObject)]
pub struct CollectionObject {
    #[property(get, set)]
    pub title: RefCell&lt;String&gt;,
    #[property(get, set)]
    pub tasks: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CollectionObject {
    const NAME: &amp;'static str = "TodoCollectionObject";
    type Type = super::CollectionObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CollectionObject {}</span></code></pre>
<p>We also add the struct <code>CollectionData</code> to aid in serialization and deserialization.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CollectionObject {
</span><span class="boring">    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("title", title)
</span><span class="boring">            .property("tasks", tasks)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
</span><span class="boring">        let title = self.imp().title.borrow().clone();
</span><span class="boring">        let tasks_data = self
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">        CollectionData { title, tasks_data }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
</span><span class="boring">        let title = collection_data.title;
</span><span class="boring">        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
</span><span class="boring">            .tasks_data
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(TaskObject::from_task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">        tasks.extend_from_slice(&amp;tasks_to_extend);
</span><span class="boring">
</span><span class="boring">        Self::new(&amp;title, tasks)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CollectionData {
    pub title: String,
    pub tasks_data: Vec&lt;TaskData&gt;,
}</code></pre>
<p>Finally, we add methods to <code>CollectionObject</code> in order to</p>
<ul>
<li>construct it with <code>new</code>,</li>
<li>easily access the tasks <code>ListStore</code> with <code>tasks</code> and</li>
<li>convert to and from <code>CollectionData</code> with <code>to_collection_data</code> and <code>from_collection_data</code>.</li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionObject {
    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
        Object::builder()
            .property("title", title)
            .property("tasks", tasks)
            .build()
    }

    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
        let title = self.imp().title.borrow().clone();
        let tasks_data = self
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();
        CollectionData { title, tasks_data }
    }

    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
        let title = collection_data.title;
        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
            .tasks_data
            .into_iter()
            .map(TaskObject::from_task_data)
            .collect();

        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
        tasks.extend_from_slice(&amp;tasks_to_extend);

        Self::new(&amp;title, tasks)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct CollectionData {
</span><span class="boring">    pub title: String,
</span><span class="boring">    pub tasks_data: Vec&lt;TaskData&gt;,
</span><span class="boring">}</span></code></pre>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>In order to hook up the new logic, we have to add more state to <code>imp::Window</code>.
There are additional widgets that we access via the <code>template_child</code> macro.
Additionally, we reference the <code>collections</code> list store, the <code>current_collection</code> as well as the <code>current_filter_model</code>.
We also store <code>tasks_changed_handler_id</code>.
Its purpose will become clear in later snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    // 👇 all members below are new
    #[template_child]
    pub collections_list: TemplateChild&lt;ListBox&gt;,
    #[template_child]
    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
    #[template_child]
    pub stack: TemplateChild&lt;Stack&gt;,
    pub collections: OnceCell&lt;gio::ListStore&gt;,
    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>Further, we add a couple of helper methods which will come in handy later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        self.current_collection().tasks()
    }

    fn current_collection(&amp;self) -&gt; CollectionObject {
        self.imp()
            .current_collection
            .borrow()
            .clone()
            .expect("`current_collection` should be set in `set_current_collections`.")
    }

    fn collections(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .collections
            .get()
            .expect("`collections` should be set in `setup_collections`.")
            .clone()
    }

    fn set_filter(&amp;self) {
        self.imp()
            .current_filter_model
            .borrow()
            .clone()
            .expect("`current_filter_model` should be set in `set_current_collection`.")
            .set_filter(self.filter().as_ref());
    }
<span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As always, we want our data to be saved when we close the window.
Since most of the implementation is in the method <code>CollectionObject::to_collection_data</code>, the implementation of <code>close_request</code> doesn't change much.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;CollectionData&gt; = self
            .obj()
            .collections()
            .iter::&lt;CollectionObject&gt;()
            .filter_map(|collection_object| collection_object.ok())
            .map(|collection_object| collection_object.to_collection_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>constructed</code> stays mostly the same as well.
Instead of <code>setup_tasks</code> we now call <code>setup_collections</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_collections();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>setup_collections</code> sets up the <code>collections</code> list store as well as assuring that changes in the model will be reflected in the <code>collections_list</code>.
To do that it uses the method <code>create_collection_row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_collections(&amp;self) {
        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
        self.imp()
            .collections
            .set(collections.clone())
            .expect("Could not set collections");

        self.imp().collections_list.bind_model(
            Some(&amp;collections),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let collection_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `CollectionObject`.");
                    let row = window.create_collection_row(collection_object);
                    row.upcast()
                }
            ),
        )
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>create_collection_row</code> takes a <code>CollectionObject</code> and builds a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBoxRow.html"><code>gtk::ListBoxRow</code></a> from its information.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_collection_row(
        &amp;self,
        collection_object: &amp;CollectionObject,
    ) -&gt; ListBoxRow {
        let label = Label::builder()
            .ellipsize(pango::EllipsizeMode::End)
            .xalign(0.0)
            .build();

        collection_object
            .bind_property("title", &amp;label, "label")
            .sync_create()
            .build();

        ListBoxRow::builder().child(&amp;label).build()
    }
<span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also adapt <code>restore_data</code>.
Again, the heavy lifting comes from <code>CollectionObject::from_collection_data</code>, so we don't have to change too much here.
Since the rows of <code>collections_list</code> can be selected, we have to select one of them after restoring the data.
We choose the first one and let the method <code>set_current_collection</code> do the rest.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
                .expect(
                    "It should be possible to read `backup_data` from the json file.",
                );

            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
            let collections: Vec&lt;CollectionObject&gt; = backup_data
                .into_iter()
                .map(CollectionObject::from_collection_data)
                .collect();

            // Insert restored objects into model
            self.collections().extend_from_slice(&amp;collections);

            // Set first collection as current
            if let Some(first_collection) = collections.first() {
                self.set_current_collection(first_collection.clone());
            }
        }
    }
<span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>set_current_collection</code> assures that all elements accessing tasks refer to the task model of the current collection.
We bind the <code>tasks_list</code> to the current collection and store the filter model.
Whenever there are no tasks in our current collection we want to hide our tasks list.
Otherwise, the list box will leave a bad-looking line behind.
However, we don't want to accumulate signal handlers whenever we switch collections.
This is why we store the <code>tasks_changed_handler_id</code> and disconnect the old handler as soon as we set a new collection.
Finally, we select the collection row.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_current_collection(&amp;self, collection: CollectionObject) {
        // Wrap model with filter and selection and pass it to the list box
        let tasks = collection.tasks();
        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );

        // Store filter model
        self.imp().current_filter_model.replace(Some(filter_model));

        // If present, disconnect old `tasks_changed` handler
        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
            self.tasks().disconnect(handler_id);
        }

        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;tasks);
        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
        self.imp()
            .tasks_changed_handler_id
            .replace(Some(tasks_changed_handler_id));

        // Set current tasks
        self.imp().current_collection.replace(Some(collection));

        self.select_collection_row();
    }
<span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Previously, we used the method <code>set_task_list_visible</code>.
It assures that <code>tasks_list</code> is only visible if the number of tasks is greater than 0.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>select_collection_row</code> assures that the row for the current collection is selected in <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_collection_row(&amp;self) {
        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
            let row = self.imp().collections_list.row_at_index(index as i32);
            self.imp().collections_list.select_row(row.as_ref());
        }
    }
<span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="message-dialog"><a class="header" href="#message-dialog">Message Dialog</a></h2>
<p>There isn't yet a way to add a collection.
Let's implement that functionality.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_dialog.webm" type="video/webm">
   <p>A video which shows the new dialog</p>
 </video>
</div>
<p>The screencast above demonstrates the desired behavior.
When we activate the button with the <code>+</code> symbol, a dialog appears.
While the entry is empty, the "Create" button remains insensitive.
As soon as we start typing, the button becomes sensitive.
When we remove all typed letters and the entry becomes empty again, the "Create" button becomes insensitive and the entry gets the "error" style.
After clicking the "Create" button, a new collection is created, and we navigate to its task view.</p>
<p>To implement that behavior we will first add a "new-collection" action to <code>class_init</code> method.
This action will be activated by a click on the <code>+</code> button as well as on the button in the placeholder page.
We are using <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a>.
It is a convenient way to add asynchronous actions to subclassed widgets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });

        // Create async action to create new collection and add to action group "win"
        klass.install_action_async(
            "win.new-collection",
            None,
            |window, _, _| async move {
                window.new_collection().await;
            },
        );
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>As soon as the "new-collection" action is activated, the <code>async</code> <code>new_collection</code> method is called.
Here, we create the <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.AlertDialog.html"><code>adw::AlertDialog</code></a>, set up the buttons as well as add the entry to it.
We add a callback to the entry to ensure that when the content changes, an empty content sets <code>dialog_button</code> as insensitive and adds an "error" CSS class to the entry.
We then <code>await</code> on the user pressing a button on the dialog.
If they click "Cancel", we simply return.
However, if they click "Create", we want a new collection to be created and set as current collection.
Afterwards we navigate forward on our leaflet, which means we navigate to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    async fn new_collection(&amp;self) {
        // Create entry
        let entry = Entry::builder()
            .placeholder_text("Name")
            .activates_default(true)
            .build();

        let cancel_response = "cancel";
        let create_response = "create";

        // Create new dialog
        let dialog = AlertDialog::builder()
            .heading("New Collection")
            .close_response(cancel_response)
            .default_response(create_response)
            .extra_child(&amp;entry)
            .build();
        dialog
            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
        // Make the dialog button insensitive initially
        dialog.set_response_enabled(create_response, false);
        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);

        // Set entry's css class to "error", when there is no text in it
        entry.connect_changed(clone!(
            #[weak]
            dialog,
            move |entry| {
                let text = entry.text();
                let empty = text.is_empty();

                dialog.set_response_enabled(create_response, !empty);

                if empty {
                    entry.add_css_class("error");
                } else {
                    entry.remove_css_class("error");
                }
            }
        ));

        let response = dialog.choose_future(self).await;

        // Return if the user chose `cancel_response`
        if response == cancel_response {
            return;
        }

        // Create a new list store
        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();

        // Create a new collection object from the title the user provided
        let title = entry.text().to_string();
        let collection = CollectionObject::new(&amp;title, tasks);

        // Add new collection object and set current tasks
        self.collections().append(&amp;collection);
        self.set_current_collection(collection);

        // Show the content
        self.imp().split_view.set_show_content(true);
    }
<span class="boring">}</span></code></pre>
<p>We also add more callbacks to <code>setup_callbacks</code>.
Importantly, we want to filter our current task model whenever the value of the "filter" setting changes.
Whenever the items of our collections change we also want to set the stack.
This makes sure that our placeholder page is shown if there are no collections.
Finally, we assure that when we click on a row of <code>collections_list</code>, <code>current_collection</code> is set to the selected collection and the split view shows the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span>        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                move |_, _| {
                    window.set_filter();
                }
            ),
        );

        // Setup callback when items of collections change
        self.set_stack();
        self.collections().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _, _, _| {
                window.set_stack();
            }
        ));

        // Setup callback for activating a row of collections list
        self.imp().collections_list.connect_row_activated(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, row| {
                let index = row.index();
                let selected_collection = window
                    .collections()
                    .item(index as u32)
                    .expect("There needs to be an object at this position.")
                    .downcast::&lt;CollectionObject&gt;()
                    .expect("The object needs to be a `CollectionObject`.");
                window.set_current_collection(selected_collection);
                window.imp().split_view.set_show_content(true);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Before, we called the method <code>set_stack</code>.
This method ensure when there is at least one collection, the "main" page is shown, and the "placeholder" page otherwise.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_stack(&amp;self) {
        if self.collections().n_items() &gt; 0 {
            self.imp().stack.set_visible_child_name("main");
        } else {
            self.imp().stack.set_visible_child_name("placeholder");
        }
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>And that was it!
Now we can enjoy the final result.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_adaptive_sidebar.webm" type="video/webm">
   <p>A video which shows the final To-Do app</p>
 </video>
</div>
<blockquote>
<p>You might have noticed that there is not yet a way to remove a collection.
Try to implement this missing piece of functionality in your local version of the To-Do app.
Which edge cases do you have to consider?</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
