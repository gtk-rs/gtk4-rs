<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Main Event Loop - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-main-event-loop"><a class="header" href="#the-main-event-loop">The Main Event Loop</a></h1>
<p>We now got comfortable using callbacks, but how do they actually work?
All of this happens asynchronously, so there must be something managing the events and scheduling the responses.
Unsurprisingly, this is called the main event loop.</p>
<div style="text-align:center"><img src="img/main_event_loop.png" alt="Diagram showing the main event loop"/></div>
<p>The main loop manages all kinds of events — from mouse clicks and keyboard presses to file events.
It does all of that within the same thread.
Quickly iterating between all tasks gives the illusion of parallelism.
That is why you can move the window at the same time as a progress bar is growing.</p>
<p>However, you surely saw GUIs that became unresponsive, at least for a few seconds.
That happens when a single task takes too long.
The following example uses <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code>std::thread::sleep</code></a> to represent a long-running task.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/1/main.rs">listings/main_event_loop/1/main.rs</a></p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, glib, Application, ApplicationWindow, Button};

const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        thread::sleep(five_seconds);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>After we press the button, the GUI is completely frozen for five seconds.
We can't even move the window.
The <code>sleep</code> call is an artificial example,
but frequently, we want to run a slightly longer operation in one go.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_1.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<h2 id="how-to-avoid-blocking-the-main-loop"><a class="header" href="#how-to-avoid-blocking-the-main-loop">How to Avoid Blocking the Main Loop</a></h2>
<p>In order to avoid blocking the main loop, we can spawn a new task with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/fn.spawn_blocking.html"><code>gio::spawn_blocking</code></a> and let the operation run on the thread pool.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/2/main.rs">listings/main_event_loop/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now the GUI doesn't freeze when we press the button.
However, nothing stops us from spawning as many tasks as we want at the same time.
This is not necessarily what we want.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_2.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<blockquote>
<p>If you come from another language than Rust, you might be uncomfortable with the thought of running tasks in separate threads before even looking at other options.
Luckily, Rust's safety guarantees allow you to stop worrying about the nasty bugs that concurrency tends to bring.</p>
</blockquote>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>Typically, we want to keep track of the work in the task.
In our case, we don't want the user to spawn additional tasks while an existing one is still running.
In order to exchange information with the task we can create a channel with the crate <a href="https://docs.rs/async-channel/latest/async_channel/index.html"><code>async-channel</code></a>.
Let's add it by executing the following in the terminal:</p>
<pre><code>cargo add async-channel
</code></pre>
<p>We want to send a <code>bool</code> to inform, whether we want the button to react to clicks or not.
Since we send in a separate thread, we can use <a href="https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send_blocking"><code>send_blocking</code></a>.
But what about receiving?
Every time we get a message, we want to set the sensitivity of the button according to the <code>bool</code> we've received.
However, we don't want to block the main loop while waiting for a message to receive.
That is the whole point of the exercise after all!</p>
<p>We solve that problem by waiting for messages in an <a href="https://rust-lang.github.io/async-book/"><code>async</code></a> block.
This <code>async</code> block is spawned on the <code>glib</code> main loop with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future_local.html"><code>spawn_future_local</code></a></p>
<blockquote>
<p>See also <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future.html"><code>spawn_future</code></a> for spawning async blocks on the main loop from outside the main thread.</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/3/main.rs">listings/main_event_loop/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            sender
                .send_blocking(false)
                .expect("The channel needs to be open.");
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            sender
                .send_blocking(true)
                .expect("The channel needs to be open.");
        });
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>As you can see, spawning a task still doesn't freeze our user interface.
However, now we can't spawn multiple tasks at the same time since the button becomes insensitive after the first task has been spawned.
After the task is finished, the button becomes sensitive again.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_3.webm" type="video/webm">
  <p>The button now stops being responsive for 10 seconds after being pressed</p>
 </video>
</div>
<p>What if the task is asynchronous by nature?
Let's try <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.timeout_future_seconds.html"><code>glib::timeout_future_seconds</code></a> as representation for our task instead of <code>std::thread::sleep</code>.
It returns a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a>, which means we can <code>await</code> on it within an <code>async</code> context.
The converted code looks and behaves very similar to the multithreaded code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/4/main.rs">listings/main_event_loop/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                // Deactivate the button until the operation is done
                sender
                    .send(false)
                    .await
                    .expect("The channel needs to be open.");
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                sender
                    .send(true)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Since we are single-threaded again, we can even get rid of the channel while achieving the same result.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/5/main.rs">listings/main_event_loop/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                button.set_sensitive(true);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>But why did we not do the same thing with our multithreaded example?</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::{glib, gio};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">       .application_id("org.gtk_rs.MainEventLoop6")
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE!
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Simply because we would get this error message:</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>After reference cycles we found the second disadvantage of GTK GObjects: They are not thread safe.</p>
<h2 id="embed-blocking-calls-in-an-async-context"><a class="header" href="#embed-blocking-calls-in-an-async-context">Embed blocking calls in an <code>async</code> context</a></h2>
<p>We've seen in the previous snippets that spawning an <code>async</code> block or <code>async</code> future on the <code>glib</code> main loop can lead to more concise code than running tasks on separate threads.
Let's focus on a few more aspects that are interesting to know when running <code>async</code> functions with gtk-rs apps.</p>
<p>For a start, blocking functions can be embedded within an <code>async</code> context.
In the following listing, we want to execute a synchronous function that returns a boolean and takes ten seconds to run.
In order to integrate it in our <code>async</code> block, we run the function in a separate thread via <code>spawn_blocking</code>.
We can then get the return value of the function by calling <code>await</code> on the return value of <code>spawn_blocking</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/6/main.rs">listings/main_event_loop/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                let enable_button = gio::spawn_blocking(move || {
                    let five_seconds = Duration::from_secs(5);
                    thread::sleep(five_seconds);
                    true
                })
                .await
                .expect("Task needs to finish successfully.");
                // Set sensitivity of button to `enable_button`
                button.set_sensitive(enable_button);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="run-async-functions-from-external-crates"><a class="header" href="#run-async-functions-from-external-crates">Run <code>async</code> functions from external crates</a></h2>
<p>Asynchronous functions from the <code>glib</code> ecosystem can always be spawned on the <code>glib</code> main loop.
Typically, crates depending on <code>async-std</code> or <code>smol</code> work as well.
Let us take <code>ashpd</code> for example which allows sandboxed applications to interact with the desktop.
It can be configured to depend on <code>async-std</code>.
We can add it to our dependencies by running the following command.</p>
<pre><code>cargo add ashpd --no-default-features --features "gtk4 async-std"
</code></pre>
<p>You need to use a Linux desktop environment in order to run the following example locally.
This example is using <a href="https://docs.rs/ashpd/latest/ashpd/desktop/account/index.html"><code>ashpd::desktop::account::UserInformation</code></a> to access user information.
We are getting a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Native.html"><code>gtk::Native</code></a> object from our button, create a <a href="https://docs.rs/ashpd/latest/ashpd/enum.WindowIdentifier.html"><code>ashpd::WindowIdentifier</code></a> and pass it to the user information request.</p>
<blockquote>
<p>We need to pass the <code>WindowIdentifier</code> to make the dialog modal. This means that it will be on top of the window and freezes the rest of the application from user input.</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/7/main.rs">listings/main_event_loop/7/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop7";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move { fetch_user_information(button).await }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(target_os = "linux")]
</span><span class="boring">async fn fetch_user_information(button: Button) {
</span><span class="boring">    use ashpd::desktop::account::UserInformation;
</span><span class="boring">    use ashpd::WindowIdentifier;
</span><span class="boring">
</span><span class="boring">    // Get native of button for window identifier
</span><span class="boring">    let native = button.native().expect("Need to be able to get native.");
</span><span class="boring">    // Get window identifier so that the dialog will be modal to the main window
</span><span class="boring">    let identifier = WindowIdentifier::from_native(&amp;native).await;
</span><span class="boring">    let request = UserInformation::request()
</span><span class="boring">        .reason("App would like to access user information.")
</span><span class="boring">        .identifier(identifier)
</span><span class="boring">        .send()
</span><span class="boring">        .await;
</span><span class="boring">
</span><span class="boring">    if let Ok(response) = request.and_then(|r| r.response()) {
</span><span class="boring">        println!("User name: {}", response.name());
</span><span class="boring">    } else {
</span><span class="boring">        println!("Could not access user information.")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(not(target_os = "linux"))]
</span><span class="boring">async fn fetch_user_information(_button: Button) {
</span><span class="boring">    println!("fetching user information not available outside target_os = \"linux\"");
</span><span class="boring">}</span></code></pre>
<p>After pressing the button, a dialog should open that shows the information that will be shared.
If you decide to share it, you user name will be printed on the console.</p>
<div style="text-align:center"><img src="img/main_event_loop_ashpd.png" alt="Dialog requesting user information."/></div>
<h2 id="tokio"><a class="header" href="#tokio">Tokio</a></h2>
<p><a href="https://docs.rs/tokio/latest/tokio/"><code>tokio</code></a> is Rust's most popular asynchronous platform.
Therefore, many high-quality crates are part of its ecosystem.
The web client <a href="https://docs.rs/reqwest/latest/reqwest/"><code>reqwest</code></a> belongs to this group.
Let's add it by executing the following command</p>
<pre><code>cargo add reqwest@0.12 --features rustls-tls --no-default-features
</code></pre>
<p>As soon as the button is pressed, we want to send a <code>GET</code> request to <a href="https://www.gtk-rs.org">www.gtk-rs.org</a>.
The response should then be sent to the main thread via a channel.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/8/main.rs">listings/main_event_loop/8/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop8";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>This compiles fine and even seems to run.
However, nothing happens when we press the button.
Inspecting the console gives the following error message:</p>
<pre><code>thread 'main' panicked at
'there is no reactor running, must be called from the context of a Tokio 1.x runtime'
</code></pre>
<p>At the time of writing, <code>reqwest</code> doesn't document this requirement.
Unfortunately, that is also the case for other libraries depending on <code>tokio</code>.
Let's bite the bullet and add <code>tokio</code>:</p>
<pre><code>cargo add tokio@1 --features rt-multi-thread
</code></pre>
<p>Since we already run the <code>glib</code> main loop on our main thread, we don't want to run the <code>tokio</code> runtime there.
For this reason, we <strong>avoid</strong> using the <code>#[tokio::main]</code> macro or using a top-level <code>block_on</code> call.
Doing this will block one of the runtime's threads with the GLib main loop, which is a waste of resources and a potential source of strange bugs.</p>
<p>Instead, we bind <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html"><code>tokio::runtime::Runtime</code></a> to a static variable.</p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop0";
</span><span class="boring">
</span>// DOES NOT COMPILE!
static RUNTIME: Runtime =
    Runtime::new().expect("Setting up tokio runtime needs to succeed.");
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">   // Create a button
</span><span class="boring">   let button = Button::builder()
</span><span class="boring">       .label("Press me!")
</span><span class="boring">       .margin_top(12)
</span><span class="boring">       .margin_bottom(12)
</span><span class="boring">       .margin_start(12)
</span><span class="boring">       .margin_end(12)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // ANCHOR: callback
</span><span class="boring">   let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">   // Connect to "clicked" signal of `button`
</span><span class="boring">   button.connect_clicked(move |_| {
</span><span class="boring">       RUNTIME.spawn(clone!(#[strong] sender, async move {
</span><span class="boring">           let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">           sender.send(response).await.expect("The channel needs to be open.");
</span><span class="boring">       }));
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   // The main loop executes the asynchronous block
</span><span class="boring">   glib::spawn_future_local(async move {
</span><span class="boring">       while let Ok(response) = receiver.recv().await {
</span><span class="boring">           if let Ok(response) = response {
</span><span class="boring">               println!("Status: {}", response.status());
</span><span class="boring">           } else {
</span><span class="boring">               println!("Could not make a `GET` request.");
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   });
</span><span class="boring">   // ANCHOR_END: callback
</span><span class="boring">
</span><span class="boring">   // Create a window
</span><span class="boring">   let window = ApplicationWindow::builder()
</span><span class="boring">       .application(app)
</span><span class="boring">       .title("My GTK App")
</span><span class="boring">       .child(&amp;button)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // Present window
</span><span class="boring">   window.present();
</span><span class="boring">}</span></code></pre>
<p>Unfortunately, this doesn't compile.
As usual, Rust's error messages are really helpful.</p>
<pre><code>cannot call non-const fn `tokio::runtime::Runtime::new` in statics
calls in statics are limited to constant functions, tuple structs and tuple variants
consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate
</code></pre>
<p>We could follow the advice directly, but the standard library also provides solutions for that.
With <a href="https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html"><code>std::sync::OnceLock</code></a> we can initialize the static with the const function <code>OnceLock::new()</code> and initialize it the first time our function <code>runtime</code> is called.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span>fn runtime() -&gt; &amp;'static Runtime {
    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
    RUNTIME.get_or_init(|| {
        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
    })
}
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">    // Connect to "clicked" signal of `button`
</span><span class="boring">    button.connect_clicked(move |_| {
</span><span class="boring">        runtime().spawn(clone!(
</span><span class="boring">            #[strong]
</span><span class="boring">            sender,
</span><span class="boring">            async move {
</span><span class="boring">                let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">                sender
</span><span class="boring">                    .send(response)
</span><span class="boring">                    .await
</span><span class="boring">                    .expect("The channel needs to be open.");
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // The main loop executes the asynchronous block
</span><span class="boring">    glib::spawn_future_local(async move {
</span><span class="boring">        while let Ok(response) = receiver.recv().await {
</span><span class="boring">            if let Ok(response) = response {
</span><span class="boring">                println!("Status: {}", response.status());
</span><span class="boring">            } else {
</span><span class="boring">                println!("Could not make a `GET` request.");
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>In the button callback we can now spawn the <code>reqwest</code> <code>async</code> block with <code>tokio</code> rather than with <code>glib</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span><span class="boring">fn runtime() -&gt; &amp;'static Runtime {
</span><span class="boring">    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
</span><span class="boring">    RUNTIME.get_or_init(|| {
</span><span class="boring">        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        runtime().spawn(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>If we now press the button, we should find the following message in our console:</p>
<pre><code>Status: 200 OK
</code></pre>
<p>We will not need <code>tokio</code>, <code>reqwest</code> or <code>ashpd</code> in the following chapters, so let's remove them again by executing:</p>
<pre><code>cargo remove tokio reqwest ashpd
</code></pre>
<p>How to find out whether you can spawn an <code>async</code> task on the <code>glib</code> main loop?
<code>glib</code> should be able to spawn the task when the called functions come from libraries that either:</p>
<ul>
<li>come from the <code>glib</code> ecosystem,</li>
<li>don't depend on a runtime but only on the <code>futures</code> family of crates (<code>futures-io</code>, <code>futures-core</code> etc),</li>
<li>depend on the <code>async-std</code> or <code>smol</code> runtimes, or</li>
<li>have cargo features that let them depend on <code>async-std</code>/<code>smol</code> instead of <code>tokio</code>.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>You don't want to block the main thread long enough that it is noticeable by the user.
But when should you spawn an <code>async</code> task, instead of spawning a task in a separate thread?
Let's go again through the different scenarios.</p>
<p>If the task spends its time calculating rather than waiting for a web response, it is <a href="https://en.wikipedia.org/wiki/CPU-bound">CPU-bound</a>.
That means you have to run the task in a separate thread and let it send results back via a channel.</p>
<p>If your task is <a href="https://en.wikipedia.org/wiki/I/O_bound">IO bound</a>, the answer depends on the crates at your disposal and the type of work to be done.</p>
<ul>
<li>Light I/O work with functions from crates using <code>glib</code>, <code>smol</code>, <code>async-std</code> or the <code>futures</code> trait family can be spawned on the main loop. This way, you can often avoid synchronization via channels.</li>
<li>Heavy I/O work might still benefit from running in a separate thread / an async executor to avoid saturating the main loop. If you are unsure, benchmarking is advised.</li>
</ul>
<p>If the best crate for the job relies on <code>tokio</code>, you will have to spawn it with the tokio runtime and communicate via channels.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="g_object_signals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="settings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="g_object_signals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="settings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
