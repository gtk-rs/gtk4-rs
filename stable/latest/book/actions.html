<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Actions - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>By now, we've already learned many ways to glue our widgets together.
We can send messages through channels, emit signals, share reference-counted state and bind properties.
Now, we will complete our set by learning about actions.</p>
<p>An action is a piece of functionality bound to a certain GObject.
Let's check out the simplest case where we activate an action without a parameter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger "win.close".
</span><span class="boring">    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(|window: &amp;ApplicationWindow, _, _| {
            window.close();
        })
        .build();
    window.add_action_entries([action_close]);

    // Present window
    window.present();
}</code></pre>
<p>First, we created a new <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ActionEntry.html"><code>gio::ActionEntry</code></a> which is named "close" and takes no parameter.
We also connected a callback which closes the window when the action is activated.
Finally, we add the action entry to the window via <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.ActionMapExtManual.html#method.add_action_entries"><code>add_action_entries</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Actions1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Set keyboard accelerator to trigger "win.close".
    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);

    // Run the application
    app.run()
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(|window: &amp;ApplicationWindow, _, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_close]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>One of the most popular reasons to use actions are keyboard accelerators, so we added one here.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.GtkApplicationExt.html#tymethod.set_accels_for_action"><code>set_accels_for_action</code></a> one can assign one or more accelerators to a certain action.
Check the documentation of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/functions/fn.accelerator_parse.html"><code>accelerator_parse</code></a> in order to learn more about its syntax.</p>
<p>Before we move on to other aspects of actions, let's appreciate a few things that are curious here.
The "win" part of "win.close" is the group of the action.
But how does GTK know that "win" is the action group of our window?
The answer is that it is so common to add actions to windows and applications that there are already two predefined groups available:</p>
<ul>
<li>"app" for actions global to the application, and</li>
<li>"win" for actions tied to an application window.</li>
</ul>
<p>We can add an action group to any widget via the method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#method.insert_action_group"><code>insert_action_group</code></a>.
Let's add our action to the action group "custom-group" and add the group then to our window.
The action entry isn't specific to our window anymore, the first parameter of the "activate" callback is of type <code>SimpleActionGroup</code> instead of <code>ApplicationWindow</code>.
This means we have to clone <code>window</code> into the closure.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">    // Set keyboard accelerator to trigger "custom-group.close".
</span><span class="boring">    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(clone!(
            #[weak]
            window,
            move |_, _, _| {
                window.close();
            }
        ))
        .build();

    // Create a new action group and add actions to it
    let actions = SimpleActionGroup::new();
    actions.add_action_entries([action_close]);
    window.insert_action_group("custom-group", Some(&amp;actions));

    // Present window
    window.present();
}</code></pre>
<p>If we bind the accelerator to "custom-group.close", it works just as before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span>    // Set keyboard accelerator to trigger "custom-group.close".
    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
<span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            window,
</span><span class="boring">            move |_, _, _| {
</span><span class="boring">                window.close();
</span><span class="boring">            }
</span><span class="boring">        ))
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a new action group and add actions to it
</span><span class="boring">    let actions = SimpleActionGroup::new();
</span><span class="boring">    actions.add_action_entries([action_close]);
</span><span class="boring">    window.insert_action_group("custom-group", Some(&amp;actions));
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Also, if we had multiple instances of the same windows, we would expect that only the currently focused window will be closed when activating "win.close".
And indeed, the "win.close" will be dispatched to the currently focused window.
However, that also means that we actually define one action per window instance.
If we want to have a single globally accessible action instead, we call <code>add_action_entries</code> on our application instead.</p>
<blockquote>
<p>Adding "win.close" was useful as a simple example.
However, in the future we will use the pre-defined <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Window.html#actions">"window.close"</a> action which does exactly the same thing.</p>
</blockquote>
<h2 id="parameter-and-state"><a class="header" href="#parameter-and-state">Parameter and State</a></h2>
<p>An action, like most functions, can take a parameter.
However, unlike most functions it can also be stateful.
Let's see how this works.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/3/main.rs">listings/actions/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    let original_state = 0;
    let label = Label::builder()
        .label(format!("Counter: {original_state}"))
        .build();

    // Create a button with label
    let button = Button::builder().label("Press me!").build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Activate "win.count" and pass "1" as parameter
        let parameter = 1;
        button
            .activate_action("win.count", Some(&amp;parameter.to_variant()))
            .expect("The action does not exist.");
    });

    // Create a `gtk::Box` and add `button` and `label` to it
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .spacing(12)
        .halign(Align::Center)
        .build();
    gtk_box.append(&amp;button);
    gtk_box.append(&amp;label);

    // Create a window, set the title and add `gtk_box` to it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .child(&amp;gtk_box)
        .build();

    // Add action "count" to `window` taking an integer as parameter
    let action_count = ActionEntry::builder("count")
        .parameter_type(Some(&amp;i32::static_variant_type()))
        .state(original_state.to_variant())
        .activate(move |_, action, parameter| {
            // Get state
            let mut state = action
                .state()
                .expect("Could not get state.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Get parameter
            let parameter = parameter
                .expect("Could not get parameter.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Increase state by parameter and store state
            state += parameter;
            action.set_state(&amp;state.to_variant());

            // Update label with new state
            label.set_label(&amp;format!("Counter: {state}"));
        })
        .build();
    window.add_action_entries([action_count]);

    // Present window
    window.present();
}</code></pre>
<p>Here, we created a "win.count" action that increases its state by the given parameter every time it is activated.
It also takes care of updating the <code>label</code> with the current state.
The button activates the action with each click while passing "1" as parameter.
This is how our app works:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_counter.webm" type="video/webm">
  <p>A video which shows that pressing on one button also changes the label below</p>
 </video>
</div>
<h2 id="actionable"><a class="header" href="#actionable">Actionable</a></h2>
<p>Connecting actions to the "clicked" signal of buttons is a typical use case, which is why all buttons implement the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Actionable.html"><code>Actionable</code></a> interface.
This way, the action can be specified by setting the "action-name" property.
If the action accepts a parameter, it can be set via the "action-target" property.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/builders/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a>, we can set everything up by calling its methods.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/4/main.rs">listings/actions/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    let original_state = 0;
</span><span class="boring">    let label = Label::builder()
</span><span class="boring">        .label(format!("Counter: {original_state}"))
</span><span class="boring">        .build();
</span>    // Create a button with label and action
    let button = Button::builder()
        .label("Press me!")
        .action_name("win.count")
        .action_target(&amp;1.to_variant())
        .build();
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add `button` and `label` to it
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button);
</span><span class="boring">    gtk_box.append(&amp;label);
</span><span class="boring">
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "count" to `window` taking an integer as parameter
</span><span class="boring">    let action_count = ActionEntry::builder("count")
</span><span class="boring">        .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">        .state(original_state.to_variant())
</span><span class="boring">        .activate(move |_, action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect("Could not get state.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect("Could not get parameter.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and store state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Actionable widgets are also easily accessible through the interface builder.
As usual, we build up the window via a composite template.
Within the template we can then set the "action-name" and "action-target" properties.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/resources/window.ui">listings/actions/5/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="gtk_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;12&lt;/property&gt;
        &lt;property name="halign"&gt;center&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton" id="button"&gt;
            &lt;property name="label"&gt;Press me!&lt;/property&gt;
            &lt;property name="action-name"&gt;win.count&lt;/property&gt;
            &lt;property name="action-target"&gt;1&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="label"&gt;
            &lt;property name="label"&gt;Counter: 0&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>We will connect the actions and add them to the window in the <code>Window::setup_actions</code> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/window/mod.rs">listings/actions/5/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span>impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_actions(&amp;self) {
        // Add stateful action "count" to `window` taking an integer as parameter
        let original_state = 0;
        let action_count = ActionEntry::builder("count")
            .parameter_type(Some(&amp;i32::static_variant_type()))
            .state(original_state.to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get state
                let mut state = action
                    .state()
                    .expect("Could not get state.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Increase state by parameter and store state
                state += parameter;
                action.set_state(&amp;state.to_variant());

                // Update label with new state
                window.imp().label.set_label(&amp;format!("Counter: {state}"));
            })
            .build();
        self.add_action_entries([action_count]);
    }
}</code></pre>
<p>Finally, <code>setup_actions</code> will be called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/window/imp.rs">listings/actions/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Add actions
        self.obj().setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>This app behaves the same as our previous example, but it will make it simpler for us to add a menu in the following section.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>If you want to create a <a href="https://developer.gnome.org/hig/patterns/controls/menus.html">menu</a>, you have to use actions, and you will want to use the interface builder.
Typically, a menu entry has an action fitting one of these three descriptions:</p>
<ul>
<li>no parameter and no state, or</li>
<li>no parameter and boolean state, or</li>
<li>string parameter and string state.</li>
</ul>
<p>Let's modify our small app to demonstrate these cases.
First, we extend <code>setup_actions</code>.
For the action without parameter or state, we can use the pre-defined "window.close" action.
Therefore, we don't have to add anything here.</p>
<p>With the action "button-frame", we manipulate the "has-frame" property of <code>button</code>.
Here, the convention is that actions with no parameter and boolean state should behave like toggle actions.
This means that the caller can expect the boolean state to toggle after activating the action. Luckily for us, that is the default behavior for <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.PropertyAction.html"><code>gio::PropertyAction</code></a> with a boolean property.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span>        // Add property action "button-frame" to `window`
        let button = self.imp().button.get();
        let action_button_frame =
            PropertyAction::new("button-frame", &amp;button, "has-frame");
        self.add_action(&amp;action_button_frame);
<span class="boring">
</span><span class="boring">        // Add stateful action "orientation" to `window` taking a string as parameter
</span><span class="boring">        let action_orientation = ActionEntry::builder("orientation")
</span><span class="boring">            .parameter_type(Some(&amp;String::static_variant_type()))
</span><span class="boring">            .state("Vertical".to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match parameter.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                // Set orientation and save state
</span><span class="boring">                window.imp().gtk_box.set_orientation(orientation);
</span><span class="boring">                action.set_state(&amp;parameter.to_variant());
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count, action_orientation]);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>A <code>PropertyAction</code> is useful when you need an action that manipulates the property of a GObject.
The property then acts as the state of the action.
As mentioned above, if the property is a boolean the action has no parameter and toggles the property on activation.
In all other cases, the action has a parameter of the same type as the property.
When activating the action, the property gets set to the same value as the parameter of the action.</p>
</blockquote>
<p>Finally, we add "win.orientation", an action with string parameter and string state.
This action can be used to change the orientation of <code>gtk_box</code>.
Here the convention is that the state should be set to the given parameter.
We don't need the action state to implement orientation switching, however it is useful for making the menu display the current orientation.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Add property action "button-frame" to `window`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        let action_button_frame =
</span><span class="boring">            PropertyAction::new("button-frame", &amp;button, "has-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span>        // Add stateful action "orientation" to `window` taking a string as parameter
        let action_orientation = ActionEntry::builder("orientation")
            .parameter_type(Some(&amp;String::static_variant_type()))
            .state("Vertical".to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;String&gt;()
                    .expect("The value needs to be of type `String`.");

                let orientation = match parameter.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                // Set orientation and save state
                window.imp().gtk_box.set_orientation(orientation);
                action.set_state(&amp;parameter.to_variant());
            })
            .build();
        self.add_action_entries([action_count, action_orientation]);
<span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Even though <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Menu.html"><code>gio::Menu</code></a> can also be created with the bindings, the most convenient way is to use the interface builder for that.
We do that by adding the menu in front of the template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/resources/window.ui">listings/actions/6/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Close window&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;window.close&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Toggle button frame&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.button-frame&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;section&gt;
+      &lt;attribute name="label" translatable="yes"&gt;Orientation&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Horizontal&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Vertical&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Vertical&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/section&gt;
+  &lt;/menu&gt;
   &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="title"&gt;My GTK App&lt;/property&gt;
+    &lt;property name="width-request"&gt;360&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type ="end"&gt;
+          &lt;object class="GtkMenuButton"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class="GtkBox" id="gtk_box"&gt;
         &lt;property name="orientation"&gt;vertical&lt;/property&gt;
</code></pre>
<p>Since we connect the menu to the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> via the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#menu-model">menu-model</a> property, the <code>Menu</code> is expected to be a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html"><code>gtk::PopoverMenu</code></a>.
The <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html">documentation</a> for <code>PopoverMenu</code> also explains its <code>xml</code> syntax for the interface builder.</p>
<p>Also note how we specified the target:</p>
<pre><code class="language-xml">&lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
</code></pre>
<p>String is the default type of the target which is why we did not have to specify a type.
With targets of other types you need to manually specify the correct <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant format string</a>.
For example, an <code>i32</code> variable with value "5" would correspond to this:</p>
<pre><code class="language-xml">&lt;attribute name="target" type="i"&gt;5&lt;/attribute&gt;
</code></pre>
<p>This is how the app looks in action:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_menu.webm" type="video/webm">
  <p>A video which now also shows the menu</p>
 </video>
</div>
<blockquote>
<p>We changed the icon of the <code>MenuButton</code> by setting its property "icon-name" to "open-menu-symbolic".
You can find more icons with the <a href="https://flathub.org/apps/org.gnome.design.IconLibrary">Icon Library</a>.
They can be embedded with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a> and then be referenced within the composite templates (or other places).</p>
</blockquote>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>The menu entries nicely display the state of our stateful actions, but after the app is closed, all changes to that state are lost.
As usual, we solve this problem with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a>.
First we create a schema with settings corresponding to the stateful actions we created before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/org.gtk_rs.Actions7.gschema.xml">listings/actions/7/org.gtk_rs.Actions7.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Actions7" path="/org/gtk_rs/Actions7/"&gt;
    &lt;key name="button-frame" type="b"&gt;
      &lt;default&gt;true&lt;/default&gt;
      &lt;summary&gt;Whether the button has a frame&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="orientation" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='Horizontal'/&gt;
        &lt;choice value='Vertical'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'Vertical'&lt;/default&gt;
      &lt;summary&gt;Orientation of GtkBox&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Again, we install the schema as described in the settings <a href="./settings.html">chapter</a>.
Then we add the settings to <code>imp::Window</code>.
Since <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> does not implement <code>Default</code>, we wrap it in a <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
    #[template_child]
    pub label: TemplateChild&lt;Label&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">        obj.bind_settings();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Now we create functions to make it easier to access settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Creating stateful actions from setting entries is so common that <code>Settings</code> provides a method for that exact purpose.
We create actions with the<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.create_action"> <code>create_action</code></a> method and then add them to the action group of our window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span>        // Create action from key "button-frame" and add to action group "win"
        let action_button_frame = self.settings().create_action("button-frame");
        self.add_action(&amp;action_button_frame);

        // Create action from key "orientation" and add to action group "win"
        let action_orientation = self.settings().create_action("orientation");
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since actions from <code>create_action</code> follow the aforementioned conventions, we can keep further changes to a minimum.
The action "win.button-frame" toggles its state with each activation and the state of the "win.orientation" action follows the given parameter.</p>
<p>We still have to specify what should happen when the actions are activated though.
For the stateful actions, instead of adding callbacks to their "activate" signals, we bind the settings to properties we want to manipulate.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn bind_settings(&amp;self) {
        // Bind setting "button-frame" to "has-frame" property of `button`
        let button = self.imp().button.get();
        self.settings()
            .bind("button-frame", &amp;button, "has-frame")
            .build();

        // Bind setting "orientation" to "orientation" property of `button`
        let gtk_box = self.imp().gtk_box.get();
        self.settings()
            .bind("orientation", &amp;gtk_box, "orientation")
            .mapping(|variant, _| {
                let orientation = variant
                    .get::&lt;String&gt;()
                    .expect("The variant needs to be of type `String`.");

                let orientation = match orientation.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                Some(orientation.to_value())
            })
            .build();
    }
<span class="boring">}</span></code></pre>
<p>Finally, we make sure that <code>bind_settings</code> is called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_actions();
        obj.bind_settings();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Actions are extremely powerful, and we are only scratching the surface here.
If you want to learn more about them, the <a href="https://developer.gnome.org/documentation/tutorials/actions.html">GNOME developer documentation</a> is a good place to start.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="todo_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="todo_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
