<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Rust and GTK 4</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gui-development-with-rust-and-gtk-4"><a class="header" href="#gui-development-with-rust-and-gtk-4">GUI development with Rust and GTK 4</a></h1>
<p><em>by Julian Hofer, with contributions from the community</em></p>
<p>GTK 4 is the newest version of a popular cross-platform widget toolkit written in C.
Thanks to GObject-Introspection, GTK's API can be easily targeted by various programming languages.
The API even describes the ownership of its parameters!</p>
<p>Managing ownership without giving up speed is one of Rust's greatest strengths, which makes it an excellent choice to develop GTK apps with.
With this combination you don't have to worry about hitting bottlenecks mid-project anymore.
Additionally, with Rust you will have nice things such as</p>
<ul>
<li>thread safety,</li>
<li>memory safety,</li>
<li>sensible dependency management as well as</li>
<li>excellent third party libraries.</li>
</ul>
<p>The <a href="https://gtk-rs.org/"><code>gtk-rs</code></a> project provides bindings to many GTK-related libraries which we will be using throughout this book.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book assumes that you know your way around Rust code.
If this is not already the case, reading <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> is an enjoyable way to get you to that stage.
If you have experience with another low-level language such as C or C++ you
might find that reading <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half hour to learn Rust</a> gives you sufficient information as well.</p>
<p>Luckily, this — together with the wish to develop graphical applications — is all that is necessary to benefit from this book.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>In general, this book assumes that you are reading it in sequence from front to
back. However, if you are using it as a reference for a certain topic,
you might find it useful to just jump into it.</p>
<p>There are two kinds of chapters in this book: concept chapters and project
chapters.
In concept chapters, you will learn about an aspect of GTK development.
In project chapters, we will build small programs together, applying what you've learned so far.</p>
<p>The book strives to explain essential GTK concepts paired with practical examples.
However, if a concept can be better conveyed with a less practical example, we took this path most of the time.
If you are interested in contained and useful examples, we refer you to the corresponding section of <code>gtk4-rs</code>' <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/examples">repository</a>.</p>
<p>Every valid code snippet in the book is part of a listing.
Like the examples, the listings be found in the <a href="https://github.com/gtk-rs/gtk4-rs/tree/main/book/listings">repository</a> of <code>gtk4-rs</code>.</p>
<h2 id="translations"><a class="header" href="#translations">Translations</a></h2>
<p>This book has been translated to Chinese by 陈竞阁 and is served under the following <a href="https://mario-hero.github.io/gtk-book-zh_cn/">website</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The book itself is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.
The only exception are the code snippets which are licensed under the <a href="https://github.com/gtk-rs/gtk4-rs/blob/main/README.md">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>In order to develop a <code>gtk-rs</code> app, you basically need two things on your workstation:</p>
<ul>
<li>the Rust toolchain, and</li>
<li>the GTK 4 library.</li>
</ul>
<p>As so often the devil hides in the details, which is why we will list the installation instructions for each operating system in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>You first have to install rustup.
You can find the up-to-date instructions on <a href="https://rustup.rs">rustup.rs</a>.</p>
<p>Then install GTK 4 and the build essentials.
To do this, execute the command belonging to the distribution you are using.</p>
<p>Fedora and derivatives:</p>
<pre><code>sudo dnf install gtk4-devel gcc
</code></pre>
<p>Debian and derivatives:</p>
<pre><code>sudo apt install libgtk-4-dev build-essential
</code></pre>
<p>Arch and derivatives:</p>
<pre><code>sudo pacman -S gtk4 base-devel
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>First install rustup.
You can find the up-to-date instructions on <a href="https://rustup.rs">rustup.rs</a>.</p>
<p>Then install <a href="https://brew.sh/">homebrew</a>.</p>
<p>Finally, install GTK 4 by executing the following in your terminal:</p>
<pre><code class="language-bash">brew install gtk4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>When preparing your Windows machine, you have to decide between either using the <strong>MSVC toolchain</strong> or the <strong>GNU toolchain</strong>.
If in doubt, go for MSVC since that is the default on Windows.
You will want to go for the GNU toolchain if you depend on libraries that can only be compiled with the GNU toolchain.</p>
<h2 id="install-rustup"><a class="header" href="#install-rustup">Install Rustup</a></h2>
<p>Install the Rust toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<h2 id="install-gtk-4"><a class="header" href="#install-gtk-4">Install GTK 4</a></h2>
<details>
<summary>Build GTK 4 with gvsbuild and MSVC (recommended)</summary>
<h3 id="set-rust-toolchain-to-msvc"><a class="header" href="#set-rust-toolchain-to-msvc">Set Rust toolchain to MSVC</a></h3>
<p>Tell Rust to use MSVC by executing:</p>
<pre><code>rustup default stable-msvc
</code></pre>
<p>Note that this does not install the MSVC toolchain. If you don't have it yet, you will need to <a href="https://learn.microsoft.com/en-us/windows/dev-environment/rust/setup">install it separately</a>.</p>
<h3 id="build-gtk-4"><a class="header" href="#build-gtk-4">Build GTK 4</a></h3>
<p>Follow the <a href="https://github.com/wingtk/gvsbuild#development-environment"><code>gvsbuild</code> docs to build GTK 4</a>. Be sure to build the right version:</p>
<pre><code>gvsbuild build gtk4
</code></pre>
<h3 id="update-environment-variables"><a class="header" href="#update-environment-variables">Update environment variables</a></h3>
<ol>
<li>Go to Start</li>
<li>Search for 'Advanced system settings'</li>
<li>Click 'Environment Variables...'</li>
<li>Ensure there is a user variable named <code>PKG_CONFIG_PATH</code> with value <code>C:\gtk-build\gtk\x64\release\lib\pkgconfig</code></li>
<li>Edit the variable named <code>Path</code> and add <code>C:\gtk-build\gtk\x64\release\bin</code> to it</li>
<li>Ensure there is a user variable named <code>Lib</code> with value <code>C:\gtk-build\gtk\x64\release\lib</code> (or add new value to existing variable if already exists)</li>
</ol>
<p>You can now continue with the <a href="./project_setup.html">project setup</a>.</p>
</details>
<details>
<summary>Build GTK 4 manually with MSVC</summary>
<p>If it's not possible to build with <code>gvsbuild</code> (or you want to customize your build), you
can build GTK 4 and the minimum dependencies you need manually.</p>
<h3 id="set-rust-toolchain-to-msvc-1"><a class="header" href="#set-rust-toolchain-to-msvc-1">Set Rust toolchain to MSVC</a></h3>
<p>Set the Rust toolchain to MSVC by executing:</p>
<pre><code>rustup default stable-msvc
</code></pre>
<h3 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h3>
<p>Install Visual Studio Community from <a href="https://visualstudio.microsoft.com/de/vs/community/">visualstudio.microsoft.com</a>.
Make sure to check the box "Desktop development with C++" during the installation process.</p>
<div style="text-align:center"><img src="img/vs-install.png" /></div>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p>Download git from <a href="https://gitforwindows.org/">gitforwindows.org</a>.</p>
<h3 id="cmake"><a class="header" href="#cmake">CMake</a></h3>
<p>Download CMake from <a href="https://cmake.org/download/">https://cmake.org/download/</a></p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>Download python from <a href="https://www.python.org/downloads">python.org</a>.
Make sure to opt-in to adding Python to your Path during the installation process.</p>
<h3 id="meson"><a class="header" href="#meson">Meson</a></h3>
<p>Install meson by executing:</p>
<pre><code class="language-powershell">pip install meson ninja
</code></pre>
<h3 id="gettext-021"><a class="header" href="#gettext-021">Gettext 0.21</a></h3>
<p>Download Gettext 0.21 from <a href="https://mlocati.github.io/articles/gettext-iconv-windows.html">mlocati.github.io</a>.
Make sure to select the static version.</p>
<h3 id="pkg-config"><a class="header" href="#pkg-config">Pkg-config</a></h3>
<p>Download pkg-config-lite from <a href="https://sourceforge.net/projects/pkgconfiglite/">sourceforge.net</a>.
Then extract and unpack it in <code>C:/</code>, so that the executable is in <code>C:\pkg-config-lite-0.28-1\bin</code>.</p>
<h3 id="update-environment-variables-1"><a class="header" href="#update-environment-variables-1">Update environment variables</a></h3>
<ol>
<li>Go to settings -&gt; Search and open <code>Advanced system settings</code> -&gt; Click on <code>Environment variables</code></li>
<li>Select <code>Path</code> -&gt; Click on <code>Edit</code> -&gt; Add the following entries:</li>
</ol>
<pre><code>C:\pkg-config-lite-0.28-1\bin
C:\gnome\bin
</code></pre>
<ol start="3">
<li>Go back to <code>Environment variables</code></li>
<li>Under <code>User variables</code> click on <code>New</code> and add:</li>
</ol>
<ul>
<li>Variable name: <code>PKG_CONFIG_PATH</code></li>
<li>Variable value: <code>C:\gnome\lib\pkgconfig</code></li>
</ul>
<h3 id="compile-and-install-gtk-4"><a class="header" href="#compile-and-install-gtk-4">Compile and install GTK 4</a></h3>
<p>From the Windows start menu, search for <code>x64 Native Tools Command Prompt for VS 2019</code>.
That will open a terminal configured to use MSVC x64 tools.
From there, run the following commands:</p>
<pre><code class="language-cmd">cd /
git clone https://gitlab.gnome.org/GNOME/gtk.git --depth 1
git clone https://gitlab.gnome.org/GNOME/libxml2.git --depth 1
git clone https://gitlab.gnome.org/GNOME/librsvg.git --depth 1

:: Make sure that cmd finds pkg-config-lite when searching for pkg-config
where pkg-config

:: Make sure that setuptools is available.
pip install setuptools

cd gtk
meson setup builddir --prefix=C:/gnome -Dbuild-tests=false -Dmedia-gstreamer=disabled
meson install -C builddir
cd /

cd libxml2
cmake -S . -B build -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=C:\gnome -D LIBXML2_WITH_ICONV=OFF -D LIBXML2_WITH_LZMA=OFF -D LIBXML2_WITH_PYTHON=OFF -D LIBXML2_WITH_ZLIB=OFF
cmake --build build --config Release
cmake --install build
cd /

cd librsvg/win32
nmake /f generate-msvc.mak generate-nmake-files
nmake /f Makefile.vc CFG=release install PREFIX=C:\gnome
cd /
</code></pre>
<p>You can now continue with the <a href="./project_setup.html">project setup</a>.</p>
</details>
<details>
<summary>Install GTK 4 with MSYS2 and the GNU toolchain</summary>
<h3 id="install-rustup-1"><a class="header" href="#install-rustup-1">Install Rustup</a></h3>
<p>Install the rust toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<h3 id="remove-residues-from-the-msvc-toolchain"><a class="header" href="#remove-residues-from-the-msvc-toolchain">Remove residues from the MSVC toolchain</a></h3>
<p>If you used the MSVC toolchain before, make sure to revert all changes you made to environment variables during the installation process.</p>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<p>Install MSYS2 from <a href="https://www.msys2.org/">www.msys2.org</a></p>
<h3 id="install-gtk-4-1"><a class="header" href="#install-gtk-4-1">Install GTK 4</a></h3>
<p>From the Windows start menu, search for <code>MSYS2 MinGW 64-bit</code>.
That will open a terminal configured to use MinGW x64 tools.</p>
<p>There, execute the following commands to install <code>GTK 4</code>, <code>pkgconf</code> and <code>gcc</code>.</p>
<pre><code class="language-sh">pacman -S mingw-w64-x86_64-gtk4 mingw-w64-x86_64-gettext mingw-w64-x86_64-libxml2 mingw-w64-x86_64-librsvg mingw-w64-x86_64-pkgconf mingw-w64-x86_64-gcc
</code></pre>
<h3 id="update-path-environment-variable"><a class="header" href="#update-path-environment-variable">Update <code>Path</code> environment variable</a></h3>
<ol>
<li>Go to settings -&gt; Search and open <code>Advanced system settings</code> -&gt; Click on <code>Environment variables</code></li>
<li>Select <code>Path</code> -&gt; Click on <code>Edit</code> -&gt; Add the following three entries:</li>
</ol>
<pre><code>C:\msys64\mingw64\include
C:\msys64\mingw64\bin
C:\msys64\mingw64\lib
</code></pre>
<h3 id="setup-the-gnu-toolchain-for-rust"><a class="header" href="#setup-the-gnu-toolchain-for-rust">Setup the GNU toolchain for Rust</a></h3>
<p>The default toolchain on windows is <code>stable-msvc</code>.
To switch to <code>stable-gnu</code>, run the following commands from your terminal:</p>
<ol>
<li><code>rustup toolchain install stable-gnu</code></li>
<li><code>rustup default stable-gnu</code></li>
</ol>
<p>Please note that this command might change in the future.
If it does not work anymore, please open an <a href="https://github.com/gtk-rs/gtk4-rs/issues/new/choose">issue</a> on our repo.</p>
<p>You can now continue with the <a href="./project_setup.html">project setup</a>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<p>Let's begin by installing all necessary tools.
First, follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.</p>
<p>Now, create a new project and move into the newly created folder by executing:</p>
<pre><code>cargo new my-gtk-app
cd my-gtk-app
</code></pre>
<p>Find out the GTK 4 version on your machine by running</p>
<pre><code>pkg-config --modversion gtk4
</code></pre>
<p>Use this information to add the <a href="https://crates.io/crates/gtk4">gtk4 crate</a> to your dependencies in <code>Cargo.toml</code>.
At the time of this writing the newest version is <code>4.12</code>.</p>
<pre><code>cargo add gtk4 --rename gtk --features v4_12
</code></pre>
<p>By specifying this feature you opt-in to API that was added with minor releases of GTK 4.</p>
<p>Now, you can run your application by executing:</p>
<pre><code>cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Now that we've got a working installation, let's get right into it!</p>
<p>At the very least, we need to create a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html"><code>gtk::Application</code></a> instance with an <a href="https://developer.gnome.org/documentation/tutorials/application-id.html">application id</a>.
For that we use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a> which many <code>gtk-rs</code> objects support.
Note that we also import the prelude to bring the necessary traits into scope.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/1/main.rs">listings/hello_world/1/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application};

const APP_ID: &amp;str = "org.gtk_rs.HelloWorld1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Run the application
    app.run()
}</code></pre>
<p>It builds fine, but nothing but a warning in our terminal appears.</p>
<pre><code>GLib-GIO-WARNING: Your application does not implement g_application_activate()
and has no handlers connected to the 'activate' signal. It should do one of these.
</code></pre>
<p>GTK tells us that something should be called in its <code>activate</code> step.
So let's create a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> there.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/2/main.rs">listings/hello_world/2/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow};

const APP_ID: &amp;str = "org.gtk_rs.HelloWorld2";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .build();

    // Present window
    window.present();
}</code></pre>
<p>That is better!</p>
<div style="text-align:center"><img src="img/hello_world_empty.png" alt="An empty window with a header bar with label 'My GTK App'"/></div>
<p>Normally we expect to be able to interact with the user interface.
Also, the name of the chapter suggests that the phrase "Hello World!" will be involved.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<blockquote>
<p>If you look closely at the code snippet you will notice that it has a small eye symbol on its top right.
After you press on it you can see the full code of the listing.
We will use this throughout the book to hide details which are not important to bring the message across.
Pay attention to this if you want to write apps by following the book step-by-step.
Here, we've hidden that we brought <code>gtk::Button</code> into scope.</p>
</blockquote>
<p>There is now a button and if we click on it, its label becomes "Hello World!".</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/hello_world_button.webm" type="video/webm">
  <p>A video which shows that pressing on the button changes it's label</p>
 </video>
</div>
<p>Wasn't that hard to create our first <code>gtk-rs</code> app, right?
Let's now get a better understanding of what we did here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are the components that make up a GTK application.
GTK offers many widgets and if those don't fit, you can even create custom ones.
There are, for example, display widgets, buttons, containers and windows.
One kind of widget might be able to contain other widgets, it might present information and it might react to interaction.</p>
<p>The <a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> is useful to find out which widget fits your needs.
Let's say we want to add a button to our app.
We have quite a bit of choice here, but let's take the simplest one — a <code>Button</code>.</p>
<div style="text-align:center"><img src="img/widgets_button.png" /></div>
<p>GTK is an object-oriented framework, so all widgets are part of an inheritance tree with <code>GObject</code> at the top.
The inheritance tree of a <code>Button</code> looks like this:</p>
<pre><code class="language-console">GObject
╰── Widget
    ╰── Button
</code></pre>
<p>The <a href="https://docs.gtk.org/gtk4/class.Button.html#implements">GTK documentation</a> also tells us that <code>Button</code> implements the interfaces <code>GtkAccessible</code>, <code>GtkActionable</code>, <code>GtkBuildable</code>, <code>GtkConstraintTarget</code>.</p>
<p>Now let's compare that with the corresponding <code>Button</code> struct in <code>gtk-rs</code>.
The <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#implements">gtk-rs documentation</a> tells us which traits it implements.
We find that these traits either have a corresponding base class or interface in the GTK docs.
In the "Hello World" app we wanted to react to a button click.
This behavior is specific to a button, so we expect to find a suitable method in the <code>ButtonExt</code> trait.
And indeed, <code>ButtonExt</code> includes the method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gobject-concepts"><a class="header" href="#gobject-concepts">GObject Concepts</a></h1>
<p>GTK is an object-oriented framework.
It is written in C, which does not support object-orientation out of the box.
That is why GTK relies on the GObject library to provide the object system.</p>
<p>We have already learned that <code>gtk-rs</code> maps GObject concepts, like inheritance and interfaces, to Rust traits.
In this chapter we will learn:</p>
<ul>
<li>How memory of GObjects is managed</li>
<li>How to create our own GObjects via subclassing</li>
<li>How to deal with generic values</li>
<li>How to use properties</li>
<li>How to emit and receive signals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Memory management when writing a gtk-rs app can be a bit tricky.
Let's have a look why that is the case and how to deal with that.</p>
<p>With our first example, we have window with a single button.
Every button click should increment an integer <code>number</code> by one.</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement0";
</span><span class="boring">
</span>// DOES NOT COMPILE!
fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(application: &amp;Application) {
    // Create two buttons
    let button_increase = Button::builder()
        .label("Increase")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(|_| number += 1);

    // Create a window
    let window = ApplicationWindow::builder()
        .application(application)
        .title("My GTK App")
        .child(&amp;button_increase)
        .build();

    // Present the window
    window.present();
}</code></pre>
<p>The Rust compiler refuses to compile this application while spitting out multiple error messages.
Let's have a look at them one by one.</p>
<pre><code class="language-console">
error[E0373]: closure may outlive the current function, but it borrows `number`, which is owned by the current function
   |
32 |     button_increase.connect_clicked(|_| number += 1);
   |                                     ^^^ ------ `number` is borrowed here
   |                                     |
   |                                     may outlive borrowed value `number`
   |
note: function requires argument type to outlive `'static`
   |
32 |     button_increase.connect_clicked(|_| number += 1);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `number` (and any other referenced variables), use the `move` keyword
   |
32 |     button_increase.connect_clicked(move |_| number += 1);
   |
</code></pre>
<p>Our closure only borrows <code>number</code>.
Signal handlers in GTK require <code>'static</code> lifetimes for their references, so we cannot borrow a variable that only lives for the scope of the function <code>build_ui</code>.
The compiler also suggests how to fix this.
By adding the <code>move</code> keyword in front of the closure, <code>number</code> will be moved into the closure.</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement0";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE!
    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(move |_| number += 1);
<span class="boring">
</span><span class="boring">   // Create a window
</span><span class="boring">   let window = ApplicationWindow::builder()
</span><span class="boring">       .application(application)
</span><span class="boring">       .title("My GTK App")
</span><span class="boring">       .child(&amp;button_increase)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // Present the window
</span><span class="boring">   window.present();
</span><span class="boring">}</span></code></pre>
<p>This still leaves the following error message:</p>
<pre><code class="language-console">
error[E0594]: cannot assign to `number`, as it is a captured variable in a `Fn` closure
   |
32 |     button_increase.connect_clicked(move |_| number += 1);
   |                                              ^^^^^^^^^^^ cannot assign
</code></pre>
<p>In order to understand that error message we have to understand the difference between the three closure traits <code>FnOnce</code>, <code>FnMut</code> and <code>Fn</code>.
APIs that take closures implementing the <code>FnOnce</code> trait give the most freedom to the API consumer.
The closure is called only once, so it can even consume its state.
Signal handlers can be called multiple times, so they cannot accept <code>FnOnce</code>.</p>
<p>The more restrictive <code>FnMut</code> trait doesn't allow closures to consume their state, but they can still mutate it.
Signal handlers can't allow this either, because they can be called from inside themselves.
This would lead to multiple mutable references which the borrow checker doesn't appreciate at all.</p>
<p>This leaves <code>Fn</code>.
State can be immutably borrowed, but then how can we modify <code>number</code>?
We need a data type with interior mutability like <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>std::cell::Cell</code></a>.</p>
<blockquote>
<p>The <code>Cell</code> class is only suitable for objects that implement the <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a> trait.
For other objects, <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> is the way to go.
You can learn more about interior mutability in this <a href="https://marabos.nl/atomics/basics.html#interior-mutability">section</a> of the book <em>Rust Atomics and Locks</em>.</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/2/main.rs">listings/g_object_memory_management/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(application: &amp;Application) {
    // Create two buttons
    let button_increase = Button::builder()
        .label("Increase")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // A mutable integer
    let number = Cell::new(0);

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(move |_| number.set(number.get() + 1));

    // Create a window
    let window = ApplicationWindow::builder()
        .application(application)
        .title("My GTK App")
        .child(&amp;button_increase)
        .build();

    // Present the window
    window.present();
}</code></pre>
<p>This now compiles as expected.
Let's try a slightly more complicated example: two buttons which both modify the same <code>number</code>.
For that, we need a way that both closures take ownership of the same value?</p>
<p>That is exactly what the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>std::rc::Rc</code></a> type is there for.
<code>Rc</code> counts the number of strong references created via <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>Clone::clone</code></a> and released via <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>Drop::drop</code></a>, and only deallocates the value when this number drops to zero.
If we want to modify the content of our <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>,
we can again use the <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> type.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/2/main.rs">listings/g_object_memory_management/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Reference-counted object with inner-mutability
    let number = Rc::new(Cell::new(0));

    // Connect callbacks, when a button is clicked `number` will be changed
    let number_copy = number.clone();
    button_increase.connect_clicked(move |_| number_copy.set(number_copy.get() + 1));
    button_decrease.connect_clicked(move |_| number.set(number.get() - 1));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>It is not very nice though to fill the scope with temporary variables like <code>number_copy</code>.
We can improve that by using the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.clone.html"><code>glib::clone!</code></a> macro.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/3/main.rs">listings/g_object_memory_management/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` will be changed
</span>    button_increase.connect_clicked(clone!(
        #[strong]
        number,
        move |_| {
            number.set(number.get() + 1);
        }
    ));
    button_decrease.connect_clicked(move |_| {
        number.set(number.get() - 1);
    });
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Just like <code>Rc&lt;Cell&lt;T&gt;&gt;</code>, GObjects are reference-counted and mutable.
Therefore, we can pass the buttons the same way to the closure as we did with <code>number</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/4/main.rs">listings/g_object_memory_management/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(
        #[weak]
        number,
        #[strong]
        button_decrease,
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
        }
    ));
    button_decrease.connect_clicked(clone!(
        #[strong]
        button_increase,
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
        }
    ));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>If we now click on one button, the other button's label gets changed.</p>
<p>But whoops!
Did we forget about one annoyance of reference-counted systems?
Yes we did: <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycles</a>.
<code>button_increase</code> holds a strong reference to <code>button_decrease</code> and vice-versa.
A strong reference keeps the referenced value from being deallocated.
If this chain leads to a circle, none of the values in this cycle ever get deallocated.
With weak references we can break this cycle, because they don't keep their value alive but instead provide a way to retrieve a strong reference if the value is still alive.
Since we want our apps to free unneeded memory, we should use weak references for the buttons instead.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(
        #[weak]
        number,
        #[weak]
        button_decrease,
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
        }
    ));
    button_decrease.connect_clicked(clone!(
        #[weak]
        button_increase,
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
        }
    ));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>The reference cycle is broken.
Every time the button is clicked, <code>glib::clone</code> tries to upgrade the weak reference.
If we now for example click on one button and the other button is not there anymore, the callback will be skipped.
Per default, it immediately returns from the closure with <code>()</code> as return value.
In case the closure expects a different return value <code>@default-return</code> can be specified.</p>
<p>Notice that we move <code>number</code> in the second closure.
If we had moved weak references in both closures, nothing would have kept <code>number</code> alive and the closure would have never been called.
Thinking about this, <code>button_increase</code> and <code>button_decrease</code> are also dropped at the end of the scope of <code>build_ui</code>.
Who then keeps the buttons alive?</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        number,
</span><span class="boring">        #[weak]
</span><span class="boring">        button_decrease,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">    button_decrease.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        button_increase,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">
</span>    // Add buttons to `gtk_box`
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .build();
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>When we append the buttons to the <code>gtk_box</code>, <code>gtk_box</code> keeps a strong reference to them.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        number,
</span><span class="boring">        #[weak]
</span><span class="boring">        button_decrease,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">    button_decrease.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        button_increase,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span>    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;gtk_box)
        .build();
<span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>When we set <code>gtk_box</code> as child of <code>window</code>, <code>window</code> keeps a strong reference to it.
Until we close the <code>window</code> it keeps <code>gtk_box</code> and with it the buttons alive.
Since our application has only one window, closing it also means exiting the application.</p>
<p>As long as you use weak references whenever possible, you will find it perfectly doable to avoid memory cycles within your application.
Without memory cycles, you can rely on GTK to properly manage the memory of GObjects you pass to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h1>
<p>GObjects rely heavily on inheritance.
Therefore, it makes sense that if we want to create a custom GObject, this is done via subclassing.
Let's see how this works by replacing the button in our "Hello World!" app with a custom one.
First, we need to create an implementation struct that holds the state and overrides the virtual methods.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_subclassing/1/custom_button/imp.rs">listings/g_object_subclassing/1/custom_button/imp.rs</a></p>
<pre><code class="language-rust">use gtk::glib;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {}</code></pre>
<p>The description of the subclassing is in <code>ObjectSubclass</code>.</p>
<ul>
<li><code>NAME</code> should consist of crate-name and object-name in order to avoid name collisions. Use <a href="https://en.wikipedia.org/wiki/Camel_case">UpperCamelCase</a> here.</li>
<li><code>Type</code> refers to the actual GObject that will be created afterwards.</li>
<li><code>ParentType</code> is the GObject we inherit of.</li>
</ul>
<p>After that, we would have the option to override the virtual methods of our ancestors.
Since we only want to have a plain button for now, we override nothing.
We still have to add the empty <code>impl</code> though.
Next, we describe the public interface of our custom GObject.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_subclassing/1/custom_button/mod.rs">listings/g_object_subclassing/1/custom_button/mod.rs</a></p>
<pre><code class="language-rust">mod imp;

use glib::Object;
use gtk::glib;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        Object::builder().build()
    }

    pub fn with_label(label: &amp;str) -&gt; Self {
        Object::builder().property("label", label).build()
    }
}
<span class="boring">
</span><span class="boring">impl Default for CustomButton {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.wrapper.html"><code>glib::wrapper!</code></a> implements the same traits that our <code>ParentType</code> implements.
Theoretically that would mean that the <code>ParentType</code> is also the only thing we have to specify here.
Unfortunately, nobody has yet found a good way to do that.
Which is why, as of today, subclassing of GObjects in Rust requires to mention all ancestors and interfaces apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.
For <code>gtk::Button</code>, we can look up the ancestors and interfaces in the corresponding <a href="https://docs.gtk.org/gtk4/class.Button.html#hierarchy">doc page</a> of GTK4.</p>
<p>After these steps, nothing is stopping us from replacing <code>gtk::Button</code> with our <code>CustomButton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_subclassing/1/main.rs">listings/g_object_subclassing/1/main.rs</a></p>
<pre><code class="language-rust">mod custom_button;

use custom_button::CustomButton;
use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow};

const APP_ID: &amp;str = "org.gtk_rs.GObjectSubclassing1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::with_label("Press me!");
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<blockquote>
<p>Describing objects with two structs is a peculiarity coming from how GObjects are defined in C.
<code>imp::CustomButton</code> handles the state of the GObject and the overridden virtual methods.
<code>CustomButton</code> determines the exposed methods from the implemented traits and added methods.</p>
</blockquote>
<h2 id="adding-functionality"><a class="header" href="#adding-functionality">Adding Functionality</a></h2>
<p>We are able to use <code>CustomButton</code> as a drop-in replacement for <code>gtk::Button</code>.
This is cool, but also not very tempting to do in a real application.
For the gain of zero benefits, it did involve quite a bit of boilerplate after all.</p>
<p>So let's make it a bit more interesting!
<code>gtk::Button</code> does not hold much state, but we can let <code>CustomButton</code> hold a number.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_subclassing/2/custom_button/imp.rs">listings/g_object_subclassing/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust">use std::cell::Cell;

use gtk::glib;
use gtk::prelude::*;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton {
    number: Cell&lt;i32&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self) {
        self.parent_constructed();
        self.obj().set_label(&amp;self.number.get().to_string());
    }
}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        self.number.set(self.number.get() + 1);
        self.obj().set_label(&amp;self.number.get().to_string())
    }
}</code></pre>
<p>We override <code>constructed</code> in <code>ObjectImpl</code> so that the label of the button initializes with <code>number</code>.
We also override <code>clicked</code> in <code>ButtonImpl</code> so that every click increases <code>number</code> and updates the label.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_subclassing/2/main.rs">listings/g_object_subclassing/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSubclassing2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::new();
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>In <code>build_ui</code> we stop calling <code>connect_clicked</code>, and that was it.
After a rebuild, the app now features our <code>CustomButton</code> with the label "0".
Every time we click on the button, the number displayed by the label increases by 1.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/g_object_subclassing.webm" type="video/webm">
  <p>A video showing that pressing on a button increases the number</p>
 </video>
</div>
<p>So, when do we want to inherit from GObject?</p>
<ul>
<li>We want to use a certain widget, but with added state and overridden virtual functions.</li>
<li>We want to pass a Rust object to a function, but the function expects a GObject.</li>
<li>We want to add properties or signals to an object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-values"><a class="header" href="#generic-values">Generic Values</a></h1>
<p>Some GObject-related functions rely on generic values for their arguments or return parameters.
Since GObject introspection works through a C interface, these functions cannot rely on any powerful Rust concepts.
In these cases <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html"><code>glib::Value</code></a> or <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/struct.Variant.html"><code>glib::Variant</code></a> are used.</p>
<h2 id="value"><a class="header" href="#value">Value</a></h2>
<p>Let's start with <code>Value</code>.
Conceptually, a <code>Value</code> is similar to a Rust <code>enum</code> defined like this:</p>
<pre><code class="language-rust  no_run noplayground">enum Value &lt;T&gt; {
    bool(bool),
    i8(i8),
    i32(i32),
    u32(u32),
    i64(i64),
    u64(u64),
    f32(f32),
    f64(f64),
    // boxed types
    String(Option&lt;String&gt;),
    Object(Option&lt;dyn IsA&lt;glib::Object&gt;&gt;),
}</code></pre>
<p>For example, this is how you would use a <code>Value</code> representing an <code>i32</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Value`
    let integer_value = 10.to_value();

    // Retrieve `i32` from `Value`
    let integer = integer_value
        .get::&lt;i32&gt;()
        .expect("The value needs to be of type `i32`.");

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = "Hello!".to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, "Hello!".to_string());
</span><span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = "Hello!".to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some("Hello!".to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}</span></code></pre>
<p>Also note that in the <code>enum</code> above boxed types such as <code>String</code> or <code>glib::Object</code> are wrapped in an <code>Option</code>.
This comes from C, where every boxed type can potentially be <code>None</code> (or <code>NULL</code> in C terms).
You can still access it the same way as with the <code>i32</code> above.
<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html#method.get"><code>get</code></a> will then not only return <code>Err</code> if you specified the wrong type, but also if the <code>Value</code> represents <code>None</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The value needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    // Store string as `Value`
    let string_value = "Hello!".to_value();

    // Retrieve `String` from `Value`
    let string = string_value
        .get::&lt;String&gt;()
        .expect("The value needs to be of type `String`.");

    // Check if the retrieved value is correct
    assert_eq!(string, "Hello!".to_string());
<span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = "Hello!".to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some("Hello!".to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}</span></code></pre>
<p>If you want to differentiate between specifying the wrong type and a <code>Value</code> representing <code>None</code>, just call <code>get::&lt;Option&lt;T&gt;&gt;</code> instead.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The value needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = "Hello!".to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, "Hello!".to_string());
</span><span class="boring">
</span>    // Store `Option&lt;String&gt;` as `Value`
    let string_some_value = "Hello!".to_value();
    let string_none_value = None::&lt;String&gt;.to_value();

    // Retrieve `String` from `Value`
    let string_some = string_some_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect("The value needs to be of type `Option&lt;String&gt;`.");
    let string_none = string_none_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect("The value needs to be of type `Option&lt;String&gt;`.");

    // Check if the retrieved value is correct
    assert_eq!(string_some, Some("Hello!".to_string()));
    assert_eq!(string_none, None);
<span class="boring">}</span></code></pre>
<p>We will use <code>Value</code> when we deal with properties and signals later on.</p>
<h2 id="variant"><a class="header" href="#variant">Variant</a></h2>
<p>A <code>Variant</code> is used whenever data needs to be serialized, for example for sending it to another process or over the network, or for storing it on disk.
Although <code>GVariant</code> supports arbitrarily complex types, the Rust bindings are currently limited to <code>bool</code>, <code>u8</code>, <code>i16</code>, <code>u16</code>, <code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f64</code>, <code>&amp;str</code>/<code>String</code>, and <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.VariantDict.html"><code>VariantDict</code></a>.
Containers of the above types are possible as well, such as <code>HashMap</code>, <code>Vec</code>, <code>Option</code>, tuples up to 16 elements, and <code>Variant</code>.
Variants can even be <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib_macros/derive.Variant.html#">derived</a> from Rust structs as long as its members can be represented by variants.</p>
<p>In the most simple case, converting Rust types to <code>Variant</code> and vice-versa is very similar to the way it worked with <code>Value</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_values/2/main.rs">listings/g_object_values/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Variant`
    let integer_variant = 10.to_variant();

    // Retrieve `i32` from `Variant`
    let integer = integer_variant
        .get::&lt;i32&gt;()
        .expect("The variant needs to be of type `i32`.");

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    let variant = vec!["Hello", "there!"].to_variant();
</span><span class="boring">    assert_eq!(variant.n_children(), 2);
</span><span class="boring">    let vec = &amp;variant
</span><span class="boring">        .get::&lt;Vec&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The variant needs to be of type `String`.");
</span><span class="boring">    assert_eq!(vec[0], "Hello");
</span><span class="boring">}</span></code></pre>
<p>However, a <code>Variant</code> is also able to represent containers such as <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> or <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>.
The following snippet shows how to convert between <code>Vec</code> and <code>Variant</code>.
More examples can be found in the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/index.html">docs</a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_values/2/main.rs">listings/g_object_values/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Variant`
</span><span class="boring">    let integer_variant = 10.to_variant();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Variant`
</span><span class="boring">    let integer = integer_variant
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    let variant = vec!["Hello", "there!"].to_variant();
    assert_eq!(variant.n_children(), 2);
    let vec = &amp;variant
        .get::&lt;Vec&lt;String&gt;&gt;()
        .expect("The variant needs to be of type `String`.");
    assert_eq!(vec[0], "Hello");
<span class="boring">}</span></code></pre>
<p>We will use <code>Variant</code> when saving settings using <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> or activating actions via <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html"><code>gio::Action</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<p>Properties provide a public API for accessing state of GObjects.</p>
<p>Let's see how this is done by experimenting with the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html"><code>Switch</code></a> widget.
One of its properties is called <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#active">active</a>.
According to the GTK docs, it can be read and be written to.
That is why <code>gtk-rs</code> provides corresponding <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.is_active"><code>is_active</code></a> and <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.set_active"><code>set_active</code></a> methods.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/1/main.rs">listings/g_object_properties/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain active property
    switch.set_active(true);
    let switch_active = switch.is_active();

    // This prints: "The active property of switch is true"
    println!("The active property of switch is {}", switch_active);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Properties can not only be accessed via getters &amp; setters, they can also be bound to each other.
Let's see how that would look like for two <code>Switch</code> instances.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/2/main.rs">listings/g_object_properties/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switches
    let switch_1 = Switch::new();
    let switch_2 = Switch::new();
<span class="boring">
</span><span class="boring">    switch_1
</span><span class="boring">        .bind_property("active", &amp;switch_2, "active")
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>In our case, we want to bind the "active" property of <code>switch_1</code> to the "active" property of <code>switch_2</code>.
We also want the binding to be bidirectional, so we specify by calling the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.bidirectional"><code>bidirectional</code></a> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/2/main.rs">listings/g_object_properties/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the switches
</span><span class="boring">    let switch_1 = Switch::new();
</span><span class="boring">    let switch_2 = Switch::new();
</span><span class="boring">
</span>    switch_1
        .bind_property("active", &amp;switch_2, "active")
        .bidirectional()
        .build();
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now when we click on one of the two switches, the other one is toggled as well.</p>
<div style="text-align:center">
 <video autoplay muted loop>
    <source src="vid/g_object_properties_switches.webm">
    <p>A video which shows that toggling one button also toggles the other one </p>
 </video>
</div>
<h2 id="adding-properties-to-custom-gobjects"><a class="header" href="#adding-properties-to-custom-gobjects">Adding Properties to Custom GObjects</a></h2>
<p>We can also add properties to custom GObjects.
We can demonstrate that by binding the <code>number</code> of our <code>CustomButton</code> to a property.
Most of the work is done by the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/derive.Properties.html"><code>glib::Properties</code></a> derive macro.
We tell it that the wrapper type is <code>super::CustomButton</code>.
We also annotate <code>number</code>, so that macro knows that it should create a property "number" that is readable and writable.
It also generates <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/derive.Properties.html#generated-wrapper-methods">wrapper methods</a> which we are going to use later in this chapter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/3/custom_button/imp.rs">listings/g_object_properties/3/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CustomButton)]
pub struct CustomButton {
    #[property(get, set)]
    number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        self.obj().set_number(incremented_number);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/attr.derived_properties.html"><code>glib::derived_properties</code></a> macro generates boilerplate that is the same for every GObject that generates its properties with the <code>Property</code> macro.
In <code>constructed</code> we use our new property "number" by binding the "label" property to it.
<code>bind_property</code> converts the integer value of "number" to the string of "label" on its own.
Now we don't have to adapt the label in the "clicked" callback anymore.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/3/custom_button/imp.rs">listings/g_object_properties/3/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self) {
        self.parent_constructed();

        // Bind label to number
        // `SYNC_CREATE` ensures that the label will be immediately set
        let obj = self.obj();
        obj.bind_property("number", obj.as_ref(), "label")
            .sync_create()
            .build();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        self.obj().set_number(incremented_number);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also have to adapt the <code>clicked</code> method.
Before we modified <code>number</code> directly, now we can use the generated wrapper methods <code>number</code> and <code>set_number</code>.
This way the "notify" signal will be emitted, which is necessary for the bindings to work as expected.</p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        let incremented_number = self.obj().number() + 1;
        self.obj().set_number(incremented_number);
    }
}</code></pre>
<p>Let's see what we can do with this by creating two custom buttons.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the buttons
    let button_1 = CustomButton::new();
    let button_2 = CustomButton::new();
<span class="boring">
</span><span class="boring">    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property("number", &amp;button_2, "number")
</span><span class="boring">        // How to transform "number" from `button_1` to "number" of `button_2`
</span><span class="boring">        .transform_to(|_, number: i32| {
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform "number" from `button_2` to "number" of `button_1`
</span><span class="boring">        .transform_from(|_, number: i32| {
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .sync_create()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property "number" of `button_1` gets changed
</span><span class="boring">    button_1.connect_number_notify(|button| {
</span><span class="boring">        println!("The current number of `button_1` is {}.", button.number());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>We have already seen that bound properties don't necessarily have to be of the same type.
By leveraging <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_to"><code>transform_to</code></a> and <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_from"><code>transform_from</code></a>, we can assure that <code>button_2</code> always displays a number which is 1 higher than the number of <code>button_1</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span>    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
    button_1
        .bind_property("number", &amp;button_2, "number")
        // How to transform "number" from `button_1` to "number" of `button_2`
        .transform_to(|_, number: i32| {
            let incremented_number = number + 1;
            Some(incremented_number.to_value())
        })
        // How to transform "number" from `button_2` to "number" of `button_1`
        .transform_from(|_, number: i32| {
            let decremented_number = number - 1;
            Some(decremented_number.to_value())
        })
        .bidirectional()
        .sync_create()
        .build();
<span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property "number" of `button_1` gets changed
</span><span class="boring">    button_1.connect_number_notify(|button| {
</span><span class="boring">        println!("The current number of `button_1` is {}.", button.number());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now if we click on one button, the "number" and "label" properties of the other button change as well.</p>
<div style="text-align:center">
 <video autoplay muted loop>
    <source src="vid/g_object_properties_buttons.webm">
    <p>A video which shows that pressing on one button also changes the number on the other one</p>
 </video>
</div>
<p>Another nice feature of properties is, that you can connect a callback to the event, when a property gets changed.
For example like this:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property("number", &amp;button_2, "number")
</span><span class="boring">        // How to transform "number" from `button_1` to "number" of `button_2`
</span><span class="boring">        .transform_to(|_, number: i32| {
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform "number" from `button_2` to "number" of `button_1`
</span><span class="boring">        .transform_from(|_, number: i32| {
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .sync_create()
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // The closure will be called
    // whenever the property "number" of `button_1` gets changed
    button_1.connect_number_notify(|button| {
        println!("The current number of `button_1` is {}.", button.number());
    });
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now, whenever the "number" property gets changed, the closure gets executed and prints the current value of "number" to standard output.</p>
<p>Introducing properties to your custom GObjects is useful if you want to</p>
<ul>
<li>bind state of (different) GObjects</li>
<li>notify consumers whenever a property value changes</li>
</ul>
<p>Note that it has a (computational) cost to send a signal each time the value changes.
If you only want to expose internal state, adding getter and setter methods is the better option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>GObject signals are a system for registering callbacks for specific events.
For example, if we press on a button, the "clicked" signal will be emitted.
The signal then takes care that all the registered callbacks will be executed.</p>
<p><code>gtk-rs</code> provides convenience methods for registering callbacks.
In our "Hello World" example we <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked">connected</a> the "clicked" signal to a closure which sets the label of the button to "Hello World" as soon as it gets called.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button with label and margins
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>If we wanted to, we could have connected to it with the generic <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect_closure"><code>connect_closure</code></a> method and the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.closure_local.html"><code>glib::closure_local!</code></a> macro.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_signals/1/main.rs">listings/g_object_signals/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::closure_local;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSignals1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_closure(
        "clicked",
        false,
        closure_local!(move |button: Button| {
            // Set the label to "Hello World!" after the button has been clicked on
            button.set_label("Hello World!");
        }),
    );

<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>The advantage of <code>connect_closure</code> is that it also works with custom signals.</p>
<blockquote>
<p>If you need to clone reference counted objects into your closure you don't have to wrap it within another <code>clone!</code> macro.
<code>closure_local!</code> accepts the same syntax for creating strong/weak references, plus a <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.closure.html#object-watching">watch</a> feature that automatically disconnects the closure once the watched object is dropped.</p>
</blockquote>
<h2 id="adding-signals-to-custom-gobjects"><a class="header" href="#adding-signals-to-custom-gobjects">Adding Signals to Custom GObjects</a></h2>
<p>Let's see how we can create our own signals.
Again we do that by extending our <code>CustomButton</code>.
First we override the <code>signals</code> method in <code>ObjectImpl</code>.
In order to do that, we need to lazily initialize a static item <code>SIGNALS</code>.
<a href="https://doc.rust-lang.org/std/sync/struct.OnceLock.html"><code>std::sync::OnceLock</code></a> ensures that <code>SIGNALS</code> will only be initialized once.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_signals/2/custom_button/imp.rs">listings/g_object_signals/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for CustomButton {
    fn signals() -&gt; &amp;'static [Signal] {
        static SIGNALS: OnceLock&lt;Vec&lt;Signal&gt;&gt; = OnceLock::new();
        SIGNALS.get_or_init(|| {
            vec![Signal::builder("max-number-reached")
                .param_types([i32::static_type()])
                .build()]
        })
    }
<span class="boring">
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">static MAX_NUMBER: i32 = 8;
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        // If `number` reached `MAX_NUMBER`,
</span><span class="boring">        // emit "max-number-reached" signal and set `number` back to 0
</span><span class="boring">        if incremented_number == MAX_NUMBER {
</span><span class="boring">            obj.emit_by_name::&lt;()&gt;("max-number-reached", &amp;[&amp;incremented_number]);
</span><span class="boring">            obj.set_number(0);
</span><span class="boring">        } else {
</span><span class="boring">            obj.set_number(incremented_number);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The <code>signals</code> method is responsible for defining a set of signals.
In our case, we only create a single signal named "max-number-reached".
When naming our signal, we make sure to do that in <a href="https://en.wikipedia.org/wiki/Letter_case#Kebab_case">kebab-case</a>.
When emitted, it sends a single <code>i32</code> value.</p>
<p>We want the signal to be emitted, whenever <code>number</code> reaches <code>MAX_NUMBER</code>.
Together with the signal we send the value <code>number</code> currently holds.
After we did that, we set <code>number</code> back to 0.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_signals/2/custom_button/imp.rs">listings/g_object_signals/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn signals() -&gt; &amp;'static [Signal] {
</span><span class="boring">        static SIGNALS: OnceLock&lt;Vec&lt;Signal&gt;&gt; = OnceLock::new();
</span><span class="boring">        SIGNALS.get_or_init(|| {
</span><span class="boring">            vec![Signal::builder("max-number-reached")
</span><span class="boring">                .param_types([i32::static_type()])
</span><span class="boring">                .build()]
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>static MAX_NUMBER: i32 = 8;

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        let incremented_number = self.obj().number() + 1;
        let obj = self.obj();
        // If `number` reached `MAX_NUMBER`,
        // emit "max-number-reached" signal and set `number` back to 0
        if incremented_number == MAX_NUMBER {
            obj.emit_by_name::&lt;()&gt;("max-number-reached", &amp;[&amp;incremented_number]);
            obj.set_number(0);
        } else {
            obj.set_number(incremented_number);
        }
    }
}</code></pre>
<p>If we now press on the button, the number of its label increases until it reaches <code>MAX_NUMBER</code>.
Then it emits the "max-number-reached" signal which we can nicely connect to.
Whenever we now receive the "max-number-reached" signal, the accompanying number is printed to <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">standard output</a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/g_object_signals/2/main.rs">listings/g_object_signals/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::closure_local;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSignals2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span>    button.connect_closure(
        "max-number-reached",
        false,
        closure_local!(move |_button: CustomButton, number: i32| {
            println!("The maximum number {} has been reached", number);
        }),
    );
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>You now know how to connect to every kind of signal and how to create your own.
Custom signals are especially useful, if you want to notify consumers of your GObject that a certain event occurred.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-main-event-loop"><a class="header" href="#the-main-event-loop">The Main Event Loop</a></h1>
<p>We now got comfortable using callbacks, but how do they actually work?
All of this happens asynchronously, so there must be something managing the events and scheduling the responses.
Unsurprisingly, this is called the main event loop.</p>
<div style="text-align:center"><img src="img/main_event_loop.png" alt="Diagram showing the main event loop"/></div>
<p>The main loop manages all kinds of events — from mouse clicks and keyboard presses to file events.
It does all of that within the same thread.
Quickly iterating between all tasks gives the illusion of parallelism.
That is why you can move the window at the same time as a progress bar is growing.</p>
<p>However, you surely saw GUIs that became unresponsive, at least for a few seconds.
That happens when a single task takes too long.
The following example uses <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code>std::thread::sleep</code></a> to represent a long-running task.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/1/main.rs">listings/main_event_loop/1/main.rs</a></p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, glib, Application, ApplicationWindow, Button};

const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        thread::sleep(five_seconds);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>After we press the button, the GUI is completely frozen for five seconds.
We can't even move the window.
The <code>sleep</code> call is an artificial example,
but frequently, we want to run a slightly longer operation in one go.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_1.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<h2 id="how-to-avoid-blocking-the-main-loop"><a class="header" href="#how-to-avoid-blocking-the-main-loop">How to Avoid Blocking the Main Loop</a></h2>
<p>In order to avoid blocking the main loop, we can spawn a new task with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/fn.spawn_blocking.html"><code>gio::spawn_blocking</code></a> and let the operation run on the thread pool.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/2/main.rs">listings/main_event_loop/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now the GUI doesn't freeze when we press the button.
However, nothing stops us from spawning as many tasks as we want at the same time.
This is not necessarily what we want.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_2.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<blockquote>
<p>If you come from another language than Rust, you might be uncomfortable with the thought of running tasks in separate threads before even looking at other options.
Luckily, Rust's safety guarantees allow you to stop worrying about the nasty bugs that concurrency tends to bring.</p>
</blockquote>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>Typically, we want to keep track of the work in the task.
In our case, we don't want the user to spawn additional tasks while an existing one is still running.
In order to exchange information with the task we can create a channel with the crate <a href="https://docs.rs/async-channel/latest/async_channel/index.html"><code>async-channel</code></a>.
Let's add it by executing the following in the terminal:</p>
<pre><code>cargo add async-channel
</code></pre>
<p>We want to send a <code>bool</code> to inform, whether we want the button to react to clicks or not.
Since we send in a separate thread, we can use <a href="https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send_blocking"><code>send_blocking</code></a>.
But what about receiving?
Every time we get a message, we want to set the sensitivity of the button according to the <code>bool</code> we've received.
However, we don't want to block the main loop while waiting for a message to receive.
That is the whole point of the exercise after all!</p>
<p>We solve that problem by waiting for messages in an <a href="https://rust-lang.github.io/async-book/"><code>async</code></a> block.
This <code>async</code> block is spawned on the <code>glib</code> main loop with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future_local.html"><code>spawn_future_local</code></a></p>
<blockquote>
<p>See also <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future.html"><code>spawn_future</code></a> for spawning async blocks on the main loop from outside the main thread.</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/3/main.rs">listings/main_event_loop/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            sender
                .send_blocking(false)
                .expect("The channel needs to be open.");
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            sender
                .send_blocking(true)
                .expect("The channel needs to be open.");
        });
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>As you can see, spawning a task still doesn't freeze our user interface.
However, now we can't spawn multiple tasks at the same time since the button becomes insensitive after the first task has been spawned.
After the task is finished, the button becomes sensitive again.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_3.webm" type="video/webm">
  <p>The button now stops being responsive for 10 seconds after being pressed</p>
 </video>
</div>
<p>What if the task is asynchronous by nature?
Let's try <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.timeout_future_seconds.html"><code>glib::timeout_future_seconds</code></a> as representation for our task instead of <code>std::thread::sleep</code>.
It returns a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a>, which means we can <code>await</code> on it within an <code>async</code> context.
The converted code looks and behaves very similar to the multithreaded code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/4/main.rs">listings/main_event_loop/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                // Deactivate the button until the operation is done
                sender
                    .send(false)
                    .await
                    .expect("The channel needs to be open.");
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                sender
                    .send(true)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Since we are single-threaded again, we can even get rid of the channel while achieving the same result.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/5/main.rs">listings/main_event_loop/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                button.set_sensitive(true);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>But why did we not do the same thing with our multithreaded example?</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::{glib, gio};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">       .application_id("org.gtk_rs.MainEventLoop6")
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE!
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Simply because we would get this error message:</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>After reference cycles we found the second disadvantage of GTK GObjects: They are not thread safe.</p>
<h2 id="embed-blocking-calls-in-an-async-context"><a class="header" href="#embed-blocking-calls-in-an-async-context">Embed blocking calls in an <code>async</code> context</a></h2>
<p>We've seen in the previous snippets that spawning an <code>async</code> block or <code>async</code> future on the <code>glib</code> main loop can lead to more concise code than running tasks on separate threads.
Let's focus on a few more aspects that are interesting to know when running <code>async</code> functions with gtk-rs apps.</p>
<p>For a start, blocking functions can be embedded within an <code>async</code> context.
In the following listing, we want to execute a synchronous function that returns a boolean and takes ten seconds to run.
In order to integrate it in our <code>async</code> block, we run the function in a separate thread via <code>spawn_blocking</code>.
We can then get the return value of the function by calling <code>await</code> on the return value of <code>spawn_blocking</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/6/main.rs">listings/main_event_loop/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                let enable_button = gio::spawn_blocking(move || {
                    let five_seconds = Duration::from_secs(5);
                    thread::sleep(five_seconds);
                    true
                })
                .await
                .expect("Task needs to finish successfully.");
                // Set sensitivity of button to `enable_button`
                button.set_sensitive(enable_button);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="run-async-functions-from-external-crates"><a class="header" href="#run-async-functions-from-external-crates">Run <code>async</code> functions from external crates</a></h2>
<p>Asynchronous functions from the <code>glib</code> ecosystem can always be spawned on the <code>glib</code> main loop.
Typically, crates depending on <code>async-std</code> or <code>smol</code> work as well.
Let us take <code>ashpd</code> for example which allows sandboxed applications to interact with the desktop.
It can be configured to depend on <code>async-std</code>.
We can add it to our dependencies by running the following command.</p>
<pre><code>cargo add ashpd --no-default-features --features "gtk4 async-std"
</code></pre>
<p>You need to use a Linux desktop environment in order to run the following example locally.
This example is using <a href="https://docs.rs/ashpd/latest/ashpd/desktop/account/index.html"><code>ashpd::desktop::account::UserInformation</code></a> to access user information.
We are getting a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Native.html"><code>gtk::Native</code></a> object from our button, create a <a href="https://docs.rs/ashpd/latest/ashpd/enum.WindowIdentifier.html"><code>ashpd::WindowIdentifier</code></a> and pass it to the user information request.</p>
<blockquote>
<p>We need to pass the <code>WindowIdentifier</code> to make the dialog modal. This means that it will be on top of the window and freezes the rest of the application from user input.</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/7/main.rs">listings/main_event_loop/7/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop7";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move { fetch_user_information(button).await }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(target_os = "linux")]
</span><span class="boring">async fn fetch_user_information(button: Button) {
</span><span class="boring">    use ashpd::desktop::account::UserInformation;
</span><span class="boring">    use ashpd::WindowIdentifier;
</span><span class="boring">
</span><span class="boring">    // Get native of button for window identifier
</span><span class="boring">    let native = button.native().expect("Need to be able to get native.");
</span><span class="boring">    // Get window identifier so that the dialog will be modal to the main window
</span><span class="boring">    let identifier = WindowIdentifier::from_native(&amp;native).await;
</span><span class="boring">    let request = UserInformation::request()
</span><span class="boring">        .reason("App would like to access user information.")
</span><span class="boring">        .identifier(identifier)
</span><span class="boring">        .send()
</span><span class="boring">        .await;
</span><span class="boring">
</span><span class="boring">    if let Ok(response) = request.and_then(|r| r.response()) {
</span><span class="boring">        println!("User name: {}", response.name());
</span><span class="boring">    } else {
</span><span class="boring">        println!("Could not access user information.")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(not(target_os = "linux"))]
</span><span class="boring">async fn fetch_user_information(_button: Button) {
</span><span class="boring">    println!("fetching user information not available outside target_os = \"linux\"");
</span><span class="boring">}</span></code></pre>
<p>After pressing the button, a dialog should open that shows the information that will be shared.
If you decide to share it, you user name will be printed on the console.</p>
<div style="text-align:center"><img src="img/main_event_loop_ashpd.png" alt="Dialog requesting user information."/></div>
<h2 id="tokio"><a class="header" href="#tokio">Tokio</a></h2>
<p><a href="https://docs.rs/tokio/latest/tokio/"><code>tokio</code></a> is Rust's most popular asynchronous platform.
Therefore, many high-quality crates are part of its ecosystem.
The web client <a href="https://docs.rs/reqwest/latest/reqwest/"><code>reqwest</code></a> belongs to this group.
Let's add it by executing the following command</p>
<pre><code>cargo add reqwest@0.12 --features rustls-tls --no-default-features
</code></pre>
<p>As soon as the button is pressed, we want to send a <code>GET</code> request to <a href="https://www.gtk-rs.org">www.gtk-rs.org</a>.
The response should then be sent to the main thread via a channel.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/8/main.rs">listings/main_event_loop/8/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop8";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>This compiles fine and even seems to run.
However, nothing happens when we press the button.
Inspecting the console gives the following error message:</p>
<pre><code>thread 'main' panicked at
'there is no reactor running, must be called from the context of a Tokio 1.x runtime'
</code></pre>
<p>At the time of writing, <code>reqwest</code> doesn't document this requirement.
Unfortunately, that is also the case for other libraries depending on <code>tokio</code>.
Let's bite the bullet and add <code>tokio</code>:</p>
<pre><code>cargo add tokio@1 --features rt-multi-thread
</code></pre>
<p>Since we already run the <code>glib</code> main loop on our main thread, we don't want to run the <code>tokio</code> runtime there.
For this reason, we <strong>avoid</strong> using the <code>#[tokio::main]</code> macro or using a top-level <code>block_on</code> call.
Doing this will block one of the runtime's threads with the GLib main loop, which is a waste of resources and a potential source of strange bugs.</p>
<p>Instead, we bind <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html"><code>tokio::runtime::Runtime</code></a> to a static variable.</p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop0";
</span><span class="boring">
</span>// DOES NOT COMPILE!
static RUNTIME: Runtime =
    Runtime::new().expect("Setting up tokio runtime needs to succeed.");
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">   // Create a button
</span><span class="boring">   let button = Button::builder()
</span><span class="boring">       .label("Press me!")
</span><span class="boring">       .margin_top(12)
</span><span class="boring">       .margin_bottom(12)
</span><span class="boring">       .margin_start(12)
</span><span class="boring">       .margin_end(12)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // ANCHOR: callback
</span><span class="boring">   let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">   // Connect to "clicked" signal of `button`
</span><span class="boring">   button.connect_clicked(move |_| {
</span><span class="boring">       RUNTIME.spawn(clone!(#[strong] sender, async move {
</span><span class="boring">           let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">           sender.send(response).await.expect("The channel needs to be open.");
</span><span class="boring">       }));
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   // The main loop executes the asynchronous block
</span><span class="boring">   glib::spawn_future_local(async move {
</span><span class="boring">       while let Ok(response) = receiver.recv().await {
</span><span class="boring">           if let Ok(response) = response {
</span><span class="boring">               println!("Status: {}", response.status());
</span><span class="boring">           } else {
</span><span class="boring">               println!("Could not make a `GET` request.");
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   });
</span><span class="boring">   // ANCHOR_END: callback
</span><span class="boring">
</span><span class="boring">   // Create a window
</span><span class="boring">   let window = ApplicationWindow::builder()
</span><span class="boring">       .application(app)
</span><span class="boring">       .title("My GTK App")
</span><span class="boring">       .child(&amp;button)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // Present window
</span><span class="boring">   window.present();
</span><span class="boring">}</span></code></pre>
<p>Unfortunately, this doesn't compile.
As usual, Rust's error messages are really helpful.</p>
<pre><code>cannot call non-const fn `tokio::runtime::Runtime::new` in statics
calls in statics are limited to constant functions, tuple structs and tuple variants
consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate
</code></pre>
<p>We could follow the advice directly, but the standard library also provides solutions for that.
With <a href="https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html"><code>std::sync::OnceLock</code></a> we can initialize the static with the const function <code>OnceLock::new()</code> and initialize it the first time our function <code>runtime</code> is called.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span>fn runtime() -&gt; &amp;'static Runtime {
    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
    RUNTIME.get_or_init(|| {
        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
    })
}
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">    // Connect to "clicked" signal of `button`
</span><span class="boring">    button.connect_clicked(move |_| {
</span><span class="boring">        runtime().spawn(clone!(
</span><span class="boring">            #[strong]
</span><span class="boring">            sender,
</span><span class="boring">            async move {
</span><span class="boring">                let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">                sender
</span><span class="boring">                    .send(response)
</span><span class="boring">                    .await
</span><span class="boring">                    .expect("The channel needs to be open.");
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // The main loop executes the asynchronous block
</span><span class="boring">    glib::spawn_future_local(async move {
</span><span class="boring">        while let Ok(response) = receiver.recv().await {
</span><span class="boring">            if let Ok(response) = response {
</span><span class="boring">                println!("Status: {}", response.status());
</span><span class="boring">            } else {
</span><span class="boring">                println!("Could not make a `GET` request.");
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>In the button callback we can now spawn the <code>reqwest</code> <code>async</code> block with <code>tokio</code> rather than with <code>glib</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span><span class="boring">fn runtime() -&gt; &amp;'static Runtime {
</span><span class="boring">    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
</span><span class="boring">    RUNTIME.get_or_init(|| {
</span><span class="boring">        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        runtime().spawn(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>If we now press the button, we should find the following message in our console:</p>
<pre><code>Status: 200 OK
</code></pre>
<p>We will not need <code>tokio</code>, <code>reqwest</code> or <code>ashpd</code> in the following chapters, so let's remove them again by executing:</p>
<pre><code>cargo remove tokio reqwest ashpd
</code></pre>
<p>How to find out whether you can spawn an <code>async</code> task on the <code>glib</code> main loop?
<code>glib</code> should be able to spawn the task when the called functions come from libraries that either:</p>
<ul>
<li>come from the <code>glib</code> ecosystem,</li>
<li>don't depend on a runtime but only on the <code>futures</code> family of crates (<code>futures-io</code>, <code>futures-core</code> etc),</li>
<li>depend on the <code>async-std</code> or <code>smol</code> runtimes, or</li>
<li>have cargo features that let them depend on <code>async-std</code>/<code>smol</code> instead of <code>tokio</code>.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>You don't want to block the main thread long enough that it is noticeable by the user.
But when should you spawn an <code>async</code> task, instead of spawning a task in a separate thread?
Let's go again through the different scenarios.</p>
<p>If the task spends its time calculating rather than waiting for a web response, it is <a href="https://en.wikipedia.org/wiki/CPU-bound">CPU-bound</a>.
That means you have to run the task in a separate thread and let it send results back via a channel.</p>
<p>If your task is <a href="https://en.wikipedia.org/wiki/I/O_bound">IO bound</a>, the answer depends on the crates at your disposal and the type of work to be done.</p>
<ul>
<li>Light I/O work with functions from crates using <code>glib</code>, <code>smol</code>, <code>async-std</code> or the <code>futures</code> trait family can be spawned on the main loop. This way, you can often avoid synchronization via channels.</li>
<li>Heavy I/O work might still benefit from running in a separate thread / an async executor to avoid saturating the main loop. If you are unsure, benchmarking is advised.</li>
</ul>
<p>If the best crate for the job relies on <code>tokio</code>, you will have to spawn it with the tokio runtime and communicate via channels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>We have now learned multiple ways to handle states.
However, every time we close the application all of it is gone.
Let's learn how to use <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> by storing the state of a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html"><code>Switch</code></a> in it.</p>
<p>At the very beginning we have to create a <code>GSchema</code> xml file in order to describe the kind of data our application plans to store in the settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/1/org.gtk_rs.Settings1.gschema.xml">listings/settings/1/org.gtk_rs.Settings1.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Settings1" path="/org/gtk_rs/Settings1/"&gt;
    &lt;key name="is-switch-enabled" type="b"&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default switch state&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Let's get through it step by step.
The <code>id</code> is the same application id we used when we created our application.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span>    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();
<span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>The <code>path</code> must start and end with a forward slash character ('/') and must not contain two sequential slash characters.
When creating a <code>path</code>, we advise to take the <code>id</code>, replace the '.' with '/' and add '/' at the front and end of it.</p>
<p>We only want to store a single key with the <code>name</code> "is-switch-enabled".
This is a boolean value so its <code>type</code> is "b" (see <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant Format Strings</a> for the other options).
We also set its default value to <code>false</code> (see <a href="https://docs.gtk.org/glib/gvariant-text-format.html">GVariant Text Format</a> for the full syntax).
Finally, we add a summary.</p>
<p>Now we need to copy and compile the schema.</p>
<blockquote>
<p>You can install the schema by executing the following commands on a Linux or macOS machine:</p>
<pre><code class="language-bash">mkdir -p $HOME/.local/share/glib-2.0/schemas
cp org.gtk_rs.Settings1.gschema.xml $HOME/.local/share/glib-2.0/schemas/
glib-compile-schemas $HOME/.local/share/glib-2.0/schemas/
</code></pre>
<p>On Windows run:</p>
<pre><code class="language-powershell">mkdir C:/ProgramData/glib-2.0/schemas/
cp org.gtk_rs.Settings1.gschema.xml C:/ProgramData/glib-2.0/schemas/
glib-compile-schemas C:/ProgramData/glib-2.0/schemas/
</code></pre>
</blockquote>
<p>We initialize the <code>Settings</code> object by specifying the application id.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Initialize settings
    let settings = Settings::new(APP_ID);
<span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Then we get the settings key and use it when we create our <code>Switch</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span>    // Get the last switch state from the settings
    let is_switch_enabled = settings.boolean("is-switch-enabled");

    // Create a switch
    let switch = Switch::builder()
        .margin_top(48)
        .margin_bottom(48)
        .margin_start(48)
        .margin_end(48)
        .valign(Align::Center)
        .halign(Align::Center)
        .state(is_switch_enabled)
        .build();
<span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Finally, we assure that the switch state is stored in the settings whenever we click on it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    switch.connect_state_set(move |_, is_enabled| {
        // Save changed switch state in the settings
        settings
            .set_boolean("is-switch-enabled", is_enabled)
            .expect("Could not set setting.");
        // Allow to invoke other event handlers
        glib::Propagation::Proceed
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/settings_1.webm" type="video/webm">
  <p>A video which shows that the app can now store the app state</p>
 </video>
</div>
<p>The <code>Switch</code> now retains its state even after closing the application.
But we can make this even better.
The <code>Switch</code> has a property "active" and <code>Settings</code> allows us to bind properties to a specific setting.
So let's do exactly that.</p>
<p>We can remove the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.boolean"><code>boolean</code></a> call before initializing the <code>Switch</code> as well as the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.connect_state_set"><code>connect_state_set</code></a> call.
We then bind the setting to the property by specifying the key, object and name of the property.
Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/settings/2/main.rs">listings/settings/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    settings
        .bind("is-switch-enabled", &amp;switch, "active")
        .build();
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Whenever you have a property which nicely correspond to a setting, you probably want to bind it to it.
In other cases, interacting with the settings via the getter and setter methods tends to be the right choice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-window-state"><a class="header" href="#saving-window-state">Saving Window State</a></h1>
<p>Quite often, we want the window state to persist between sessions.
If the user resizes or maximizes the window, they might expect to find it in the same state the next time they open the app.
GTK does not provide this functionality out of the box, but luckily it is not too hard to manually implement it.
We basically want two integers (<code>height</code> &amp; <code>width</code>) and a boolean (<code>is_maximized</code>) to persist.
We already know how to do this by using <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/saving_window_state/1/org.gtk_rs.SavingWindowState1.gschema.xml">listings/saving_window_state/1/org.gtk_rs.SavingWindowState1.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.SavingWindowState1" path="/org/gtk_rs/SavingWindowState1/"&gt;
    &lt;key name="window-width" type="i"&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window width&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="window-height" type="i"&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window height&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="is-maximized" type="b"&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default window maximized behaviour&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Since we don't care about intermediate state, we only load the window state when the window is constructed and save it when we close the window.
That can be done by creating a custom window.
First, we create one and add convenience methods for accessing settings as well as the window state.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/saving_window_state/1/custom_window/mod.rs">listings/saving_window_state/1/custom_window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }

    pub fn save_window_size(&amp;self) -&gt; Result&lt;(), glib::BoolError&gt; {
        // Get the size of the window
        let size = self.default_size();

        // Set the window state in `settings`
        self.settings().set_int("window-width", size.0)?;
        self.settings().set_int("window-height", size.1)?;
        self.settings()
            .set_boolean("is-maximized", self.is_maximized())?;

        Ok(())
    }

    fn load_window_size(&amp;self) {
        // Get the window state from `settings`
        let width = self.settings().int("window-width");
        let height = self.settings().int("window-height");
        let is_maximized = self.settings().boolean("is-maximized");

        // Set the size of the window
        self.set_default_size(width, height);

        // If the window was maximized when it was closed, maximize it again
        if is_maximized {
            self.maximize();
        }
    }
}</code></pre>
<blockquote>
<p>We set the property "application" by passing it to <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.Object.html#method.new"><code>glib::Object::new</code></a>.
You can even set multiple properties that way.
When creating new GObjects, this is nicer than calling the setter methods manually.</p>
</blockquote>
<p>The implementation struct holds the <code>settings</code>.
You can see that we embed <code>Settings</code> in <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a>.
This is a nice alternative to <code>RefCell&lt;Option&lt;T&gt;&gt;</code> when you know that you will initialize the value only once.</p>
<p>We also override the <code>constructed</code> and <code>close_request</code> methods, where we load or save the window state.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/saving_window_state/1/custom_window/imp.rs">listings/saving_window_state/1/custom_window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, ApplicationWindow};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>#[derive(Default)]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
}

#[glib::object_subclass]
impl ObjectSubclass for Window {
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = ApplicationWindow;
}
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        self.parent_constructed();
        // Load latest window state
        let obj = self.obj();
        obj.setup_settings();
        obj.load_window_size();
    }
}
impl WidgetImpl for Window {}
impl WindowImpl for Window {
    // Save window state right before the window will be closed
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Save window size
        self.obj()
            .save_window_size()
            .expect("Failed to save window state");
        // Allow to invoke other event handlers
        glib::Propagation::Proceed
    }
}
impl ApplicationWindowImpl for Window {}</code></pre>
<p>That is it!
Now our window retains its state between app sessions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-widgets"><a class="header" href="#list-widgets">List Widgets</a></h1>
<p>Sometimes you want to display a list of elements in a certain arrangement.
<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a> and <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FlowBox.html"><code>gtk::FlowBox</code></a> are two container widgets which allow you to do this.
<code>ListBox</code> describes a vertical list and <code>FlowBox</code> describes a grid.</p>
<p>Let's explore this concept by adding labels to a <code>ListBox</code>.
Each label will display an integer starting from 0 and ranging up to 100.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/1/main.rs">listings/list_widgets/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    glib, Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&amp;number.to_string()));
        list_box.append(&amp;label);
    }
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>We cannot display so many widgets at once.
Therefore, we add <code>ListBox</code> to a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ScrolledWindow.html"><code>gtk::ScrolledWindow</code></a>.
Now we can scroll through our elements.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/1/main.rs">listings/list_widgets/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    glib, Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `ListBox` and add labels with integers from 0 to 100
</span><span class="boring">    let list_box = ListBox::new();
</span><span class="boring">    for number in 0..=100 {
</span><span class="boring">        let label = Label::new(Some(&amp;number.to_string()));
</span><span class="boring">        list_box.append(&amp;label);
</span><span class="boring">    }
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_box)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}</span></code></pre>
<div style="text-align:center"><img src="img/lists_list_box.png" alt="Window with a list of integers"/></div>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>That was easy enough.
However, we currently create one widget per element.
Since each widget takes up a bit of resources, many of them can lead to slow and unresponsive user interfaces.
Depending on the widget type even thousands of elements might not be a problem.
But how could we possibly deal with the infinite amount of posts in a social media timeline?</p>
<p>We use scalable lists instead!</p>
<ul>
<li>The <strong>model</strong> holds our data, filters it and describes its order.</li>
<li>The <strong>list item factory</strong> defines how the data transforms into widgets.</li>
<li>The <strong>view</strong> specifies how the widgets are then arranged.</li>
</ul>
<p>What makes this concept scalable is that GTK only has to create slightly more widgets than we can currently look at.
As we scroll through our elements, the widgets which become invisible will be reused.
The following figure demonstrates how this works in practice.</p>
<div style="text-align:center"><img src="img/scalable_lists_concept.png" alt="Diagram showing how list widgets are being recycled"/></div>
<p>100 000 elements is something <code>ListBox</code> will struggle with, so let's use this to demonstrate scalable lists.</p>
<p>We start by defining and filling up our model.
The model is an instance of <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
The main limitation here is that <code>gio::ListStore</code> only accepts GObjects.
So let's create a custom GObject <code>IntegerObject</code> that is initialized with a number.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/integer_object/mod.rs">listings/list_widgets/2/integer_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
}

impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::builder().property("number", number).build()
    }
}
<span class="boring"></span></code></pre>
<p>This number represents the internal state of <code>IntegerObject</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/integer_object/imp.rs">listings/list_widgets/2/integer_object/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::IntegerObject)]
pub struct IntegerObject {
    #[property(get, set)]
    number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for IntegerObject {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppIntegerObject";
</span><span class="boring">    type Type = super::IntegerObject;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for IntegerObject {}
</span><span class="boring"></span></code></pre>
<p>We now fill the model with integers from 0 to 100 000.
Please note that models only takes care of the data.
Neither <code>Label</code> nor any other widget is mentioned here.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();

    // Create new model
    let model = gio::ListStore::new::&lt;IntegerObject&gt;();

    // Add the vector to the model
    model.extend_from_slice(&amp;vector);
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>The <code>ListItemFactory</code> takes care of the widgets as well as their relationship to the model.
Here, we use the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SignalListItemFactory.html"><code>SignalListItemFactory</code></a> which emits a signal for every relevant step in the life of a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListItem.html"><code>ListItem</code></a>.
The "setup" signal will be emitted when new widgets have to be created.
We connect to it to create a <code>Label</code> for every requested widget.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span>    let factory = SignalListItemFactory::new();
    factory.connect_setup(move |_, list_item| {
        let label = Label::new(None);
        list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .set_child(Some(&amp;label));
    });
<span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>In the "bind" step we bind the data in our model to the individual list items.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .item()
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Get `Label` from `ListItem`
        let label = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .child()
            .and_downcast::&lt;Label&gt;()
            .expect("The child has to be a `Label`.");

        // Set "label" to "number"
        label.set_label(&amp;integer_object.number().to_string());
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>We only want single items to be selectable, so we choose <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SingleSelection.html"><code>SingleSelection</code></a>.
The other options would have been <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MultiSelection.html"><code>MultiSelection</code></a> or <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.NoSelection.html"><code>NoSelection</code></a>.
Then we pass the model and the factory to the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>ListView</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span>    let selection_model = SingleSelection::new(Some(model));
    let list_view = ListView::new(Some(selection_model), Some(factory));
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Every <code>ListView</code> has to be a direct child of a <code>ScrolledWindow</code>, so we are adding it to one.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_view)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}</span></code></pre>
<p>We can now easily scroll through our long list of integers.</p>
<div style="text-align:center"><img src="img/lists_list_view_1.png" alt="Window with a list of 100 000 integers"/></div>
<p>Let's see what else we can do.
We might want to increase the number every time we activate its row.
For that we first add the method <code>increase_number</code> to our <code>IntegerObject</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/3/integer_object/mod.rs">listings/list_widgets/3/integer_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::builder().property("number", number).build()
    }

    pub fn increase_number(self) {
        self.set_number(self.number() + 1);
    }
}</code></pre>
<p>In order to interact with our <code>ListView</code>, we connect to its "activate" signal.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/3/main.rs">listings/list_widgets/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Bind "label" to "number"
</span><span class="boring">        integer_object
</span><span class="boring">            .bind_property("number", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect("The model has to exist.");
        let integer_object = model
            .item(position)
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Increase "number" of `IntegerObject`
        integer_object.increase_number();
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now every time we activate an element, for example by double-clicking on it,
the corresponding "number" property of the <code>IntegerObject</code> in the model will be increased by 1.
However, just because the <code>IntegerObject</code> has been modified the corresponding <code>Label</code> does not immediately change.
One naive approach would be to bind the properties in the "bind" step of the <code>SignalListItemFactory</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/3/main.rs">listings/list_widgets/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .item()
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Get `Label` from `ListItem`
        let label = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .child()
            .and_downcast::&lt;Label&gt;()
            .expect("The child has to be a `Label`.");

        // Bind "label" to "number"
        integer_object
            .bind_property("number", &amp;label, "label")
            .sync_create()
            .build();
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>At first glance, that seems to work.
However, as you scroll around and activate a few list elements,
you will notice that sometimes multiple numbers change even though you only activated a single one.
This relates to how the view works internally.
Not every model item belongs to a single widget, but the widgets get recycled instead as you scroll through the view.
That also means that in our case, multiple numbers will be bound to the same widget.</p>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>Situations like these are so common that GTK offers an alternative to property binding: <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Expression.html">expressions</a>.
As a first step it allows us to remove the "bind" step.
Let's see how the "setup" step now works.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/4/main.rs">listings/list_widgets/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        let list_item = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem");
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
        list_item
            .property_expression("item")
            .chain_property::&lt;IntegerObject&gt;("number")
            .bind(&amp;label, "label", Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>An expression provides a way to describe references to values.
One interesting part here is that these references can be several steps away.
This allowed us in the snippet above to bind the property "number" of the property "item" of <code>list_item</code> to the property "label" of <code>label</code>.</p>
<p>It is also worth noting that at the "setup" stage there is no way of knowing which list item belongs to which label, simply because this changes as we scroll through the list.
Here, another power of expressions becomes evident.
Expressions allow us to describe relationships between objects or properties that might not even exist yet.
We just had to tell it to change the label whenever the number that belongs to it changes.
That way, we also don't face the problem that multiple labels are bound to the same number.
When we now activate a label, only the corresponding number visibly changes.</p>
<p>Let's extend our app a bit more.
We can, for example, filter our model to only allow even numbers.
We do that by passing it to a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FilterListModel.html"><code>gtk::FilterListModel</code></a> together with a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CustomFilter.html"><code>gtk::CustomFilter</code></a></p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span>    let filter = CustomFilter::new(move |obj| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object = obj
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");

        // Only allow even numbers
        integer_object.number() % 2 == 0
    });
    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
<span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get property "number" from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.number();
</span><span class="boring">        let number_2 = integer_object_2.number();
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Additionally, we can reverse the order of our model.
Now we pass the filtered model to <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SortListModel.html"><code>gtk::SortListModel</code></a> together with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CustomSorter.html"><code>gtk::CustomSorter</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        integer_object.number() % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
</span><span class="boring">
</span>    let sorter = CustomSorter::new(move |obj1, obj2| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object_1 = obj1
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");
        let integer_object_2 = obj2
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");

        // Get property "number" from `IntegerObject`
        let number_1 = integer_object_1.number();
        let number_2 = integer_object_2.number();

        // Reverse sorting order -&gt; large numbers come first
        number_2.cmp(&amp;number_1).into()
    });
    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>To ensure that our filter and sorter get updated when we modify the numbers, we call the <code>changed</code> method on them.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        integer_object.number() % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
</span><span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get property "number" from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.number();
</span><span class="boring">        let number_2 = integer_object_2.number();
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect("The model has to exist.");
        let integer_object = model
            .item(position)
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Increase "number" of `IntegerObject`
        integer_object.increase_number();

        // Notify that the filter and sorter have been changed
        filter.changed(FilterChange::Different);
        sorter.changed(SorterChange::Different);
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>After our changes, the application looks like this:</p>
<div style="text-align:center"><img src="img/lists_list_view_2.png" alt="Window with a list of 100 000 integers, starting from 100 000"/></div>
<h3 id="string-list"><a class="header" href="#string-list">String List</a></h3>
<p>Often, all you want is to display a list of strings.
However, if you either need to filter and sort your displayed data or have too many elements to be displayed by <code>ListBox</code>, you will still want to use a view.
GTK provides a convenient model for this use case: <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringList.html"><code>gtk::StringList</code></a>.</p>
<p>Let's see with a small example how to use this API.
Filter and sorter is controlled by the factory, so nothing changes here.
This is why we will skip this topic here.</p>
<p>First, we add a bunch of strings to our model.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/6/main.rs">listings/list_widgets/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::{glib, prelude::*, ListItem};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `StringList` with number from 0 to 100_000
    // `StringList` implements FromIterator&lt;String&gt;
    let model: StringList = (0..=100_000).map(|number| number.to_string()).collect();
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;StringObject&gt;("string")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Note that we can create a <code>StringList</code> directly from an iterator over strings.
This means we don't have to create a custom GObject for our model anymore.</p>
<p>As usual, we connect the label to the list item via an expression.
Here we can use <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringObject.html"><code>StringObject</code></a>, which exposes its content via the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringObject.html#string">property "string"</a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/list_widgets/6/main.rs">listings/list_widgets/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::{glib, prelude::*, ListItem};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `StringList` with number from 0 to 100_000
</span><span class="boring">    // `StringList` implements FromIterator&lt;String&gt;
</span><span class="boring">    let model: StringList = (0..=100_000).map(|number| number.to_string()).collect();
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        let list_item = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem");
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
        list_item
            .property_expression("item")
            .chain_property::&lt;StringObject&gt;("string")
            .bind(&amp;label, "label", Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>We now know how to display a list of data.
Small amount of elements can be handled by <code>ListBox</code> or <code>FlowBox</code>.
These widgets are easy to use and can, if necessary, be bound to a model such as <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
Their data can then be modified, sorted and filtered more easily.
However, if we need the widgets to be scalable, we still need to use <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>ListView</code></a>, <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ColumnView.html"><code>ColumnView</code></a> or <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.GridView.html"><code>GridView</code></a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composite-templates"><a class="header" href="#composite-templates">Composite Templates</a></h1>
<p>Until now, whenever we constructed pre-defined widgets we relied on the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>.
As a reminder, that is how we used it to build our trusty "Hello World!" app.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow, Button};
const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/hello_world_button.webm" type="video/webm">
  <p>A video which shows that pressing on a button changes its label</p>
 </video>
</div>
<p>Creating widgets directly from code is fine, but it makes it harder to separate the logic from the user interface.
This is why most toolkits allow to describe the user interface with a markup language and GTK is no exception here.
For example the following <code>xml</code> file describes the window widget of the "Hello World!" app.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/resources/window.ui">listings/composite_templates/1/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkButton" id="button"&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>The most outer tag always has to be the <code>&lt;interface&gt;</code>.
Then you start listing the elements you want to describe.
In order to define a composite template, we specify the name <code>MyGtkAppWindow</code> of the custom widget we want to create and the parent <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> it derives of.
These <code>xml</code> files are independent of the programming language, which is why the classes have the original names.
Luckily, they all convert like this: <code>gtk::ApplicationWindow</code> → <code>GtkApplicationWindow</code>.
Then we can specify properties which are listed <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html#properties">here</a> for <code>ApplicationWindow</code>.
Since <code>ApplicationWindow</code> can contain other widgets we use the <code>&lt;child&gt;</code> tag to add a <code>gtk::Button</code>.
We want to be able to refer to the button later on so we also set its <code>id</code>.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>In order to embed the template file into our application we take advantage of <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a>.
The files to embed are again described by an <code>xml</code> file.
For our template file we also add the <code>compressed</code> and <code>preprocess</code> attribute in order to reduce the final size of the resources.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/resources/resources.gresource.xml">listings/composite_templates/1/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/example/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<p>Now we have to compile the resources and link it to our application.
One way to do this is to execute <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib_build_tools/fn.compile_resources.html"><code>glib_build_tools::compile_resources</code></a> within a cargo <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>.</p>
<p>First, we have to add <code>glib-build-tools</code> as build dependency in <code>Cargo.toml</code> by executing:</p>
<pre><code>cargo add glib-build-tools --build
</code></pre>
<p>Then, we create a <code>build.rs</code> at the root of our package with the following content.
This will compile the resources whenever we trigger a build with cargo and then statically link our executable to them.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/build.rs">listings/build.rs</a></p>
<pre><code class="language-rust">fn main() {
    glib_build_tools::compile_resources(
        &amp;["composite_templates/1/resources"],
        "composite_templates/1/resources/resources.gresource.xml",
        "composite_templates_1.gresource",
    );
}</code></pre>
<p>Finally, we register and include the resources by calling the macro <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/macro.resources_register_include.html"><code>gio::resources_register_include!</code></a>.
In your own apps take care to register the resources before creating the <code>gtk::Application</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/main.rs">listings/composite_templates/1/main.rs</a></p>
<pre><code class="language-rust">mod window;

use gtk::prelude::*;
use gtk::{gio, glib, Application};
use window::Window;

const APP_ID: &amp;str = "org.gtk_rs.CompositeTemplates1";

fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("composite_templates_1.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}
fn build_ui(app: &amp;Application) {
    // Create new window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Within our code we create a custom widget inheriting from <code>gtk::ApplicationWindow</code> to make use of our template.
Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/window/mod.rs">listings/composite_templates/1/window/mod.rs</a></p>
<pre><code class="language-rust">mod imp;

use glib::Object;
use gtk::{gio, glib, Application};

glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }
}</code></pre>
<p>In the implementation struct, we then add the derive macro <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4_macros/derive.CompositeTemplate.html"><code>gtk::CompositeTemplate</code></a>.
We also specify that the template information comes from a resource of prefix <code>/org/gtk-rs/example</code> containing a file <code>window.ui</code>.</p>
<p>One very convenient feature of templates is the template child.
You use it by adding a struct member with the same name as one <code>id</code> attribute in the template.
<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/struct.TemplateChild.html"><code>TemplateChild</code></a> then stores a reference to the widget for later use.
This will be useful later, when we want to add a callback to our button.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Within the <code>ObjectSubclass</code> trait, we make sure that <code>NAME</code> corresponds to <code>class</code> in the template and <code>ParentType</code> corresponds to <code>parent</code> in the template.
We also bind and initialize the template in <code>class_init</code> and <code>instance_init</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Finally, we connect the callback to the "clicked" signal of <code>button</code> within <code>constructed</code>.
The button is easily available thanks to the stored reference in <code>self</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Connect to "clicked" signal of `button`
        self.button.connect_clicked(move |button| {
            // Set the label to "Hello World!" after the button has been clicked on
            button.set_label("Hello World!");
        });
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<h2 id="custom-widgets"><a class="header" href="#custom-widgets">Custom Widgets</a></h2>
<p>We can also instantiate custom widgets within a template file.
First we define <code>CustomButton</code> that inherits from <code>gtk::Button</code>.
As usual, we define the implementation struct within <code>imp.rs</code>.
Note the <code>NAME</code> we define here, we will need it later to refer to it in the template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/2/custom_button/imp.rs">listings/composite_templates/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {}</span></code></pre>
<p>We also define the public struct in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/2/custom_button/mod.rs">listings/composite_templates/2/custom_button/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>mod imp;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable,
                    gtk::Buildable, gtk::ConstraintTarget;
}
<span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CustomButton {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since we want to refer to a <code>CustomButton</code> now we also have to change the type of the template child to it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/2/window/imp.rs">listings/composite_templates/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Finally, we can replace <code>GtkButton</code> with <code>MyGtkAppCustomButton</code> within our composite template.
Since the custom button is a direct subclass of <code>gtk::Button</code> without any modifications, the behavior of our app stays the same.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/2/resources/window.ui">listings/composite_templates/2/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="template-callbacks"><a class="header" href="#template-callbacks">Template Callbacks</a></h2>
<p>We can even specify the handlers of signals within composite templates.
This can be done with a <code>&lt;signal&gt;</code> tag containing the name of the signal and the handler in our Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/3/resources/window.ui">listings/composite_templates/3/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;signal name="clicked" handler="handle_button_clicked"/&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>Then we define the <code>handle_button_clicked</code> with the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4_macros/attr.template_callbacks.html"><code>template_callbacks</code></a> macro applied to it.
We can determine the function signature by having a look at the <code>connect_*</code> method of the signal we want to handle.
In our case that would be <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.
It takes a function of type <code>Fn(&amp;Self)</code>.
<code>Self</code> refers to our button.
This means that <code>handle_button_clicked</code> has a single parameter of type <code>&amp;CustomButton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/3/window/imp.rs">listings/composite_templates/3/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[gtk::template_callbacks]
impl Window {
    #[template_callback]
    fn handle_button_clicked(button: &amp;CustomButton) {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Then we have to bind the template callbacks with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.CompositeTemplateCallbacksClass.html#tymethod.bind_template_callbacks"><code>bind_template_callbacks</code></a>.
We also need to remove the <code>button.connect_clicked</code> callback implemented in <code>window/imp.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/3/window/imp.rs">listings/composite_templates/3/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
        klass.bind_template_callbacks();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(button: &amp;CustomButton) {
</span><span class="boring">        // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">        button.set_label("Hello World!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We can also access the state of our widget.
Let's say we want to manipulate a <code>number</code> stored in <code>imp::Window</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/4/window/imp.rs">listings/composite_templates/4/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
    pub number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>In order to access the widget's state we have to add <code>swapped="true"</code> to the <code>signal</code> tag.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/4/resources/window.ui">listings/composite_templates/4/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;signal name="clicked" handler="handle_button_clicked" swapped="true"/&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>Now we can add <code>&amp;self</code> as first parameter to <code>handle_button_clicked</code>.
This lets us access the state of the window and therefore manipulate <code>number</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/4/window/imp.rs">listings/composite_templates/4/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">    pub number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[gtk::template_callbacks]
impl Window {
    #[template_callback]
    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
        let number_increased = self.number.get() + 1;
        self.number.set(number_increased);
        button.set_label(&amp;number_increased.to_string())
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<h2 id="registering-types"><a class="header" href="#registering-types">Registering Types</a></h2>
<p>Now that we use template callbacks we don't access the template child anymore.
Let's remove it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/5/window/imp.rs">listings/composite_templates/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    pub number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>However, when we now run it GTK doesn't see <code>MyGtkAppCustomButton</code> as valid object type anymore.
So what happened here?</p>
<pre><code>Gtk-CRITICAL **: Error building template class 'MyGtkAppWindow' for an instance of
                 type 'MyGtkAppWindow': Invalid object type 'MyGtkAppCustomButton'
</code></pre>
<p>Turns out adding a template child not only gives a convenient reference to a widget within the template.
It also ensures that the widget type is registered.
Luckily we can also do that by ourselves.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/composite_templates/6/window/imp.rs">listings/composite_templates/6/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        // Register `CustomButton`
        CustomButton::ensure_type();

        klass.bind_template();
        klass.bind_template_callbacks();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We call the <code>ensure_type</code> method within <code>class_init</code> and voilà: our app works again.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Thanks to custom widgets we can</p>
<ul>
<li>keep state and part of it as properties,</li>
<li>add signals as well as</li>
<li>override behavior.</li>
</ul>
<p>Thanks to composite templates we can</p>
<ul>
<li>describe complex user interfaces concisely,</li>
<li>easily access widgets within the template as well as</li>
<li>specify handler functions for signals.</li>
</ul>
<p>The API involved here is extensive so especially at the beginning you will want to check out the documentation.
The basic syntax of the <code>ui</code> files is explained within <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Builder.html#gtkbuilder-ui-definitions"><code>Builder</code></a>, syntax specific to widgets within <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>Widget</code></a>.
If a certain widget accepts additional element, then they are typically explained in the docs of the widget.</p>
<p>In the following chapter, we will see how composite templates help us to create slightly bigger apps such as a To-Do app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-simple-to-do-app"><a class="header" href="#building-a-simple-to-do-app">Building a Simple To-Do App</a></h1>
<p>After we have learned so many concepts, it is finally time to put them into practice.
We are going to build a To-Do app!</p>
<p>For now, we would already be satisfied with a minimal version.
An entry to input new tasks and a list view to display them will suffice.
Something like this:</p>
<div style="text-align:center"><img src="img/todo_1_mockup.png" alt="To-Do App with a couple of tasks, some of them crossed-off"/></div>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>This mockup can be described by the following composite template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/resources/window.ui">listings/todo/1/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="TodoWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkEntry" id="entry"&gt;
            &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
            &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkScrolledWindow"&gt;
            &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
            &lt;property name="min-content-height"&gt;360&lt;/property&gt;
            &lt;property name="vexpand"&gt;true&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkListView" id="tasks_list"&gt;
                &lt;property name="valign"&gt;start&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to use the composite template, we create a custom widget.
The <code>parent</code> is <code>gtk::ApplicationWindow</code>, so we inherit from it.
As usual, we have to list all <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#ancestors">ancestors</a> and <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#implements">interfaces</a> apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Then we initialize the composite template for <code>imp::Window</code>.
We store references to the entry, the list view as well as the list model.
This will come in handy when we later add methods to our window.
After that, we add the typical boilerplate for initializing composite templates.
We only have to assure that the <code>class</code> attribute of the template in <code>window.ui</code> matches <code>NAME</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/imp.rs">listings/todo/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo1/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListView&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p><code>main.rs</code> also does not hold any surprises for us.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/main.rs">listings/todo/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("todo_1.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder()
        .application_id("org.gtk_rs.Todo1")
        .build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a new custom window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Finally, we specify our resources.
Here, they already include <code>task_row.ui</code> which we will handle later in this chapter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/resources/resources.gresource.xml">listings/todo/1/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/Todo1/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<h2 id="task-object"><a class="header" href="#task-object">Task Object</a></h2>
<p>So far so good.
The main user interface is done, but the entry does not react to input yet.
Also, where would the input go?
We haven't even set up the list model yet.
Let's do that!</p>
<div style="text-align:center"><img src="img/todo_1_empty.png" alt="To-Do app without any content"/></div>
<p>As discussed in the <a href="./list_widgets.html">list widgets chapter</a>,
we start out by creating a custom GObject.
This object will store the state of the task consisting of:</p>
<ul>
<li>a boolean describing whether the task is completed or not, and</li>
<li>a string holding the task name.</li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_object/mod.rs">listings/todo/1/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
}

impl TaskObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::builder()
            .property("completed", completed)
            .property("content", content)
            .build()
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TaskData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>Unlike the lists chapter, the state is stored in a struct rather than in individual members of <code>imp::TaskObject</code>.
This will be very convenient when saving the state in one of the following chapters.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_object/mod.rs">listings/todo/1/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("completed", completed)
</span><span class="boring">            .property("content", content)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct TaskData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>We are going to expose <code>completed</code> and <code>content</code> as properties.
Since the data is now inside a struct rather than individual member variables we have to add more annotations.
For each property we additionally specify the name, the type and which member variable of <code>TaskData</code> we want to access.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_object/imp.rs">listings/todo/1/task_object/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use super::TaskData;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::TaskObject)]
pub struct TaskObject {
    #[property(name = "completed", get, set, type = bool, member = completed)]
    #[property(name = "content", get, set, type = String, member = content)]
    pub data: RefCell&lt;TaskData&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskObject {
    const NAME: &amp;'static str = "TodoTaskObject";
    type Type = super::TaskObject;
}

// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for TaskObject {}</code></pre>
<h2 id="task-row"><a class="header" href="#task-row">Task Row</a></h2>
<p>Let's move on to the individual tasks.
The row of a task should look like this:</p>
<div style="text-align:center"><img src="img/task_row.png" alt="A single task widget"/></div>
<p>Again, we describe the mockup with a composite template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/resources/task_row.ui">listings/todo/1/resources/task_row.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="TodoTaskRow" parent="GtkBox"&gt;
    &lt;child&gt;
      &lt;object class="GtkCheckButton" id="completed_button"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkLabel" id="content_label"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In the code, we <a href="https://docs.gtk.org/gtk4/class.Box.html#hierarchy">derive</a> <code>TaskRow</code> from <code>gtk:Box</code>:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
    @extends gtk::Box, gtk::Widget,
    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
}
<span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let completed_button = self.imp().completed_button.get();
</span><span class="boring">        let content_label = self.imp().content_label.get();
</span><span class="boring">        let mut bindings = self.imp().bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;completed_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.content` to `task_row.content_label.label`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("content", &amp;content_label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;content_label, "attributes")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .transform_to(|_, active| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                if active {
</span><span class="boring">                    // If "active" is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in self.imp().bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>imp::TaskRow</code>, we hold references to <code>completed_button</code> and <code>content_label</code>.
We also store a mutable vector of bindings.
Why we need that will become clear as soon as we get to bind the state of <code>TaskObject</code> to the corresponding <code>TaskRow</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_row/imp.rs">listings/todo/1/task_row/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">
</span>// Object holding the state
#[derive(Default, CompositeTemplate)]
#[template(resource = "/org/gtk_rs/Todo1/task_row.ui")]
pub struct TaskRow {
    #[template_child]
    pub completed_button: TemplateChild&lt;CheckButton&gt;,
    #[template_child]
    pub content_label: TemplateChild&lt;Label&gt;,
    // Vector holding the bindings to properties of `TaskObject`
    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoTaskRow";
    type Type = super::TaskRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TaskRow {}</span></code></pre>
<p>Now we can bring everything together.
We override the <code>imp::Window::constructed</code> in order to set up window contents at the time of its construction.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/imp.rs">listings/todo/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo1/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_tasks();
        obj.setup_callbacks();
        obj.setup_factory();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Since we need to access the list model quite often, we add the convenience method <code>Window::tasks</code> for that.
In <code>Window::setup_tasks</code> we create a new model.
Then we store a reference to the model in <code>imp::Window</code> as well as in <code>gtk::ListView</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        // Get state
        self.imp()
            .tasks
            .borrow()
            .clone()
            .expect("Could not get current tasks.")
    }

    fn setup_tasks(&amp;self) {
        // Create new model
        let model = gio::ListStore::new::&lt;TaskObject&gt;();

        // Get state and set model
        self.imp().tasks.replace(Some(model));

        // Wrap model with selection and pass it to the list view
        let selection_model = NoSelection::new(Some(self.tasks()));
        self.imp().tasks_list.set_model(Some(&amp;selection_model));
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also create a method <code>new_task</code> which takes the content of the entry, clears the entry and uses the content to create a new task.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn new_task(&amp;self) {
        // Get content from entry and clear it
        let buffer = self.imp().entry.buffer();
        let content = buffer.text().to_string();
        if content.is_empty() {
            return;
        }
        buffer.set_text("");

        // Add new task to model
        let task = TaskObject::new(false, content);
        self.tasks().append(&amp;task);
    }
<span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>Window::setup_callbacks</code> we connect to the "activate" signal of the entry.
This signal is triggered when we press the enter key in the entry.
Then a new <code>TaskObject</code> with the content will be created and appended to the model.
Finally, the entry will be cleared.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_callbacks(&amp;self) {
        // Setup callback for activation of the entry
        self.imp().entry.connect_activate(clone!(
            #[weak(rename_to = window)]
            self,
            move |_| {
                window.new_task();
            }
        ));

        // Setup callback for clicking (and the releasing) the icon of the entry
        self.imp().entry.connect_icon_release(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _| {
                window.new_task();
            }
        ));
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The list elements for the <code>gtk::ListView</code> are produced by a factory.
Before we move on to the implementation, let's take a step back and think about which behavior we expect here.
<code>content_label</code> of <code>TaskRow</code> should follow <code>content</code> of <code>TaskObject</code>.
We also want <code>completed_button</code> of <code>TaskRow</code> follow <code>completed</code> of <code>TaskObject</code>.
This could be achieved with expressions similar to what we did in the lists chapter.</p>
<p>However, if we toggle the state of <code>completed_button</code> of <code>TaskRow</code>, <code>completed</code> of <code>TaskObject</code> should change too.
Unfortunately, expressions cannot handle bidirectional relationships.
This means we have to use property bindings.
We will need to unbind them manually when they are no longer needed.</p>
<p>We will create empty <code>TaskRow</code> objects in the "setup" step in <code>Window::setup_factory</code> and deal with binding in the "bind" and "unbind" steps.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_factory(&amp;self) {
        // Create a new factory
        let factory = SignalListItemFactory::new();

        // Create an empty `TaskRow` during setup
        factory.connect_setup(move |_, list_item| {
            // Create `TaskRow`
            let task_row = TaskRow::new();
            list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .set_child(Some(&amp;task_row));
        });

        // Tell factory how to bind `TaskRow` to a `TaskObject`
        factory.connect_bind(move |_, list_item| {
            // Get `TaskObject` from `ListItem`
            let task_object = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .item()
                .and_downcast::&lt;TaskObject&gt;()
                .expect("The item has to be an `TaskObject`.");

            // Get `TaskRow` from `ListItem`
            let task_row = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .child()
                .and_downcast::&lt;TaskRow&gt;()
                .expect("The child has to be a `TaskRow`.");

            task_row.bind(&amp;task_object);
        });

        // Tell factory how to unbind `TaskRow` from `TaskObject`
        factory.connect_unbind(move |_, list_item| {
            // Get `TaskRow` from `ListItem`
            let task_row = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .child()
                .and_downcast::&lt;TaskRow&gt;()
                .expect("The child has to be a `TaskRow`.");

            task_row.unbind();
        });

        // Set the factory of the list view
        self.imp().tasks_list.set_factory(Some(&amp;factory));
    }
<span class="boring">}</span></code></pre>
<p>Binding properties in <code>TaskRow::bind</code> works just like in former chapters.
The only difference is that we store the bindings in a vector.
This is necessary because a <code>TaskRow</code> will be reused as you scroll through the list.
That means that over time a <code>TaskRow</code> will need to bound to a new <code>TaskObject</code> and has to be unbound from the old one.
Unbinding will only work if it can access the stored <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.Binding.html"><code>glib::Binding</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
        // Get state
        let completed_button = self.imp().completed_button.get();
        let content_label = self.imp().content_label.get();
        let mut bindings = self.imp().bindings.borrow_mut();

        // Bind `task_object.completed` to `task_row.completed_button.active`
        let completed_button_binding = task_object
            .bind_property("completed", &amp;completed_button, "active")
            .bidirectional()
            .sync_create()
            .build();
        // Save binding
        bindings.push(completed_button_binding);

        // Bind `task_object.content` to `task_row.content_label.label`
        let content_label_binding = task_object
            .bind_property("content", &amp;content_label, "label")
            .sync_create()
            .build();
        // Save binding
        bindings.push(content_label_binding);

        // Bind `task_object.completed` to `task_row.content_label.attributes`
        let content_label_binding = task_object
            .bind_property("completed", &amp;content_label, "attributes")
            .sync_create()
            .transform_to(|_, active| {
                let attribute_list = AttrList::new();
                if active {
                    // If "active" is true, content of the label will be strikethrough
                    let attribute = AttrInt::new_strikethrough(true);
                    attribute_list.insert(attribute);
                }
                Some(attribute_list.to_value())
            })
            .build();
        // Save binding
        bindings.push(content_label_binding);
    }
<span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in self.imp().bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>TaskRow::unbind</code> takes care of the cleanup.
It iterates through the vector and unbinds each binding.
In the end, it clears the vector.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let completed_button = self.imp().completed_button.get();
</span><span class="boring">        let content_label = self.imp().content_label.get();
</span><span class="boring">        let mut bindings = self.imp().bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;completed_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.content` to `task_row.content_label.label`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("content", &amp;content_label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;content_label, "attributes")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .transform_to(|_, active| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                if active {
</span><span class="boring">                    // If "active" is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn unbind(&amp;self) {
        // Unbind all stored bindings
        for binding in self.imp().bindings.borrow_mut().drain(..) {
            binding.unbind();
        }
    }
<span class="boring">}</span></code></pre>
<p>That was it, we created a basic To-Do app!
We will extend it with additional functionality in the following chapters.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_1_animation.webm" type="video/webm">
  <p>A video which shows how to enter tasks to the To-Do app</p>
 </video>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>By now, we've already learned many ways to glue our widgets together.
We can send messages through channels, emit signals, share reference-counted state and bind properties.
Now, we will complete our set by learning about actions.</p>
<p>An action is a piece of functionality bound to a certain GObject.
Let's check out the simplest case where we activate an action without a parameter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger "win.close".
</span><span class="boring">    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(|window: &amp;ApplicationWindow, _, _| {
            window.close();
        })
        .build();
    window.add_action_entries([action_close]);

    // Present window
    window.present();
}</code></pre>
<p>First, we created a new <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ActionEntry.html"><code>gio::ActionEntry</code></a> which is named "close" and takes no parameter.
We also connected a callback which closes the window when the action is activated.
Finally, we add the action entry to the window via <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.ActionMapExtManual.html#method.add_action_entries"><code>add_action_entries</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Actions1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Set keyboard accelerator to trigger "win.close".
    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);

    // Run the application
    app.run()
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(|window: &amp;ApplicationWindow, _, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_close]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>One of the most popular reasons to use actions are keyboard accelerators, so we added one here.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.GtkApplicationExt.html#tymethod.set_accels_for_action"><code>set_accels_for_action</code></a> one can assign one or more accelerators to a certain action.
Check the documentation of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/functions/fn.accelerator_parse.html"><code>accelerator_parse</code></a> in order to learn more about its syntax.</p>
<p>Before we move on to other aspects of actions, let's appreciate a few things that are curious here.
The "win" part of "win.close" is the group of the action.
But how does GTK know that "win" is the action group of our window?
The answer is that it is so common to add actions to windows and applications that there are already two predefined groups available:</p>
<ul>
<li>"app" for actions global to the application, and</li>
<li>"win" for actions tied to an application window.</li>
</ul>
<p>We can add an action group to any widget via the method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#method.insert_action_group"><code>insert_action_group</code></a>.
Let's add our action to the action group "custom-group" and add the group then to our window.
The action entry isn't specific to our window anymore, the first parameter of the "activate" callback is of type <code>SimpleActionGroup</code> instead of <code>ApplicationWindow</code>.
This means we have to clone <code>window</code> into the closure.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">    // Set keyboard accelerator to trigger "custom-group.close".
</span><span class="boring">    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(clone!(
            #[weak]
            window,
            move |_, _, _| {
                window.close();
            }
        ))
        .build();

    // Create a new action group and add actions to it
    let actions = SimpleActionGroup::new();
    actions.add_action_entries([action_close]);
    window.insert_action_group("custom-group", Some(&amp;actions));

    // Present window
    window.present();
}</code></pre>
<p>If we bind the accelerator to "custom-group.close", it works just as before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span>    // Set keyboard accelerator to trigger "custom-group.close".
    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
<span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            window,
</span><span class="boring">            move |_, _, _| {
</span><span class="boring">                window.close();
</span><span class="boring">            }
</span><span class="boring">        ))
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a new action group and add actions to it
</span><span class="boring">    let actions = SimpleActionGroup::new();
</span><span class="boring">    actions.add_action_entries([action_close]);
</span><span class="boring">    window.insert_action_group("custom-group", Some(&amp;actions));
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Also, if we had multiple instances of the same windows, we would expect that only the currently focused window will be closed when activating "win.close".
And indeed, the "win.close" will be dispatched to the currently focused window.
However, that also means that we actually define one action per window instance.
If we want to have a single globally accessible action instead, we call <code>add_action_entries</code> on our application instead.</p>
<blockquote>
<p>Adding "win.close" was useful as a simple example.
However, in the future we will use the pre-defined <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Window.html#actions">"window.close"</a> action which does exactly the same thing.</p>
</blockquote>
<h2 id="parameter-and-state"><a class="header" href="#parameter-and-state">Parameter and State</a></h2>
<p>An action, like most functions, can take a parameter.
However, unlike most functions it can also be stateful.
Let's see how this works.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/3/main.rs">listings/actions/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    let original_state = 0;
    let label = Label::builder()
        .label(format!("Counter: {original_state}"))
        .build();

    // Create a button with label
    let button = Button::builder().label("Press me!").build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Activate "win.count" and pass "1" as parameter
        let parameter = 1;
        button
            .activate_action("win.count", Some(&amp;parameter.to_variant()))
            .expect("The action does not exist.");
    });

    // Create a `gtk::Box` and add `button` and `label` to it
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .spacing(12)
        .halign(Align::Center)
        .build();
    gtk_box.append(&amp;button);
    gtk_box.append(&amp;label);

    // Create a window, set the title and add `gtk_box` to it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .child(&amp;gtk_box)
        .build();

    // Add action "count" to `window` taking an integer as parameter
    let action_count = ActionEntry::builder("count")
        .parameter_type(Some(&amp;i32::static_variant_type()))
        .state(original_state.to_variant())
        .activate(move |_, action, parameter| {
            // Get state
            let mut state = action
                .state()
                .expect("Could not get state.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Get parameter
            let parameter = parameter
                .expect("Could not get parameter.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Increase state by parameter and store state
            state += parameter;
            action.set_state(&amp;state.to_variant());

            // Update label with new state
            label.set_label(&amp;format!("Counter: {state}"));
        })
        .build();
    window.add_action_entries([action_count]);

    // Present window
    window.present();
}</code></pre>
<p>Here, we created a "win.count" action that increases its state by the given parameter every time it is activated.
It also takes care of updating the <code>label</code> with the current state.
The button activates the action with each click while passing "1" as parameter.
This is how our app works:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_counter.webm" type="video/webm">
  <p>A video which shows that pressing on one button also changes the label below</p>
 </video>
</div>
<h2 id="actionable"><a class="header" href="#actionable">Actionable</a></h2>
<p>Connecting actions to the "clicked" signal of buttons is a typical use case, which is why all buttons implement the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Actionable.html"><code>Actionable</code></a> interface.
This way, the action can be specified by setting the "action-name" property.
If the action accepts a parameter, it can be set via the "action-target" property.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/builders/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a>, we can set everything up by calling its methods.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/4/main.rs">listings/actions/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    let original_state = 0;
</span><span class="boring">    let label = Label::builder()
</span><span class="boring">        .label(format!("Counter: {original_state}"))
</span><span class="boring">        .build();
</span>    // Create a button with label and action
    let button = Button::builder()
        .label("Press me!")
        .action_name("win.count")
        .action_target(&amp;1.to_variant())
        .build();
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add `button` and `label` to it
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button);
</span><span class="boring">    gtk_box.append(&amp;label);
</span><span class="boring">
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "count" to `window` taking an integer as parameter
</span><span class="boring">    let action_count = ActionEntry::builder("count")
</span><span class="boring">        .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">        .state(original_state.to_variant())
</span><span class="boring">        .activate(move |_, action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect("Could not get state.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect("Could not get parameter.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and store state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Actionable widgets are also easily accessible through the interface builder.
As usual, we build up the window via a composite template.
Within the template we can then set the "action-name" and "action-target" properties.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/resources/window.ui">listings/actions/5/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="gtk_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;12&lt;/property&gt;
        &lt;property name="halign"&gt;center&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton" id="button"&gt;
            &lt;property name="label"&gt;Press me!&lt;/property&gt;
            &lt;property name="action-name"&gt;win.count&lt;/property&gt;
            &lt;property name="action-target"&gt;1&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="label"&gt;
            &lt;property name="label"&gt;Counter: 0&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>We will connect the actions and add them to the window in the <code>Window::setup_actions</code> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/window/mod.rs">listings/actions/5/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span>impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_actions(&amp;self) {
        // Add stateful action "count" to `window` taking an integer as parameter
        let original_state = 0;
        let action_count = ActionEntry::builder("count")
            .parameter_type(Some(&amp;i32::static_variant_type()))
            .state(original_state.to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get state
                let mut state = action
                    .state()
                    .expect("Could not get state.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Increase state by parameter and store state
                state += parameter;
                action.set_state(&amp;state.to_variant());

                // Update label with new state
                window.imp().label.set_label(&amp;format!("Counter: {state}"));
            })
            .build();
        self.add_action_entries([action_count]);
    }
}</code></pre>
<p>Finally, <code>setup_actions</code> will be called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/5/window/imp.rs">listings/actions/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Add actions
        self.obj().setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>This app behaves the same as our previous example, but it will make it simpler for us to add a menu in the following section.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>If you want to create a <a href="https://developer.gnome.org/hig/patterns/controls/menus.html">menu</a>, you have to use actions, and you will want to use the interface builder.
Typically, a menu entry has an action fitting one of these three descriptions:</p>
<ul>
<li>no parameter and no state, or</li>
<li>no parameter and boolean state, or</li>
<li>string parameter and string state.</li>
</ul>
<p>Let's modify our small app to demonstrate these cases.
First, we extend <code>setup_actions</code>.
For the action without parameter or state, we can use the pre-defined "window.close" action.
Therefore, we don't have to add anything here.</p>
<p>With the action "button-frame", we manipulate the "has-frame" property of <code>button</code>.
Here, the convention is that actions with no parameter and boolean state should behave like toggle actions.
This means that the caller can expect the boolean state to toggle after activating the action. Luckily for us, that is the default behavior for <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.PropertyAction.html"><code>gio::PropertyAction</code></a> with a boolean property.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span>        // Add property action "button-frame" to `window`
        let button = self.imp().button.get();
        let action_button_frame =
            PropertyAction::new("button-frame", &amp;button, "has-frame");
        self.add_action(&amp;action_button_frame);
<span class="boring">
</span><span class="boring">        // Add stateful action "orientation" to `window` taking a string as parameter
</span><span class="boring">        let action_orientation = ActionEntry::builder("orientation")
</span><span class="boring">            .parameter_type(Some(&amp;String::static_variant_type()))
</span><span class="boring">            .state("Vertical".to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match parameter.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                // Set orientation and save state
</span><span class="boring">                window.imp().gtk_box.set_orientation(orientation);
</span><span class="boring">                action.set_state(&amp;parameter.to_variant());
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count, action_orientation]);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>A <code>PropertyAction</code> is useful when you need an action that manipulates the property of a GObject.
The property then acts as the state of the action.
As mentioned above, if the property is a boolean the action has no parameter and toggles the property on activation.
In all other cases, the action has a parameter of the same type as the property.
When activating the action, the property gets set to the same value as the parameter of the action.</p>
</blockquote>
<p>Finally, we add "win.orientation", an action with string parameter and string state.
This action can be used to change the orientation of <code>gtk_box</code>.
Here the convention is that the state should be set to the given parameter.
We don't need the action state to implement orientation switching, however it is useful for making the menu display the current orientation.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Add property action "button-frame" to `window`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        let action_button_frame =
</span><span class="boring">            PropertyAction::new("button-frame", &amp;button, "has-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span>        // Add stateful action "orientation" to `window` taking a string as parameter
        let action_orientation = ActionEntry::builder("orientation")
            .parameter_type(Some(&amp;String::static_variant_type()))
            .state("Vertical".to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;String&gt;()
                    .expect("The value needs to be of type `String`.");

                let orientation = match parameter.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                // Set orientation and save state
                window.imp().gtk_box.set_orientation(orientation);
                action.set_state(&amp;parameter.to_variant());
            })
            .build();
        self.add_action_entries([action_count, action_orientation]);
<span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Even though <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Menu.html"><code>gio::Menu</code></a> can also be created with the bindings, the most convenient way is to use the interface builder for that.
We do that by adding the menu in front of the template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/resources/window.ui">listings/actions/6/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Close window&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;window.close&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Toggle button frame&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.button-frame&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;section&gt;
+      &lt;attribute name="label" translatable="yes"&gt;Orientation&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Horizontal&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Vertical&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Vertical&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/section&gt;
+  &lt;/menu&gt;
   &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="title"&gt;My GTK App&lt;/property&gt;
+    &lt;property name="width-request"&gt;360&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type ="end"&gt;
+          &lt;object class="GtkMenuButton"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class="GtkBox" id="gtk_box"&gt;
         &lt;property name="orientation"&gt;vertical&lt;/property&gt;
</code></pre>
<p>Since we connect the menu to the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> via the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#menu-model">menu-model</a> property, the <code>Menu</code> is expected to be a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html"><code>gtk::PopoverMenu</code></a>.
The <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html">documentation</a> for <code>PopoverMenu</code> also explains its <code>xml</code> syntax for the interface builder.</p>
<p>Also note how we specified the target:</p>
<pre><code class="language-xml">&lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
</code></pre>
<p>String is the default type of the target which is why we did not have to specify a type.
With targets of other types you need to manually specify the correct <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant format string</a>.
For example, an <code>i32</code> variable with value "5" would correspond to this:</p>
<pre><code class="language-xml">&lt;attribute name="target" type="i"&gt;5&lt;/attribute&gt;
</code></pre>
<p>This is how the app looks in action:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_menu.webm" type="video/webm">
  <p>A video which now also shows the menu</p>
 </video>
</div>
<blockquote>
<p>We changed the icon of the <code>MenuButton</code> by setting its property "icon-name" to "open-menu-symbolic".
You can find more icons with the <a href="https://flathub.org/apps/org.gnome.design.IconLibrary">Icon Library</a>.
They can be embedded with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a> and then be referenced within the composite templates (or other places).</p>
</blockquote>
<h2 id="settings-1"><a class="header" href="#settings-1">Settings</a></h2>
<p>The menu entries nicely display the state of our stateful actions, but after the app is closed, all changes to that state are lost.
As usual, we solve this problem with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a>.
First we create a schema with settings corresponding to the stateful actions we created before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/org.gtk_rs.Actions7.gschema.xml">listings/actions/7/org.gtk_rs.Actions7.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Actions7" path="/org/gtk_rs/Actions7/"&gt;
    &lt;key name="button-frame" type="b"&gt;
      &lt;default&gt;true&lt;/default&gt;
      &lt;summary&gt;Whether the button has a frame&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="orientation" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='Horizontal'/&gt;
        &lt;choice value='Vertical'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'Vertical'&lt;/default&gt;
      &lt;summary&gt;Orientation of GtkBox&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Again, we install the schema as described in the settings <a href="./settings.html">chapter</a>.
Then we add the settings to <code>imp::Window</code>.
Since <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> does not implement <code>Default</code>, we wrap it in a <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
    #[template_child]
    pub label: TemplateChild&lt;Label&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">        obj.bind_settings();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Now we create functions to make it easier to access settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Creating stateful actions from setting entries is so common that <code>Settings</code> provides a method for that exact purpose.
We create actions with the<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.create_action"> <code>create_action</code></a> method and then add them to the action group of our window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span>        // Create action from key "button-frame" and add to action group "win"
        let action_button_frame = self.settings().create_action("button-frame");
        self.add_action(&amp;action_button_frame);

        // Create action from key "orientation" and add to action group "win"
        let action_orientation = self.settings().create_action("orientation");
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since actions from <code>create_action</code> follow the aforementioned conventions, we can keep further changes to a minimum.
The action "win.button-frame" toggles its state with each activation and the state of the "win.orientation" action follows the given parameter.</p>
<p>We still have to specify what should happen when the actions are activated though.
For the stateful actions, instead of adding callbacks to their "activate" signals, we bind the settings to properties we want to manipulate.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn bind_settings(&amp;self) {
        // Bind setting "button-frame" to "has-frame" property of `button`
        let button = self.imp().button.get();
        self.settings()
            .bind("button-frame", &amp;button, "has-frame")
            .build();

        // Bind setting "orientation" to "orientation" property of `button`
        let gtk_box = self.imp().gtk_box.get();
        self.settings()
            .bind("orientation", &amp;gtk_box, "orientation")
            .mapping(|variant, _| {
                let orientation = variant
                    .get::&lt;String&gt;()
                    .expect("The variant needs to be of type `String`.");

                let orientation = match orientation.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                Some(orientation.to_value())
            })
            .build();
    }
<span class="boring">}</span></code></pre>
<p>Finally, we make sure that <code>bind_settings</code> is called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_actions();
        obj.bind_settings();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Actions are extremely powerful, and we are only scratching the surface here.
If you want to learn more about them, the <a href="https://developer.gnome.org/documentation/tutorials/actions.html">GNOME developer documentation</a> is a good place to start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manipulating-state-of-to-do-app"><a class="header" href="#manipulating-state-of-to-do-app">Manipulating State of To-Do App</a></h1>
<h2 id="filtering-tasks"><a class="header" href="#filtering-tasks">Filtering Tasks</a></h2>
<p>Now it is time to continue working on our To-Do app.
One nice feature to add would be filtering of the tasks.
What a chance to use our newly gained knowledge of actions!
Using actions, we can access the filter via the menu as well as via keyboard shortcuts.
This is how we want this to work in the end:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_2_animation.webm" type="video/webm">
  <p>A video which shows a more featureful To-Do app/p>
 </video>
</div>
<p>Note that the screencast also shows a button with label "Clear" which will remove all done tasks.
This will come in handy when we later make the app preserve the tasks between sessions.</p>
<p>Let's start by adding a menu and a header bar to <code>window.ui</code>.
After reading the <a href="actions.html">actions</a> chapter the added code should feel familiar.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/resources/window.ui">listings/todo/2/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;submenu&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Filter&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_All&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;All&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Open&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Open&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Done&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Done&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/submenu&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Remove Done Tasks&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.remove-done-tasks&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Keyboard Shortcuts&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.show-help-overlay&lt;/attribute&gt;
+    &lt;/item&gt;
+  &lt;/menu&gt;
   &lt;template class="TodoWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="width-request"&gt;360&lt;/property&gt;
     &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type="end"&gt;
+          &lt;object class="GtkMenuButton" id="menu_button"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
</code></pre>
<p>Then, we create a settings schema.
Again, the "filter" setting correspond to the stateful actions called by the menu.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/org.gtk_rs.Todo2.gschema.xml">listings/todo/2/org.gtk_rs.Todo2.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Todo2" path="/org/gtk_rs/Todo2/"&gt;
    &lt;key name="filter" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='All'/&gt;
        &lt;choice value='Open'/&gt;
        &lt;choice value='Done'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'All'&lt;/default&gt;
      &lt;summary&gt;Filter of the tasks&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>We install the schema as described in the settings <a href="./settings.html">chapter</a>
Then we add a reference to <code>settings</code> to <code>imp::Window</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListView&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Again, we create functions to make it easier to access settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also add the methods <code>is_completed</code>, <code>task_data</code> and <code>from_task_data</code> to <code>TaskObject</code>.
We will make use of them in the following snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl TaskObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::builder()
            .property("completed", completed)
            .property("content", content)
            .build()
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        self.imp().data.borrow().completed
    }

    pub fn task_data(&amp;self) -&gt; TaskData {
        self.imp().data.borrow().clone()
    }

    pub fn from_task_data(task_data: TaskData) -&gt; Self {
        Self::new(task_data.completed, task_data.content)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct TaskData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>Similar to the previous chapter, we let <code>settings</code> create the action.
Then we add the newly created action "filter" to our window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_actions(&amp;self) {
        // Create action from key "filter" and add to action group "win"
        let action_filter = self.settings().create_action("filter");
        self.add_action(&amp;action_filter);
    }
<span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also add an action which allows us to remove done tasks.
This time we use another method called <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action"><code>install_action</code></a>.
This method has a couple of limitation.
It can only be used when subclassing widgets, and it doesn't support stateful actions.
On the flipside, its usage is concise and it has a corresponding sister-method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a> which we will use in one of the future chapters.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>This is the implementation of <code>remove_done_tasks</code>.
We iterate through the <code>gio::ListStore</code> and remove all completed task objects.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn remove_done_tasks(&amp;self) {
        let tasks = self.tasks();
        let mut position = 0;
        while let Some(item) = tasks.item(position) {
            // Get `TaskObject` from `glib::Object`
            let task_object = item
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            if task_object.is_completed() {
                tasks.remove(position);
            } else {
                position += 1;
            }
        }
    }
<span class="boring">}</span></code></pre>
<p>After activating the action "win.filter", the corresponding setting will be changed.
So we need a method which translates this setting into a filter that the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FilterListModel.html"><code>gtk::FilterListModel</code></a> understands.
The possible states are "All", "Open" and "Done".
We return <code>Some(filter)</code> for "Open" and "Done".
If the state is "All" nothing has to be filtered out, so we return <code>None</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
        // Get filter_state from settings
        let filter_state: String = self.settings().get("filter");

        // Create custom filters
        let filter_open = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow completed tasks
            !task_object.is_completed()
        });
        let filter_done = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow done tasks
            task_object.is_completed()
        });

        // Return the correct filter
        match filter_state.as_str() {
            "All" =&gt; None,
            "Open" =&gt; Some(filter_open),
            "Done" =&gt; Some(filter_done),
            _ =&gt; unreachable!(),
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Now, we can set up the model.
We initialize <code>filter_model</code> with the state from the settings by calling the method <code>filter</code>.
Whenever the state of the key "filter" changes, we call the method <code>filter</code> again to get the updated <code>filter_model</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_tasks(&amp;self) {
        // Create new model
        let model = gio::ListStore::new::&lt;TaskObject&gt;();

        // Get state and set model
        self.imp().tasks.replace(Some(model));

        // Wrap model with filter and selection and pass it to the list view
        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.set_model(Some(&amp;selection_model));

        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[weak]
                filter_model,
                move |_, _| {
                    filter_model.set_filter(window.filter().as_ref());
                }
            ),
        );
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Then, we bind the shortcuts to their actions with <code>set_accels_for_action</code>.
Here as well, a detailed action name is used.
Since this has to be done at the application level, <code>setup_shortcuts</code> takes a <code>gtk::Application</code> as parameter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/main.rs">listings/todo/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo2";
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("todo_2.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn setup_shortcuts(app: &amp;Application) {
    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now that we created all these nice shortcuts we will want our users to find them.
We do that by creating a shortcut window.
Again we use an <code>ui</code> file to describe it, but here we don't want to use it as template for our custom widget.
Instead we instantiate a widget of the existing class <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsWindow.html"><code>gtk::ShortcutsWindow</code></a> with it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/resources/shortcuts.ui">listings/todo/2/resources/shortcuts.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkShortcutsWindow" id="help_overlay"&gt;
    &lt;property name="modal"&gt;True&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkShortcutsSection"&gt;
        &lt;property name="section-name"&gt;shortcuts&lt;/property&gt;
        &lt;property name="max-height"&gt;10&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkShortcutsGroup"&gt;
            &lt;property name="title" translatable="yes" context="shortcut window"&gt;General&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Show shortcuts&lt;/property&gt;
                &lt;property name="action-name"&gt;win.show-help-overlay&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show all tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('All')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only open tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Open')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only completed tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Done')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>The entries can be organized with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsSection.html"><code>gtk::ShortcutsSection</code></a> and <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsGroup.html"><code>gtk::ShortcutsGroup</code></a>.
If we specify the action name, we also don't have to repeat the keyboard accelerator.
<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsShortcut.html"><code>gtk::ShortcutsShortcut</code></a> looks it up on its own.</p>
<blockquote>
<p>Note the way we set <code>action-name</code> for <code>ShortcutsShortcut</code>.
Instead of using a separate property for the target, it takes a <em>detailed</em> action name.
Detailed names look like this: <code>action_group.action_name(target)</code>.
Formatting of the target depends on its type and is documented <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html#method.parse_detailed_name">here</a>.
In particular, strings have to be enclosed single quotes as you can see in this example.</p>
</blockquote>
<p>Finally, we have to add the <code>shortcuts.ui</code> to our resources.
Note that we give it the alias <code>gtk/help-overlay.ui</code>.
We do that to take advantage of a convenience functionality documented <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html#automatic-resources">here</a>.
It will look for a resource at <code>gtk/help-overlay.ui</code> which defines a <code>ShortcutsWindow</code> with id <code>help_overlay</code>.
If it can find one it will create a action <code>win.show-help-overlay</code> which will show the window and associate the shortcut <kbd>Ctrl</kbd> + <kbd>?</kbd> with this action.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/resources/resources.gresource.xml">listings/todo/2/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/Todo2/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_2_shortcuts.png" alt="The shortcut window"/></div>
<h2 id="saving-and-restoring-tasks"><a class="header" href="#saving-and-restoring-tasks">Saving and Restoring Tasks</a></h2>
<p>Since we use <code>Settings</code>, our filter state will persist between sessions.
However, the tasks themselves will not.
Let us implement that.
We could store our tasks in <code>Settings</code>, but it would be inconvenient.
When it comes to serializing and deserializing nothing beats the crate <a href="https://lib.rs/crates/serde"><code>serde</code></a>.
Combined with <a href="https://lib.rs/crates/serde_json"><code>serde_json</code></a> we can save our tasks as serialized <a href="https://en.wikipedia.org/wiki/JSON">json</a> files.</p>
<p>First, we extend our <code>Cargo.toml</code> with the <code>serde</code> and <code>serde_json</code> crate.</p>
<pre><code>cargo add serde --features derive
cargo add serde_json
</code></pre>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/Cargo.toml">listings/Cargo.toml</a></p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</code></pre>
<p>Serde is a framework for serializing and deserializing Rust data structures.
The <code>derive</code> feature allows us to make our structures (de-)serializable with a single line of code.
We also use the <code>rc</code> feature so that Serde can deal with <code>std::rc::Rc</code> objects.
This is why we stored the data of <code>TodoObject</code> in a distinct <code>TodoData</code> structure.
Doing so allows us to derive <code>Serialize</code> and <code>Deserialize</code> for <code>TodoData</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("completed", completed)
</span><span class="boring">            .property("content", content)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn is_completed(&amp;self) -&gt; bool {
</span><span class="boring">        self.imp().data.borrow().completed
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn task_data(&amp;self) -&gt; TaskData {
</span><span class="boring">        self.imp().data.borrow().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_task_data(task_data: TaskData) -&gt; Self {
</span><span class="boring">        Self::new(task_data.completed, task_data.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct TaskData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>We plan to store our data as a file, so we create a utility function to provide a suitable file path for us.
We use <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.user_data_dir.html"><code>glib::user_data_dir</code></a> to get the path for storing application data and create a new subdirectory for our app.
Then we return the file path.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/utils.rs">listings/todo/2/utils.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>pub fn data_path() -&gt; PathBuf {
    let mut path = glib::user_data_dir();
    path.push(APP_ID);
    std::fs::create_dir_all(&amp;path).expect("Could not create directory.");
    path.push("data.json");
    path
}</code></pre>
<p>We override the <code>close_request</code> virtual function to save the tasks when the window is closed.
To do so, we first iterate through all entries and store them in a <code>Vec</code>.
Then we serialize the <code>Vec</code> and store the data as a json file.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;TaskData&gt; = self
            .obj()
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Let's it have a look into what a <code>Vec&lt;TaskData&gt;</code> will be serialized.
Note that <a href="https://docs.serde.rs/serde_json/fn.to_writer.html"><code>serde_json::to_writer</code></a> saves the data into a more concise, but also less readable way.
To create the equivalent but nicely formatted json below you can just replace <code>to_writer</code> with <a href="https://docs.serde.rs/serde_json/fn.to_writer_pretty.html"><code>serde_json::to_writer_pretty</code></a>.</p>
<p>Filename: data.json</p>
<pre><code class="language-json">[
  {
    "completed": true,
    "content": "Task Number Two"
  },
  {
    "completed": false,
    "content": "Task Number Five"
  },
  {
    "completed": true,
    "content": "Task Number Six"
  },
  {
    "completed": false,
    "content": "Task Number Seven"
  },
  {
    "completed": false,
    "content": "Task Number Eight"
  }
]
</code></pre>
<p>When we start the app, we will want to restore the saved data.
Let us add a <code>restore_data</code> method for that.
We make sure to handle the case where there is no data file there yet.
It might be the first time that we started the app and therefore there is no former session to restore.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
                "It should be possible to read `backup_data` from the json file.",
            );

            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
            let task_objects: Vec&lt;TaskObject&gt; = backup_data
                .into_iter()
                .map(TaskObject::from_task_data)
                .collect();

            // Insert restored objects into model
            self.tasks().extend_from_slice(&amp;task_objects);
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Finally, we make sure that everything is set up in <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_tasks();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_factory();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Our To-Do app suddenly became much more useful.
Not only can we filter tasks, we also retain our tasks between sessions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css"><a class="header" href="#css">CSS</a></h1>
<p>When you want to modify the style of your website, you use <a href="https://de.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>.
Similarly, GTK supports its own variant of CSS in order to style your app.</p>
<blockquote>
<p>We will not explain every piece of syntax used in this chapter.
If you are new to CSS or just need a refresher, have a look at the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax">MDN Web Docs</a>.</p>
</blockquote>
<p>Let's say we have a button and we want to set its font color to magenta.
Every type of widget has a corresponding CSS node.
In the case of <code>gtk::Button</code>, this node is called <code>button</code>.
Therefore, we create a <code>style.css</code> file with the following content:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/1/style.css">listings/css/1/style.css</a></p>
<pre><code class="language-css">button {
  color: magenta;
}
</code></pre>
<p>Next, we need to load the CSS file in the startup step of the application.
As usual, the widgets are created during the "activate" step.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/1/main.rs">listings/css/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Css1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(|_| load_css());
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_string(include_str!("style.css"));

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}

fn build_ui(app: &amp;Application) {
    // Create button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Create a new window and present it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();
    window.present();
}</code></pre>
<p>When we now run the app, we notice that our button <em>and</em> the "close" button are magenta.
Probably not what we wanted, but that is what our CSS snippet does.
We did not specify for which button the rule should apply, so it was applied to both of them.</p>
<div style="text-align:center"><img src="img/css_1.png" alt="Window with magenta text"/></div>
<blockquote>
<p>The <code>GtkInspector</code> comes in quite handy (not only) when playing with CSS.
Make sure that the window of your app is focused and press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>.
A window will pop up which lets you browse and even manipulate the state of your app.
Open the CSS view and override the button color with the following snippet.</p>
<pre><code class="language-css">button {
 color: blue;
}
</code></pre>
<p>With the pause button you can toggle whether your CSS code is active or not.</p>
</blockquote>
<h2 id="style-classes-applied-by-gtk"><a class="header" href="#style-classes-applied-by-gtk">Style Classes Applied by GTK</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">Class selectors</a> are one way to choose which specific elements a CSS rule applies to.
GTK adds style classes to many of its widgets, often depending on their content.
A <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes"><code>gtk::Button</code></a>, for example, will get the <code>text-button</code> style class when its content is a label.
That is why we create a new CSS rule which only applies to <code>button</code> nodes with the style class <code>text_button</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/2/style.css">listings/css/2/style.css</a></p>
<pre><code class="language-css">button.text-button {
  color: magenta;
}
</code></pre>
<p>Now only the font of our button becomes magenta.</p>
<div style="text-align:center"><img src="img/css_2.png" alt="Now only the text of the button is magenta"/></div>
<h2 id="adding-your-own-style-class"><a class="header" href="#adding-your-own-style-class">Adding Your Own Style Class</a></h2>
<p>With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.add_css_class"><code>add_css_class</code></a> we can also add our own style classes to widgets.
One use-case for this is when you want a rule to apply to a hand-picked set of widgets.
For example if we have two buttons, but want only one of them to have magenta font.
Relying on one of the style classes which GTK adds will not help since both will get the same ones.
Which is why we add the style class <code>button-1</code> to the first one.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/3/main.rs">listings/css/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.add_css_class("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Then, we create a CSS rule that applies to <code>button</code> nodes with the style class <code>button-1</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/3/style.css">listings/css/3/style.css</a></p>
<pre><code class="language-css">button.button-1 {
  color: magenta;
}
</code></pre>
<p>We can see that this way only the first button gets colored magenta.</p>
<div style="text-align:center"><img src="img/css_3.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="specifying-name-of-a-widget"><a class="header" href="#specifying-name-of-a-widget">Specifying Name of a Widget</a></h2>
<p>If you want that your rule only applies to a single widget, matching with style classes can be fine.
Ideally however, you would give the widget a name and match with that name instead.
This way your intentions are more clear, compared to matching with style classes that can apply to multiple widgets.</p>
<p>Again, we have two buttons but want to color only one of them magenta.
We set the name of the first one with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.set_widget_name"><code>set_widget_name</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/4/main.rs">listings/css/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.set_widget_name("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Then, create a CSS rule that applies to <code>button</code> nodes with the name <code>button-1</code>.
The name is specified after the <code>#</code> symbol.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/4/style.css">listings/css/4/style.css</a></p>
<pre><code class="language-css">button#button-1 {
  color: magenta;
}
</code></pre>
<p>Again, the style rule only applies to the first button.</p>
<div style="text-align:center"><img src="img/css_4.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="css-rules-provided-by-gtk"><a class="header" href="#css-rules-provided-by-gtk">CSS Rules Provided by GTK</a></h2>
<p>Certain styles are common enough that GTK provides CSS rules for them.
For example, if you want to indicate that your button leads to a destructive or suggested action you don't have to provide your own CSS rules.
All you have to do is to add "destructive-action" or "suggested-action" style class to your button.
Most widgets will document these rules in their documentation under <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes">CSS nodes</a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/5/main.rs">listings/css/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Destructive");
    let button_2 = Button::with_label("Suggested");

    button_1.add_css_class("destructive-action");
    button_2.add_css_class("suggested-action");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(6)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="text-align:center"><img src="img/css_5.png" alt="The left button is red, the right one is blue"/></div>
<h2 id="interface-builder"><a class="header" href="#interface-builder">Interface Builder</a></h2>
<p>We can also add style classes with the interface builder.
Just add the <code>&lt;style&gt;</code> element to your widget.
The <code>&lt;style&gt;</code> element is documented together with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>gtk::Widget</code></a>.
Adding again destructive and suggested buttons, would then look like this:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/6/window/window.ui">listings/css/6/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Destructive&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="destructive-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Suggested&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="suggested-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="pseudo-classes"><a class="header" href="#pseudo-classes">Pseudo-classes</a></h2>
<p>Sometimes you want your CSS rules to apply under even more precise conditions than style classes allow.
That is where <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">pseudo-classes</a> come in.
Let's use a single button with name <code>button-1</code> to demonstrate this concept.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/7/window/window.ui">listings/css/7/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkButton"&gt;
        &lt;property name="label"&gt;Hover over me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="name"&gt;button-1&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>By adding the pseudo-class <code>hover</code>, we say that we want this rule to only apply to a <code>button</code> node with name <code>button-1</code> when hovering over it with the mouse pointer.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/7/style.css">listings/css/7/style.css</a></p>
<pre><code class="language-css">button#button-1:hover {
  color: magenta;
  background: yellow;
}
</code></pre>
<p>If we now hover over the button, we see that over the span of one second its background turns yellow and its font turns magenta.
After we removed the cursor, the button returns to its original state.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/css_6.webm" type="video/webm">
  <p>A video which shows that hovering over one button makes its background yellow and text red</p>
 </video>
</div>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>In the previous examples, a widget always corresponded to a single CSS node.
This is not always the case.
For example, <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> has multiple CSS nodes.
Let's see how that works.</p>
<p>First, we create a single <code>MenuButton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/8/window/window.ui">listings/css/8/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkMenuButton"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>You can make a <code>MenuButton</code> show an icon or a label.
If you choose to do neither of those, as we currently do, it shows an image displaying an arrow.</p>
<p>An inheritance tree of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#css-nodes">CSS nodes</a> displays this situation:</p>
<pre><code>menubutton
╰── button.toggle
    ╰── &lt;content&gt;
         ╰── [arrow]
</code></pre>
<p>We see that the <code>menubutton</code> node has children, which themselves have children and attached style classes.
Now we know that we have to add a CSS rule that applies to the <code>arrow</code> node, which is a descendant of <code>menubutton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/css/8/style.css">listings/css/8/style.css</a></p>
<pre><code class="language-css">menubutton arrow {
  color: magenta;
}
</code></pre>
<p>Indeed, we get a <code>MenuButton</code> with a magenta arrow.</p>
<div style="text-align:center"><img src="img/css_8.png" alt="Button with a magenta symbol in it"/></div>
<h2 id="set-css-name-and-use-exported-colors"><a class="header" href="#set-css-name-and-use-exported-colors">Set CSS Name and Use Exported Colors</a></h2>
<p>We already learned how to give an instance of a widget a name with pseudo-classes.
But what if we have a custom widget and we want to reference all instances of it?
Let's see how to deal with this situation by messing with our To-Do app once more.</p>
<p>The class <code>TaskRow</code> inherits from <code>gtk::Box</code>, so we could just match for the node <code>box</code>.
However, in that case we would also match with other instance of <code>gtk::Box</code>.
What we will want to do instead is to give <code>TaskRow</code> its own CSS name.
When calling <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.set_css_name"><code>set_css_name</code> </a>, we change the name of the CSS node of the widget class.
In our case, the widget <code>TaskRow</code> then corresponds to the node <code>task-row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/3/task_row/imp.rs">listings/todo/3/task_row/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default, CompositeTemplate)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo3/task_row.ui")]
</span><span class="boring">pub struct TaskRow {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub completed_button: TemplateChild&lt;CheckButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub content_label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    // Vector holding the bindings to properties of `TaskObject`
</span><span class="boring">    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoTaskRow";
    type Type = super::TaskRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
        klass.set_css_name("task-row");
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TaskRow {}</span></code></pre>
<p>What to do with the new node name now?
Let's change the background color once more but this time with a twist.
We are going to use the named color <code>success_color</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/3/resources/style.css">listings/todo/3/resources/style.css</a></p>
<pre><code class="language-css">task-row {
  background-color: @success_color;
}
</code></pre>
<p>The <code>Default</code> stylesheet of GTK provides pre-defined colors for various use-cases.
As of this writing, these exported colors can only be found in its <a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/b2c227e9c57839a2a4e24462a71ae0bad9a95264/gtk/theme/Default/_colors-public.scss">source code</a>.</p>
<p>There we find the color <code>success_color</code>, which in real scenarios should be used to indicate success.
We can then access the pre-defined color by adding an <code>@</code> in front of its name.</p>
<p>We also have to add <code>style.css</code> to <code>resources.gresource.xml</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/3/resources/resources.gresource.xml">listings/todo/3/resources/resources.gresource.xml</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;gresources&gt;
   &lt;gresource prefix="/org/gtk_rs/Todo3/"&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
+    &lt;file compressed="true"&gt;style.css&lt;/file&gt;
   &lt;/gresource&gt;
 &lt;/gresources&gt;
</code></pre>
<p>Additionally, we call <code>load_css()</code> in <code>connect_startup</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/3/main.rs">listings/todo/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span>    // Connect to signals
    app.connect_startup(|app| {
        setup_shortcuts(app);
        load_css()
    });
<span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>load_css()</code> is very similar to the one shown at the beginning of the chapter.
However, this time we load styles using <code>load_from_resource()</code>.</p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|app| {
</span><span class="boring">        setup_shortcuts(app);
</span><span class="boring">        load_css()
</span><span class="boring">    });
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span>fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>And that is how the task rows look like after the change.
Probably better to revert this immediately again.</p>
<div style="text-align:center"><img src="img/todo_3.png" alt="To-Do app with green background for its task widget"/></div>
<h2 id="adapt-todo-app"><a class="header" href="#adapt-todo-app">Adapt Todo App</a></h2>
<p>Luckily, finding an actual use for CSS in our To-Do app isn't too hard.
Until now the different tasks weren't nicely separated.
We can change that by adding the <code>frame</code> and the <code>separators</code> style class to our <code>tasks_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/4/resources/task_row.ui">listings/todo/4/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;object class="GtkListView" id="tasks_list"&gt;
   &lt;property name="valign"&gt;start&lt;/property&gt;
+  &lt;style&gt;
+    &lt;class name="frame"/&gt;
+    &lt;class name="separators"/&gt;
+  &lt;/style&gt;
 &lt;/object&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_4.png" alt="To-Do app with borders for its task widget"/></div>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>There are surely enough ways to define CSS rules.
Let's briefly recap the syntax we learned.
The following rule matches the node <code>arrow</code>, which is a descendant of the node <code>button</code> with the name <code>button-1</code> and the style classes <code>toggle</code> and <code>text-button</code>.
The rule then actually applies, when we also hover over <code>arrow</code>.</p>
<pre><code class="language-css">button#button-1.toggle.text-button arrow:hover {
  color: magenta;
}
</code></pre>
<p>When the rule applies, the <code>color</code> parameter will be set to magenta.
You can find the full list of supported parameters in GTK's <a href="https://docs.gtk.org/gtk4/css-properties.html#gtk-css-properties">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libadwaita"><a class="header" href="#libadwaita">Libadwaita</a></h1>
<p>If you target a certain platform with your GUI, you will want to follow the platform's <a href="https://en.wikipedia.org/wiki/Human_interface_guidelines">Human Interface Guidelines</a> (HIG).
With a GTK application, chances are the platform is either <a href="https://elementary.io">elementary OS</a> or <a href="https://www.gnome.org">GNOME</a>.
In this chapter we will discuss how to follow GNOME's <a href="https://developer.gnome.org/hig/">HIG</a> with <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/">libadwaita</a>.</p>
<p>Libadwaita is a library augmenting GTK 4 which:</p>
<ul>
<li>provides widgets to better follow GNOME's HIG</li>
<li>provides widgets to let applications <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/adaptive-layouts.html">change their layout </a> based on the available space</li>
<li>integrates the Adwaita <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/styles-and-appearance.html">stylesheet</a></li>
<li>allows runtime recoloring with <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/css-variables.html#ui-colors">CSS variables</a></li>
<li>adds <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StyleManager.html">API</a> to support the cross-desktop dark style preference</li>
</ul>
<p>In order to use the Rust bindings, add the <a href="https://crates.io/crates/libadwaita">libadwaita crate</a> as dependency by executing:</p>
<pre><code>cargo add libadwaita --rename adw --features v1_5
</code></pre>
<p>The versions of the <code>gtk4</code> and <code>libadwaita</code> crates need to be synced.
Just remember that when you update one of them to the newest version to update the other one as well.</p>
<p>Installation of the library itself works similar to GTK.
Just follow the installation instruction that is suitable for your distribution.</p>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<p>Fedora and derivatives:</p>
<pre><code>sudo dnf install libadwaita-devel
</code></pre>
<p>Debian and derivatives:</p>
<pre><code>sudo apt install libadwaita-1-dev
</code></pre>
<p>Arch and derivatives:</p>
<pre><code>sudo pacman -S libadwaita
</code></pre>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<pre><code>brew install libadwaita
</code></pre>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<h2 id="if-using-gvsbuild"><a class="header" href="#if-using-gvsbuild">If using gvsbuild</a></h2>
<p>If you used <code>gvsbuild</code> to build GTK 4:</p>
<pre><code>gvsbuild build libadwaita librsvg
</code></pre>
<h2 id="if-building-manually-with-msvc"><a class="header" href="#if-building-manually-with-msvc">If building manually with MSVC:</a></h2>
<p>From the Windows start menu, search for <code>x64 Native Tools Command Prompt for VS 2019</code>.
That will open a terminal configured to use MSVC x64 tools.
From there, run the following commands:</p>
<pre><code>cd /
git clone --branch libadwaita-1-3 https://gitlab.gnome.org/GNOME/libadwaita.git --depth 1
cd libadwaita
meson setup builddir -Dprefix=C:/gnome -Dintrospection=disabled -Dvapi=false
meson install -C builddir
</code></pre>
<h2 id="work-around-missing-icons"><a class="header" href="#work-around-missing-icons">Work around missing icons</a></h2>
<p><a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/34b9ec5be2f3a38e1e72c4d96f130a2b14734121/NEWS#L60">This workaround is needed for GTK &lt; 4.10</a>
due to <a href="https://gitlab.gnome.org/GNOME/gtk/-/issues/5303">this issue</a>.</p>
<h3 id="gvsbuild"><a class="header" href="#gvsbuild">gvsbuild</a></h3>
<p>From a command prompt:</p>
<pre><code>xcopy /s /i C:\gtk-build\gtk\x64\release\share\icons\hicolor\scalable\apps C:\gtk-build\gtk\x64\release\share\icons\hicolor\scalable\actions
gtk4-update-icon-cache.exe -t -f C:\gtk-build\gtk\x64\release\share\icons\hicolor
</code></pre>
<h3 id="manually-with-msvc"><a class="header" href="#manually-with-msvc">Manually with MSVC</a></h3>
<pre><code>xcopy /s /i C:\gnome\share\icons\hicolor\scalable\apps C:\gnome\share\icons\hicolor\scalable\actions
gtk4-update-icon-cache.exe -t -f C:\gnome\share\icons\hicolor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-to-do-app-use-libadwaita"><a class="header" href="#let-to-do-app-use-libadwaita">Let To-Do App use Libadwaita</a></h1>
<p>Within this chapter we will adapt our To-Do app so that it follows GNOME's <a href="https://developer.gnome.org/hig/">HIG</a>.
Let's start by installing Libadwaita and adding the <code>libadwaita</code> crate to our dependencies as explained in the <a href="libadwaita.html">previous chapter</a>.</p>
<p>The simplest way to take advantage of Libadwaita is by replacing <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html"><code>gtk::Application</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.Application.html"><code>adw::Application</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/5/main.rs">listings/todo/5/main.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo5";
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    gio::resources_register_include!("todo_5.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    //        👇 changed
    let app = adw::Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

//                       👇 changed
fn setup_shortcuts(app: &amp;adw::Application) {
    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
}

//                👇 changed
fn build_ui(app: &amp;adw::Application) {
    // Create a new custom window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/5/window/mod.rs">listings/todo/5/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span>    pub fn new(app: &amp;adw::Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }
<span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>adw::Application</code> calls <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/functions/fn.init.html"><code>adw::init</code></a> internally and makes sure that translations, types, stylesheets, and icons are set up properly for Libadwaita.
It also loads stylesheets automatically from resources as long as they are named <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.Application.html#automatic-resources">correctly</a>.</p>
<p>Looking at our To-Do app we can see that the looks of its widgets changed.
This is because the <code>Default</code> stylesheet provided by GTK has been replaced with the <code>Adwaita</code> stylesheet provided by Libadwaita.</p>
<div style="text-align:center"><img src="img/todo_change_4_5.png" alt="Transformation of To-Do app"/></div>
<p>Also, our app now switches to the dark style together with the rest of the system.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_dark.webm" type="video/webm">
   <p>A video which shows how the To-Do app changes color scheme from light to dark</p>
 </video>
</div>
<h2 id="boxed-lists"><a class="header" href="#boxed-lists">Boxed lists</a></h2>
<p>Of course Libadwaita is more than just a couple of stylesheets and a <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StyleManager.html"><code>StyleManager</code></a>.
But before we get to the interesting stuff, we will make our lives easier for the future by replacing all occurrences of <code>gtk::prelude</code> and <code>gtk::subclass::prelude</code> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/prelude/index.html"><code>adw::prelude</code></a> and <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/subclass/prelude/index.html"><code>adw::subclass::prelude</code></a>.
This works because the <code>adw</code> preludes, in addition to the Libadwaita-specific traits, re-export the corresponding <code>gtk</code> preludes.</p>
<p>Now we are going let our tasks follow the <a href="https://developer.gnome.org/hig/patterns/containers/boxed-lists.html">boxed lists pattern</a>.
The HIG does not require us to use this style and there's a good reason for that: it is incompatible with recycling lists.
This means they cannot be used with <a href="https://developer.gnome.org/hig/patterns/containers/list-column-views.html">list views</a> and are therefore only appropriate for relatively small lists.</p>
<blockquote>
<p>Try to add tasks programmatically and see how many of them you have to add until the UI noticeably slows down.
Determine for yourself if you think that is a reasonable number or if we should have rather stuck with list views.</p>
</blockquote>
<p>We can use boxed lists by using <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a> instead of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>gtk::ListView</code></a>.
We will also add the <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/boxed-lists.html"><code>boxed-list</code></a> style class provided by Libadwaita.</p>
<p>Let's implement all these changes in the <code>window.ui</code> file.
All of the changes are confined within the second child of the <code>ApplicationWindow</code>.
To see the complete file, just click on the link after "Filename".</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/resources/window.ui">listings/todo/6/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;child&gt;
  &lt;object class="GtkScrolledWindow"&gt;
    &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
    &lt;property name="min-content-height"&gt;420&lt;/property&gt;
    &lt;property name="vexpand"&gt;True&lt;/property&gt;
    &lt;property name="child"&gt;
      &lt;object class="AdwClamp"&gt;
        &lt;property name="child"&gt;
          &lt;object class="GtkBox"&gt;
            &lt;property name="orientation"&gt;vertical&lt;/property&gt;
            &lt;property name="spacing"&gt;18&lt;/property&gt;
            &lt;property name="margin-top"&gt;24&lt;/property&gt;
            &lt;property name="margin-bottom"&gt;24&lt;/property&gt;
            &lt;property name="margin-start"&gt;12&lt;/property&gt;
            &lt;property name="margin-end"&gt;12&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkEntry" id="entry"&gt;
                &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
                &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkListBox" id="tasks_list"&gt;
                &lt;property name="visible"&gt;False&lt;/property&gt;
                &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                &lt;style&gt;
                  &lt;class name="boxed-list" /&gt;
                &lt;/style&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/object&gt;
&lt;/child&gt;
</code></pre>
<p>In order to follow the boxed list pattern, we switched to <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a>, set its property "selection-mode" to "none" and added the <code>boxed-list</code> style class.</p>
<p>Let's continue with <code>window/imp.rs</code>.
The member variable <code>tasks_list</code> now describes a <code>ListBox</code> rather than a <code>ListView</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/window/imp.rs">listings/todo/6/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo6/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We now move on to <code>window/mod.rs</code>.
<code>ListBox</code> supports models just fine, but without any widget recycling we don't need factories anymore.
<code>setup_factory</code> can therefore be safely deleted.
To setup the <code>ListBox</code>, we call <code>bind_model</code> in <code>setup_tasks</code>.
There we specify the model, as well as a closure describing how to transform the given GObject into a widget the list box can display.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span>        // Wrap model with filter and selection and pass it to the list box
        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );
<span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We still have to specify the <code>create_task_row</code> method.
Here, we create an <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ActionRow.html"><code>adw::ActionRow</code></a> with a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CheckButton.html"><code>gtk::CheckButton</code></a> as activatable widget.
Without recycling, a GObject will always belong to the same widget.
That means we can just bind their properties without having to worry about unbinding them later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
        // Create check button
        let check_button = CheckButton::builder()
            .valign(Align::Center)
            .can_focus(false)
            .build();

        // Create row
        let row = ActionRow::builder()
            .activatable_widget(&amp;check_button)
            .build();
        row.add_prefix(&amp;check_button);

        // Bind properties
        task_object
            .bind_property("completed", &amp;check_button, "active")
            .bidirectional()
            .sync_create()
            .build();
        task_object
            .bind_property("content", &amp;row, "title")
            .sync_create()
            .build();

        // Return row
        row
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When using boxed lists, you also have to take care to hide the <code>ListBox</code> when there is no task present.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span>        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;self.tasks());
        self.tasks().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Finally, we define the <code>set_task_list_visible</code> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Assure that `tasks_list` is only visible
    /// if the number of tasks is greater than 0
    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This is how the boxed list style looks like in our app.</p>
<div style="text-align:center"><img src="img/todo_6.png" alt="The To-Do app using libadwaita"/></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-collections"><a class="header" href="#adding-collections">Adding Collections</a></h1>
<h2 id="sidebar"><a class="header" href="#sidebar">Sidebar</a></h2>
<p>Using Libadwaita on its own was already a big leap forward when it came to the look and feel of the To-Do app.
Let us go one step further by adding a way to group tasks into collections.
These collections will get their own sidebar on the left of the app.
We will start by adding an empty sidebar without any functionality.</p>
<div style="text-align:center"><img src="img/todo_7_sidebar.png" alt="To-Do app with an empty sidebar"/></div>
<p>There are a couple of steps we have to go through to get to this state.
First, we have to replace <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ApplicationWindow.html"><code>adw::ApplicationWindow</code></a>.
The main difference between those two is that <code>adw::ApplicationWindow</code> has no titlebar area.
That comes in handy when we build up our interface with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.NavigationSplitView.html"><code>adw::NavigationSplitView</code></a>.
In the screenshot above, the <code>NavigationSplitView</code> adds a sidebar for the collection view to the left, while the task view occupies the space on the right.
When using <code>adw::ApplicationWindow</code> the collection view and task view have their own <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.HeaderBar.html"><code>adw::HeaderBar</code></a> and the separator spans over the whole window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt;      
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
        &lt;property name="min-sidebar-width"&gt;200&lt;/property&gt;
        &lt;property name="sidebar"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Collection view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
        &lt;property name="content"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Task view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p><code>NavigationSplitView</code> also helps with making your app <a href="https://developer.gnome.org/hig/guidelines/adaptive.html">adaptive</a>/
As soon as the requested size is too small to fit all children at the same time, the splitview collapses, and starts behaving like a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
This means that it only displays one of its children at a time.
The adaptive behavior of the leaflet allows the To-Do app to work on smaller screen sizes (like e.g. phones) even with the added collection view.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_7_navigation_sidebar.webm" type="video/webm">
   <p>A video which shows that reducing the width of the app let's the sidebar collapse</p>
 </video>
</div>
<p>We add the necessary UI elements for the collection view, such as a header bar with a button to add a new collection, as well as the list box <code>collections_list</code> to display the collections later on.
We also add the style <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/style-classes.html#sidebars">navigations-sidebar</a> to <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" bind-source="TodoWindow"
    bind-property="title" bind-flags="sync-create" /&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;child type="start"&gt;
            &lt;object class="GtkToggleButton"&gt;
              &lt;property name="icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;New Collection&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkListBox" id="collections_list"&gt;
              &lt;style&gt;
                &lt;class name="navigation-sidebar" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
</code></pre>
<p>We also add a header bar to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" translatable="yes"&gt;Tasks&lt;/property&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;property name="show-title"&gt;False&lt;/property&gt;
          &lt;child type="end"&gt;
            &lt;object class="GtkMenuButton"&gt;
              &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
              &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;Main Menu&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="AdwClamp"&gt;
              &lt;property name="maximum-size"&gt;400&lt;/property&gt;
              &lt;property name="tightening-threshold"&gt;300&lt;/property&gt;
              &lt;property name="child"&gt;
                &lt;object class="GtkBox"&gt;
                  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
                  &lt;property name="margin-start"&gt;12&lt;/property&gt;
                  &lt;property name="margin-end"&gt;12&lt;/property&gt;
                  &lt;property name="spacing"&gt;12&lt;/property&gt;
                  &lt;child&gt;
                    &lt;object class="GtkEntry" id="entry"&gt;
                      &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
                      &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                  &lt;child&gt;
                    &lt;object class="GtkListBox" id="tasks_list"&gt;
                      &lt;property name="visible"&gt;False&lt;/property&gt;
                      &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;style&gt;
                        &lt;class name="boxed-list" /&gt;
                      &lt;/style&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                &lt;/object&gt;
              &lt;/property&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/property&gt;
&lt;/object&gt;
</code></pre>
<p>We also have to adapt the window implementation.
For example, the parent type of our window is now <code>adw::ApplicationWindow</code> instead of <code>gtk::ApplicationWindow</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    //                👇 changed
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>That also means that we have to implement the trait <code>AdwApplicationWindowImpl</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    //                👇 changed
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all adwaita application windows
impl AdwApplicationWindowImpl for Window {}</code></pre>
<p>Finally, we add <code>adw::ApplicationWindow</code> to the ancestors of <code>Window</code> in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/mod.rs">listings/todo/7/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        //       👇 changed
        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="placeholder-page"><a class="header" href="#placeholder-page">Placeholder Page</a></h2>
<p>Even before we start to populate the collection view, we ought to think about a different challenge: the empty state of our To-Do app.
Before, the empty state without a single task was quite okay.
It was clear that you had to add tasks in the entry bar.
However, now the situation is different.
Users will have to add a collection first, and we have to make that clear.
The GNOME HIG suggests to use a <a href="https://developer.gnome.org/hig/patterns/feedback/placeholders.html">placeholder page</a> for that.
In our case, this placeholder page will be presented to the user if they open the app without any collections present.</p>
<div style="text-align:center"><img src="img/todo_8_placeholder_page.png" alt="The placeholder page"/></div>
<p>We now wrap our UI in a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
One stack page describes the placeholder page, the other describes the main page.
We will later wire up the logic to display the correct stack page in the Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt; 
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="GtkStack" id="stack"&gt;
        &lt;property name="transition-type"&gt;crossfade&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;placeholder&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="GtkBox"&gt;
                &lt;!--Placeholder page implementation--&gt; 
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;main&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
                &lt;!--Main page implementation--&gt;
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to create the pageholder page as displayed before, we combine a flat header bar with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StatusPage.html"><code>adw::StatusPage</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="GtkBox"&gt;
  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
  &lt;child&gt;
    &lt;object class="GtkHeaderBar"&gt;
      &lt;style&gt;
        &lt;class name="flat" /&gt;
      &lt;/style&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class="GtkWindowHandle"&gt;
      &lt;property name="vexpand"&gt;True&lt;/property&gt;
      &lt;property name="child"&gt;
        &lt;object class="AdwStatusPage"&gt;
          &lt;property name="icon-name"&gt;checkbox-checked-symbolic&lt;/property&gt;
          &lt;property name="title" translatable="yes"&gt;No Tasks&lt;/property&gt;
          &lt;property name="description" translatable="yes"&gt;Create some tasks to start using the app.&lt;/property&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkButton"&gt;
              &lt;property name="label" translatable="yes"&gt;_New Collection&lt;/property&gt;
              &lt;property name="use-underline"&gt;True&lt;/property&gt;
              &lt;property name="halign"&gt;center&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
              &lt;style&gt;
                &lt;class name="pill" /&gt;
                &lt;class name="suggested-action" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<p>We still need a way to store our collections.
Just like we have already created <code>TaskObject</code>, we will now introduce <code>CollectionObject</code>.
It will have the members <code>title</code> and <code>tasks</code>, both of which will be exposed as properties.
As usual, the full implementation can be seen by clicking at the eye symbol at the top right of the snippet.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/imp.rs">listings/todo/8/collection_object/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CollectionObject)]
pub struct CollectionObject {
    #[property(get, set)]
    pub title: RefCell&lt;String&gt;,
    #[property(get, set)]
    pub tasks: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CollectionObject {
    const NAME: &amp;'static str = "TodoCollectionObject";
    type Type = super::CollectionObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CollectionObject {}</span></code></pre>
<p>We also add the struct <code>CollectionData</code> to aid in serialization and deserialization.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CollectionObject {
</span><span class="boring">    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("title", title)
</span><span class="boring">            .property("tasks", tasks)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
</span><span class="boring">        let title = self.imp().title.borrow().clone();
</span><span class="boring">        let tasks_data = self
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">        CollectionData { title, tasks_data }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
</span><span class="boring">        let title = collection_data.title;
</span><span class="boring">        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
</span><span class="boring">            .tasks_data
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(TaskObject::from_task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">        tasks.extend_from_slice(&amp;tasks_to_extend);
</span><span class="boring">
</span><span class="boring">        Self::new(&amp;title, tasks)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CollectionData {
    pub title: String,
    pub tasks_data: Vec&lt;TaskData&gt;,
}</code></pre>
<p>Finally, we add methods to <code>CollectionObject</code> in order to</p>
<ul>
<li>construct it with <code>new</code>,</li>
<li>easily access the tasks <code>ListStore</code> with <code>tasks</code> and</li>
<li>convert to and from <code>CollectionData</code> with <code>to_collection_data</code> and <code>from_collection_data</code>.</li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionObject {
    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
        Object::builder()
            .property("title", title)
            .property("tasks", tasks)
            .build()
    }

    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
        let title = self.imp().title.borrow().clone();
        let tasks_data = self
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();
        CollectionData { title, tasks_data }
    }

    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
        let title = collection_data.title;
        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
            .tasks_data
            .into_iter()
            .map(TaskObject::from_task_data)
            .collect();

        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
        tasks.extend_from_slice(&amp;tasks_to_extend);

        Self::new(&amp;title, tasks)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct CollectionData {
</span><span class="boring">    pub title: String,
</span><span class="boring">    pub tasks_data: Vec&lt;TaskData&gt;,
</span><span class="boring">}</span></code></pre>
<h2 id="window-1"><a class="header" href="#window-1">Window</a></h2>
<p>In order to hook up the new logic, we have to add more state to <code>imp::Window</code>.
There are additional widgets that we access via the <code>template_child</code> macro.
Additionally, we reference the <code>collections</code> list store, the <code>current_collection</code> as well as the <code>current_filter_model</code>.
We also store <code>tasks_changed_handler_id</code>.
Its purpose will become clear in later snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    // 👇 all members below are new
    #[template_child]
    pub collections_list: TemplateChild&lt;ListBox&gt;,
    #[template_child]
    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
    #[template_child]
    pub stack: TemplateChild&lt;Stack&gt;,
    pub collections: OnceCell&lt;gio::ListStore&gt;,
    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>Further, we add a couple of helper methods which will come in handy later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        self.current_collection().tasks()
    }

    fn current_collection(&amp;self) -&gt; CollectionObject {
        self.imp()
            .current_collection
            .borrow()
            .clone()
            .expect("`current_collection` should be set in `set_current_collections`.")
    }

    fn collections(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .collections
            .get()
            .expect("`collections` should be set in `setup_collections`.")
            .clone()
    }

    fn set_filter(&amp;self) {
        self.imp()
            .current_filter_model
            .borrow()
            .clone()
            .expect("`current_filter_model` should be set in `set_current_collection`.")
            .set_filter(self.filter().as_ref());
    }
<span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As always, we want our data to be saved when we close the window.
Since most of the implementation is in the method <code>CollectionObject::to_collection_data</code>, the implementation of <code>close_request</code> doesn't change much.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;CollectionData&gt; = self
            .obj()
            .collections()
            .iter::&lt;CollectionObject&gt;()
            .filter_map(|collection_object| collection_object.ok())
            .map(|collection_object| collection_object.to_collection_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>constructed</code> stays mostly the same as well.
Instead of <code>setup_tasks</code> we now call <code>setup_collections</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_collections();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>setup_collections</code> sets up the <code>collections</code> list store as well as assuring that changes in the model will be reflected in the <code>collections_list</code>.
To do that it uses the method <code>create_collection_row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_collections(&amp;self) {
        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
        self.imp()
            .collections
            .set(collections.clone())
            .expect("Could not set collections");

        self.imp().collections_list.bind_model(
            Some(&amp;collections),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let collection_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `CollectionObject`.");
                    let row = window.create_collection_row(collection_object);
                    row.upcast()
                }
            ),
        )
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>create_collection_row</code> takes a <code>CollectionObject</code> and builds a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBoxRow.html"><code>gtk::ListBoxRow</code></a> from its information.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_collection_row(
        &amp;self,
        collection_object: &amp;CollectionObject,
    ) -&gt; ListBoxRow {
        let label = Label::builder()
            .ellipsize(pango::EllipsizeMode::End)
            .xalign(0.0)
            .build();

        collection_object
            .bind_property("title", &amp;label, "label")
            .sync_create()
            .build();

        ListBoxRow::builder().child(&amp;label).build()
    }
<span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also adapt <code>restore_data</code>.
Again, the heavy lifting comes from <code>CollectionObject::from_collection_data</code>, so we don't have to change too much here.
Since the rows of <code>collections_list</code> can be selected, we have to select one of them after restoring the data.
We choose the first one and let the method <code>set_current_collection</code> do the rest.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
                .expect(
                    "It should be possible to read `backup_data` from the json file.",
                );

            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
            let collections: Vec&lt;CollectionObject&gt; = backup_data
                .into_iter()
                .map(CollectionObject::from_collection_data)
                .collect();

            // Insert restored objects into model
            self.collections().extend_from_slice(&amp;collections);

            // Set first collection as current
            if let Some(first_collection) = collections.first() {
                self.set_current_collection(first_collection.clone());
            }
        }
    }
<span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>set_current_collection</code> assures that all elements accessing tasks refer to the task model of the current collection.
We bind the <code>tasks_list</code> to the current collection and store the filter model.
Whenever there are no tasks in our current collection we want to hide our tasks list.
Otherwise, the list box will leave a bad-looking line behind.
However, we don't want to accumulate signal handlers whenever we switch collections.
This is why we store the <code>tasks_changed_handler_id</code> and disconnect the old handler as soon as we set a new collection.
Finally, we select the collection row.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_current_collection(&amp;self, collection: CollectionObject) {
        // Wrap model with filter and selection and pass it to the list box
        let tasks = collection.tasks();
        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );

        // Store filter model
        self.imp().current_filter_model.replace(Some(filter_model));

        // If present, disconnect old `tasks_changed` handler
        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
            self.tasks().disconnect(handler_id);
        }

        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;tasks);
        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
        self.imp()
            .tasks_changed_handler_id
            .replace(Some(tasks_changed_handler_id));

        // Set current tasks
        self.imp().current_collection.replace(Some(collection));

        self.select_collection_row();
    }
<span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Previously, we used the method <code>set_task_list_visible</code>.
It assures that <code>tasks_list</code> is only visible if the number of tasks is greater than 0.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>select_collection_row</code> assures that the row for the current collection is selected in <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_collection_row(&amp;self) {
        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
            let row = self.imp().collections_list.row_at_index(index as i32);
            self.imp().collections_list.select_row(row.as_ref());
        }
    }
<span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="message-dialog"><a class="header" href="#message-dialog">Message Dialog</a></h2>
<p>There isn't yet a way to add a collection.
Let's implement that functionality.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_dialog.webm" type="video/webm">
   <p>A video which shows the new dialog</p>
 </video>
</div>
<p>The screencast above demonstrates the desired behavior.
When we activate the button with the <code>+</code> symbol, a dialog appears.
While the entry is empty, the "Create" button remains insensitive.
As soon as we start typing, the button becomes sensitive.
When we remove all typed letters and the entry becomes empty again, the "Create" button becomes insensitive and the entry gets the "error" style.
After clicking the "Create" button, a new collection is created, and we navigate to its task view.</p>
<p>To implement that behavior we will first add a "new-collection" action to <code>class_init</code> method.
This action will be activated by a click on the <code>+</code> button as well as on the button in the placeholder page.
We are using <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a>.
It is a convenient way to add asynchronous actions to subclassed widgets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });

        // Create async action to create new collection and add to action group "win"
        klass.install_action_async(
            "win.new-collection",
            None,
            |window, _, _| async move {
                window.new_collection().await;
            },
        );
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>As soon as the "new-collection" action is activated, the <code>async</code> <code>new_collection</code> method is called.
Here, we create the <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.AlertDialog.html"><code>adw::AlertDialog</code></a>, set up the buttons as well as add the entry to it.
We add a callback to the entry to ensure that when the content changes, an empty content sets <code>dialog_button</code> as insensitive and adds an "error" CSS class to the entry.
We then <code>await</code> on the user pressing a button on the dialog.
If they click "Cancel", we simply return.
However, if they click "Create", we want a new collection to be created and set as current collection.
Afterwards we navigate forward on our leaflet, which means we navigate to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    async fn new_collection(&amp;self) {
        // Create entry
        let entry = Entry::builder()
            .placeholder_text("Name")
            .activates_default(true)
            .build();

        let cancel_response = "cancel";
        let create_response = "create";

        // Create new dialog
        let dialog = AlertDialog::builder()
            .heading("New Collection")
            .close_response(cancel_response)
            .default_response(create_response)
            .extra_child(&amp;entry)
            .build();
        dialog
            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
        // Make the dialog button insensitive initially
        dialog.set_response_enabled(create_response, false);
        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);

        // Set entry's css class to "error", when there is no text in it
        entry.connect_changed(clone!(
            #[weak]
            dialog,
            move |entry| {
                let text = entry.text();
                let empty = text.is_empty();

                dialog.set_response_enabled(create_response, !empty);

                if empty {
                    entry.add_css_class("error");
                } else {
                    entry.remove_css_class("error");
                }
            }
        ));

        let response = dialog.choose_future(self).await;

        // Return if the user chose `cancel_response`
        if response == cancel_response {
            return;
        }

        // Create a new list store
        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();

        // Create a new collection object from the title the user provided
        let title = entry.text().to_string();
        let collection = CollectionObject::new(&amp;title, tasks);

        // Add new collection object and set current tasks
        self.collections().append(&amp;collection);
        self.set_current_collection(collection);

        // Show the content
        self.imp().split_view.set_show_content(true);
    }
<span class="boring">}</span></code></pre>
<p>We also add more callbacks to <code>setup_callbacks</code>.
Importantly, we want to filter our current task model whenever the value of the "filter" setting changes.
Whenever the items of our collections change we also want to set the stack.
This makes sure that our placeholder page is shown if there are no collections.
Finally, we assure that when we click on a row of <code>collections_list</code>, <code>current_collection</code> is set to the selected collection and the split view shows the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span>        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                move |_, _| {
                    window.set_filter();
                }
            ),
        );

        // Setup callback when items of collections change
        self.set_stack();
        self.collections().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _, _, _| {
                window.set_stack();
            }
        ));

        // Setup callback for activating a row of collections list
        self.imp().collections_list.connect_row_activated(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, row| {
                let index = row.index();
                let selected_collection = window
                    .collections()
                    .item(index as u32)
                    .expect("There needs to be an object at this position.")
                    .downcast::&lt;CollectionObject&gt;()
                    .expect("The object needs to be a `CollectionObject`.");
                window.set_current_collection(selected_collection);
                window.imp().split_view.set_show_content(true);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Before, we called the method <code>set_stack</code>.
This method ensure when there is at least one collection, the "main" page is shown, and the "placeholder" page otherwise.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_stack(&amp;self) {
        if self.collections().n_items() &gt; 0 {
            self.imp().stack.set_visible_child_name("main");
        } else {
            self.imp().stack.set_visible_child_name("placeholder");
        }
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>And that was it!
Now we can enjoy the final result.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_adaptive_sidebar.webm" type="video/webm">
   <p>A video which shows the final To-Do app</p>
 </video>
</div>
<blockquote>
<p>You might have noticed that there is not yet a way to remove a collection.
Try to implement this missing piece of functionality in your local version of the To-Do app.
Which edge cases do you have to consider?</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
