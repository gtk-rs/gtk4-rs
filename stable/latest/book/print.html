<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Rust and GTK 4</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="gobject_concepts.html"><strong aria-hidden="true">5.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gobject_memory_management.html"><strong aria-hidden="true">5.1.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="gobject_subclassing.html"><strong aria-hidden="true">5.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="gobject_values.html"><strong aria-hidden="true">5.3.</strong> Generic Values</a></li><li class="chapter-item expanded "><a href="gobject_properties.html"><strong aria-hidden="true">5.4.</strong> Properties</a></li><li class="chapter-item expanded "><a href="gobject_signals.html"><strong aria-hidden="true">5.5.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> Settings</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> Saving Window State</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> List Widgets</a></li><li class="chapter-item expanded "><a href="interface_builder.html"><strong aria-hidden="true">10.</strong> Interface Builder</a></li><li class="chapter-item expanded "><a href="todo_app_1.html"><strong aria-hidden="true">11.</strong> Building a Simple To-Do App</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_app_2.html"><strong aria-hidden="true">13.</strong> Manipulating State of To-Do App</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">15.</strong> Resources</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Internationalization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Accessibility</div></li><li class="chapter-item expanded affix "><li class="part-title">Useful Libraries</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Relm4</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> GStreamer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Adwaita</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> SourceView</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Shumate</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> WebKitGTK</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Zbus and Ashpd</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Librsvg</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gui-development-with-rust-and-gtk-4"><a class="header" href="#gui-development-with-rust-and-gtk-4">GUI development with Rust and GTK 4</a></h1>
<p><em>by Julian Hofer, with contributions from the community</em></p>
<p>GTK 4 is the newest version of a popular cross-platform widget toolkit written in C.
Thanks to GObject-Introspection, GTK's API can be easily targeted by various programming languages.
The API even describes the ownership of its parameters!</p>
<p>Managing ownership without giving up speed is one of Rust's greatest strengths, which makes it an excellent choice to develop GTK apps with.
With this combination you do not have to worry about hitting bottlenecks mid-project anymore.
Additionally, with Rust you will have nice things such as</p>
<ul>
<li>thread safety,</li>
<li>memory safety,</li>
<li>sensible dependency management as well as</li>
<li>excellent third party libraries.</li>
</ul>
<p>The <code>gtk-rs</code> project provides bindings to many GTK-related libraries which we will be using throughout this book.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book assumes that you know your way around Rust code.
If this is not already the case, reading <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> is an enjoyable way to get you to that stage.
If you have experience with another low-level language such as C or C++ you
might find that reading <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half hour to learn Rust</a> gives you sufficient information as well.</p>
<p>Luckily, this — together with the wish to develop graphical applications — is all that is necessary to benefit from this book. </p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>In general, this book assumes that you are reading it in sequence from front to
back. However, if you are using it as a reference for a certain topic,
you might find it useful to just jump into it.</p>
<p>There are two kinds of chapters in this book: concept chapters and project
chapters.
In concept chapters, you will learn about an aspect of GTK development.
In project chapters, we will build small programs together, applying what you have learned so far.</p>
<p>The book strives to explain essential GTK concepts paired with practical examples.
However, if a concept can be better conveyed with a less practical example, we took this path most of the time.
If you are interested in contained and useful examples, we refer you to the corresponding <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/examples">section</a> of <code>gtk4-rs</code>' repository.</p>
<p>Every valid code snippet in the book is part of a listing.
The listings be found in the <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book/listings">git repository</a> of <code>gtk4-rs</code>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The book itself is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.
The only exception are the code snippets which are licensed under the <a href="https://gitlab.gnome.org/Hofer-Julian/gtk-rs-book/-/blob/main/LICENSE">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>In order to develop a <code>gtk-rs</code> app, you basically need two things on your workstation:</p>
<ul>
<li>the Rust toolchain, and</li>
<li>the GTK 4 library.</li>
</ul>
<p>As so often the devil hides in the details, which is why we will list the installation instructions for each operating system in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<h2 id="flatpak"><a class="header" href="#flatpak">Flatpak</a></h2>
<p>If you develop on Linux, using Flatpak is the most convenient option.
With Flatpak your whole workflow is containerized, and your users get the very same application you develop on including all dependencies. 
First, assure that Flatpak is installed on your system, check this <a href="https://flatpak.org/setup/">website</a> to see if any steps are necessary on your distribution.
Download the <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">gtk-rust-template</a> and follow the instructions in its README.</p>
<p>Then either install</p>
<ul>
<li><a href="https://flathub.org/apps/details/org.gnome.Builder">GNOME Builder</a> or</li>
<li><a href="https://flathub.org/apps/details/com.vscodium.codium">VSCodium</a> together with the <a href="https://open-vsx.org/extension/matklad/rust-analyzer">rust-analyzer</a> and <a href="https://open-vsx.org/extension/bilelmoussaoui/flatpak-vscode">flatpak</a> extensions.</li>
</ul>
<p>That is it.
The build dependencies can be downloaded by the IDE.
With GNOME Builder, you only have to press the run button for that.</p>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p>If you develop on the host, you first have to install rustup.
You can find the up-to-date instructions on <a href="https://rustup.rs">rustup.rs</a>.</p>
<p>Then install GTK 4 and the build essentials.
To do this, execute the command belonging to the distribution you are using.</p>
<p>Fedora and derivatives:</p>
<pre><code>sudo dnf install gtk4-devel gcc
</code></pre>
<p>Debian and derivatives:</p>
<pre><code>sudo apt install libgtk-4-dev build-essential
</code></pre>
<p>Arch and derivatives:</p>
<pre><code>sudo pacman -S gtk4 base-devel
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>First install rustup.
You can find the up-to-date instructions on <a href="https://rustup.rs">rustup.rs</a>.</p>
<p>Then install <a href="https://brew.sh/">homebrew</a>.</p>
<p>Finally, install GTK 4 by executing the following in your terminal:</p>
<pre><code class="language-bash">brew install gtk4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>When preparing your Windows machine, you have to decide between either using the <strong>MSVC toolchain</strong> or the <strong>GNU toolchain</strong>.
If in doubt, go for MSVC since that is the default on Windows.
You will want to go for the GNU toolchain if you depend on libraries that can only be compiled with the GNU toolchain.</p>
<h2 id="msvc-toolchain"><a class="header" href="#msvc-toolchain">MSVC toolchain</a></h2>
<h3 id="install-rustup"><a class="header" href="#install-rustup">Install Rustup</a></h3>
<p>Install the rust toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<h3 id="remove-residues-from-the-gnu-toolchain"><a class="header" href="#remove-residues-from-the-gnu-toolchain">Remove residues from the GNU toolchain</a></h3>
<p>If you used the GNU toolchain before, make sure to revert all changes you made to environment variables during the installation process.</p>
<p>Also set the rust toolchain back to msvc by executing:</p>
<pre><code>rustup default stable-msvc
</code></pre>
<h3 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h3>
<p>Install Visual Studio Community from <a href="https://visualstudio.microsoft.com/de/vs/community/">visualstudio.microsoft.com</a>.
Make sure to check the box &quot;Desktop development with C++&quot; during the installation process.</p>
<div style="text-align:center"><img src="img/vs-install.png" /></div>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p>Download git from <a href="https://gitforwindows.org/">gitforwindows.org</a>.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>Download python from <a href="https://www.python.org/downloads">python.org</a>.
Make sure to opt-in to adding Python to your Path during the installation process.</p>
<h3 id="meson"><a class="header" href="#meson">Meson</a></h3>
<p>Install meson by executing:</p>
<pre><code class="language-powershell">pip install meson ninja
</code></pre>
<h3 id="pkg-config"><a class="header" href="#pkg-config">Pkg-config</a></h3>
<p>Download pkg-config-lite from <a href="https://sourceforge.net/projects/pkgconfiglite/">sourceforge.net</a>.
Then extract and unpack it in <code>C:/</code>, so that the executable is in <code>C:\pkg-config-lite-0.28-1\bin</code>.</p>
<h3 id="update-path-environment-variable"><a class="header" href="#update-path-environment-variable">Update <code>Path</code> environment variable</a></h3>
<ol>
<li>Go to settings -&gt; Search and open <code>Advanced system settings</code> -&gt; Click on <code>Environment variables</code></li>
<li>Select <code>Path</code> -&gt; Click on <code>Edit</code> -&gt; Add the following entries:</li>
</ol>
<pre><code>C:\pkg-config-lite-0.28-1\bin
C:\gnome\bin
</code></pre>
<h3 id="compile-and-install-gtk-4"><a class="header" href="#compile-and-install-gtk-4">Compile and install GTK 4</a></h3>
<p>From the Windows start menu, search for <code>x64 Native Tools Command Prompt for VS 2019</code>.
That will open a terminal configured to use MSVC x64 tools.
From there, run the following commands:</p>
<pre><code class="language-powershell">cd /
git clone https://gitlab.gnome.org/GNOME/gtk.git --depth 1
cd gtk
meson setup builddir --prefix=C:/gnome -Dbuild-tests=false -Dmedia-gstreamer=disabled
meson install -C builddir
</code></pre>
<h3 id="set-pkg_config_path-environment-variable"><a class="header" href="#set-pkg_config_path-environment-variable">Set <code>PKG_CONFIG_PATH</code> environment variable</a></h3>
<ol>
<li>Go to settings -&gt; Search and open <code>Advanced system settings</code> -&gt; Click on <code>Environment variables</code></li>
<li>Under <code>User variables</code> click on <code>New</code> and add:</li>
</ol>
<ul>
<li>Variable name: <code>PKG_CONFIG_PATH</code></li>
<li>Variable value: <code>C:\gnome\lib\pkgconfig</code></li>
</ul>
<h2 id="gnu-toolchain"><a class="header" href="#gnu-toolchain">GNU toolchain</a></h2>
<h3 id="install-rustup-1"><a class="header" href="#install-rustup-1">Install Rustup</a></h3>
<p>Install the rust toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<p>Install MSYS2 from <a href="https://www.msys2.org/">www.msys2.org</a> </p>
<h3 id="install-gtk-4"><a class="header" href="#install-gtk-4">Install GTK 4</a></h3>
<p>From the Windows start menu, search for <code>MSYS2 MinGW 64-bit</code>.
That will open a terminal configured to use MinGW x64 tools.</p>
<p>There, execute the following commands to install <code>GTK 4</code>, <code>pkgconf</code> and <code>gcc</code>.</p>
<pre><code class="language-sh">pacman -S mingw-w64-x86_64-gtk4 mingw-w64-x86_64-pkgconf mingw-w64-x86_64-gcc
</code></pre>
<h3 id="update-path-environment-variable-1"><a class="header" href="#update-path-environment-variable-1">Update <code>Path</code> environment variable</a></h3>
<ol>
<li>Go to settings -&gt; Search and open <code>Advanced system settings</code> -&gt; Click on <code>Environment variables</code></li>
<li>Select <code>Path</code> -&gt; Click on <code>Edit</code> -&gt; Add the following three entries:</li>
</ol>
<pre><code>C:\msys64\mingw64\include
C:\msys64\mingw64\bin
C:\msys64\mingw64\lib
</code></pre>
<h3 id="setup-the-gnu-toolchain-for-rust"><a class="header" href="#setup-the-gnu-toolchain-for-rust">Setup the GNU toolchain for Rust</a></h3>
<p>The default toolchain on windows is <code>stable-msvc</code>.
To switch to <code>stable-gnu</code>, run the following commands from your terminal:</p>
<ol>
<li><code>rustup toolchain install stable-gnu</code></li>
<li><code>rustup default stable-gnu</code></li>
</ol>
<p>Please note that this command might change in the future.
If it does not work anymore, please open an <a href="https://github.com/gtk-rs/gtk4-rs/issues/new/choose">issue</a> on our repo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<p>There are two recommended ways to set up your workstation in order to develop <code>gtk-rs</code> applications.
Let us go through them one by one.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a> is Rust's build system and package manager.
If following the book is all you care about, using only Cargo will work fine for you.</p>
<p>Let us begin by installing all necessary tools.
First, follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.</p>
<p>Now, create a new project by executing:</p>
<pre><code class="language-bash">cargo new my-gtk-app
</code></pre>
<p>Add the following lines to your dependencies in <code>Cargo.toml</code>, where <code>X.X</code> should be replaced with the most up-to-date version of the <a href="https://crates.io/crates/gtk4">gtk4 crate</a>.</p>
<pre><code class="language-toml">gtk = { version = &quot;X.X&quot;, package = &quot;gtk4&quot; }
</code></pre>
<blockquote>
<p>Per default <code>gtk4-rs</code> is compatible with all GTK 4 releases.
If you want to use functionality that has been added to later releases, you have to specify this as a feature.
If you want to use functionality of GTK 4.6, you would add the following to your gtk dependency in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">gtk = { version = &quot;X.X&quot;, package = &quot;gtk4&quot;, features = [&quot;v4_6&quot;]}
</code></pre>
<p>This will only work if your available GTK version is indeed &gt;= 4.6.
You can get the version by executing the following command:</p>
<pre><code>pkg-config --modversion gtk4
</code></pre>
</blockquote>
<p>Now, you can run your application by executing:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="cargo--meson"><a class="header" href="#cargo--meson">Cargo + Meson</a></h2>
<p>Cargo is <em>almost</em> enough, but it is not well suited for handling resources such as icons or UI definition files.
That is why we recommend to use <a href="https://mesonbuild.com/">Meson</a> on top of it.
It is cross-platform, and its syntax is very readable.
Meson takes care of</p>
<ul>
<li>translations,</li>
<li>building and installing <a href="resources.html">resources</a> as well as</li>
<li>installing auxiliary files such as icons and <a href="settings.html">settings schemas</a>.</li>
</ul>
<p>Here as well, you first follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.
Finally, install Meson by following the instructions on the <a href="https://mesonbuild.com/Getting-meson.html">Meson website</a>.</p>
<p>You can download a ready-to-use gtk-rust-template <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">here</a>.
Follow the instructions in the README to initialize your own application.
Then configure your project.</p>
<pre><code class="language-bash">meson setup builddir
</code></pre>
<p>In order to compile and install it run the following command.
You have to execute it every time you modify your application.</p>
<pre><code class="language-bash">meson install -C builddir
</code></pre>
<p>Now, the application should be in a folder included in your system path.
You can either start it with the application launcher of your choice or from within your terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Now that we have got a working installation, let us get right into it!</p>
<p>At the very least, we need to create an <code>Application</code> instance with an <a href="https://developer.gnome.org/documentation/tutorials/application-id.html">application id</a>.
For that we use the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a> which many <code>gtk-rs</code> objects support.</p>
<p><span class="filename">Filename: listings/hello_world/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::prelude::*;
use gtk::Application;

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Run the application
    app.run();
}
</code></pre>
<p>It builds fine, but nothing appears on our screen.
GTK warns us that something should be called in its <code>activate</code> step.
So let us create a window there.</p>
<p><span class="filename">Filename: listings/hello_world/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::prelude::*;
use gtk::{Application, ApplicationWindow};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>That is better!</p>
<div style="text-align:center"><img src="img/hello_world_empty.png" /></div>
<p>Normally we expect to be able to interact with the user interface.
Also, the name of the chapter suggests that the phrase &quot;Hello World!&quot; will be involved.</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>There is now a button and if we click on it, its label becomes &quot;Hello World!&quot;.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/hello_world_button.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<p>Wasn't that hard to create our first <code>gtk-rs</code> app, right?
Let us now get a better understanding of what we did here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are the components that make up a GTK application.
GTK offers many-preexisting ones and if those do not fit, you can even create custom ones.
There are display widgets, buttons, containers and windows.
One kind of widget might be able to contain other widgets, it might present information and it might react to interaction.</p>
<p>The <a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> is useful to find out which widget fits your needs.
Let us say we want to add a button to our app.
We have quite a bit of choice here, but let us take the simplest one — a <code>Button</code>.</p>
<div style="text-align:center"><img src="img/widgets_button.png" /></div>
<p>GTK is an object-oriented framework, so all widgets are part of an inheritance tree with <code>GObject</code> at the top.
The inheritance tree of a <code>Button</code> looks like this:</p>
<pre><code class="language-console">GObject
╰── Widget
    ╰── Button
</code></pre>
<p>The <a href="https://docs.gtk.org/gtk4/class.Button.html#implements">GTK documentation</a> also tells us that <code>Button</code> implements the interfaces <code>GtkAccessible</code>, <code>GtkActionable</code>, <code>GtkBuildable</code>, <code>GtkConstraintTarget</code>.</p>
<p>Now let us compare that with the corresponding <code>Button</code> struct in <code>gtk-rs</code>.
The <a href="../docs/gtk4/struct.Button.html#implements">gtk-rs documentation</a> tells us which traits it implements.
We find that these traits either have a corresponding base class or interface in the GTK docs.
In the &quot;Hello World&quot; app we wanted to react to a button click.
This behavior is specific to a button, so we expect to find a suitable method in the <code>ButtonExt</code> trait.
And indeed, <code>ButtonExt</code> includes the method <a href="../docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a button with label and margins
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Please note that Rust requires bringing traits into scope, before using one of its methods.
In our example we did that by adding the following line:</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::prelude::*;
<span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button with label and margins
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>With it, we import all necessary traits for dealing with widgets.
You probably want to bring the prelude into scope in most of your source files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gobject-concepts"><a class="header" href="#gobject-concepts">GObject Concepts</a></h1>
<p>GTK is an object-oriented framework.
It is written in C, which does not support object-orientation out of the box.
That is why, GTK relies on the GObject library to provide the object system.</p>
<p>We already learned, that <code>gtk-rs</code> maps GObject concepts like inheritance and interfaces to Rust traits.
In this chapter we will additionally find out:</p>
<ul>
<li>How to manage the memory of GObjects.</li>
<li>How to create our own GObjects via subclassing.</li>
<li>How to deal with generic values.</li>
<li>How to use properties.</li>
<li>How to emit and receive signals.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>A GObject (or <code>glib::Object</code> in Rust terms) is a reference-counted, mutable object.
Let us see in a set of real life examples which consequences this has.</p>
<pre><pre class="playground"><code class="language-rust  no_run compile_fail">use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindow, Button, Orientation};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(application: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::new(application);

    // Create two buttons
    let button_increase = Button::builder()
        .label(&quot;Increase&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();
    let button_decrease = Button::builder()
        .label(&quot;Decrease&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(|_| number += 1);
    button_decrease.connect_clicked(|_| number -= 1);

    // Add buttons
    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
    window.set_child(Some(&amp;gtk_box));
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
    window.present();
}
</code></pre></pre>
<p>Here we would like to create a simple app with two buttons.
If we click on one button, an integer number should be increased. If we press the other one, it should be decreased.
The Rust compiler refuses to compile it though.</p>
<p>For once the borrow checker kicked in:</p>
<pre><code class="language-console">error[E0499]: cannot borrow `number` as mutable more than once at a time
  --&gt; main.rs:27:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ------------------------------------------------
   |     |                               |   |
   |     |                               |   first borrow occurs due to use of `number` in closure
   |     |                               first mutable borrow occurs here
   |     argument requires that `number` is borrowed for `'static`
27 |     button_decrease.connect_clicked(|_| number -= 1);
   |                                     ^^^ ------ second borrow occurs due to use of `number` in closure
   |                                     |
   |                                     second mutable borrow occurs here
</code></pre>
<p>Also, the compiler tells us that our closures may outlive <code>number</code>:</p>
<pre><code class="language-console">
error[E0373]: closure may outlive the current function, but it borrows `number`, which is owned by the current function
  --&gt; main.rs:26:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |                                     ^^^ ------ `number` is borrowed here
   |                                     |
   |                                     may outlive borrowed value `number`
   |
note: function requires argument type to outlive `'static`
  --&gt; main.rs:26:5
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `number` (and any other referenced variables), use the `move` keyword
   |
26 |     button_increase.connect_clicked(move |_| number += 1);
   |                                     ^^^^^^^^
</code></pre>
<p>Thinking about the second error message, it makes sense that the closure requires the lifetimes of references to be <code>'static</code>.
The compiler cannot know when the user presses a button, so references must live forever.
And our <code>number</code> gets immediately deallocated after it reaches the end of its scope.
The error message is also suggesting that we could take ownership of <code>number</code>.
But is there actually a way that both closures could take ownership of the same value?</p>
<p>Yes! That is exactly what the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> type is there for.
The <code>Rc</code> counts the number of strong references created via <code>Clone::clone</code> and released via <code>Drop::drop</code>, and only deallocates it when this number drops to zero.
We call every object containing a strong reference a shared owner of the value.
If we want to modify the content of our <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>,
we can use the <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> type.</p>
<blockquote>
<p>The <code>Cell</code> class is only suitable for objects that implement the <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a> trait.
For other objects, <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> is the way to go.
You can learn more about the two cell types in this <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/choosing-your-guarantees.html#cell-types">section</a> of an older edition of the Rust book.</p>
</blockquote>
<p><span class="filename">Filename: listings/gobject_memory_management/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Reference-counted object with inner-mutability
    let number = Rc::new(Cell::new(0));

    // Connect callbacks, when a button is clicked `number` will be changed
    let number_copy = number.clone();
    button_increase.connect_clicked(move |_| number_copy.set(number_copy.get() + 1));
    button_decrease.connect_clicked(move |_| number.set(number.get() - 1));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>It is not very nice though to fill the scope with temporary variables like <code>number_copy</code>.
We can improve that by using the <code>glib::clone!</code> macro.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` will be changed
</span>    button_increase.connect_clicked(clone!(@strong number =&gt; move |_| {
        number.set(number.get() + 1);
    }));
    button_decrease.connect_clicked(move |_| {
        number.set(number.get() - 1);
    });
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Just like <code>Rc&lt;Cell&lt;T&gt;&gt;</code>, GObjects are reference-counted and mutable.
Therefore, we can pass the buttons the same way to the closure as we did with <code>number</code>.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@weak number, @strong button_decrease =&gt;
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
    }));
    button_decrease.connect_clicked(clone!(@strong button_increase =&gt;
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
    }));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>If we now click on one button, the other button's label gets changed.</p>
<p>But whoops!
Did we forget about one annoyance of reference-counted systems?
Yes we did: <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycles</a>.
<code>button_increase</code> holds a strong reference to <code>button_decrease</code> and vice-versa.
A strong reference keeps the referenced value from being deallocated.
If this chain leads to a circle, none of the values in this cycle ever get deallocated.
With weak references we can break this cycle, because they do not keep their value alive but instead provide a way to retrieve a strong reference if the value is still alive.
Since we want our apps to free unneeded memory, we should use weak references for the buttons instead.</p>
<blockquote>
<p>In this simple example, GTK actually resolves the reference cycle on its own once you close the window.
However, the general point to avoid strong references whenever possible remains valid.</p>
</blockquote>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@weak number, @weak button_decrease =&gt;
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
    }));
    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
    }));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>The reference cycle is broken.
Every time the button is clicked, <code>glib::clone</code> tries to upgrade the weak reference.
If we now for example click on one button and the other button is not there anymore, <code>upgrade</code> will return <code>None</code>.
Per default, it immediately returns from the closure with <code>()</code> as return value.
In case the closure expects a different return value or a panic is preferred <code>@default-return</code> or <code>@default-panic</code>.
For more information about <code>glib::clone</code>, please have a look at the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.clone.html">docs</a>.</p>
<p>Notice that we move <code>number</code> in the second closure.
If we had only moved <em>weak</em> reference in both closures, nothing would have kept <code>number</code> alive and the closure would have never been called.
Thinking about this, <code>button_increase</code> and <code>button_decrease</code> are also dropped at the end of the scope of <code>build_ui</code>.
Who then keeps the buttons alive?</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@weak number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span>    // Add buttons to `gtk_box`
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .build();
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>When we append the buttons to the <code>gtk_box</code>, <code>gtk_box</code> keeps a strong reference to them.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@weak number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span>    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;gtk_box)
        .build();
<span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>When we set <code>gtk_box</code> as child of <code>window</code>, <code>window</code> keeps a strong reference to it.
Until we close the <code>window</code> it keeps <code>gtk_box</code> and with it the buttons alive.
Since our application has only one window, closing it also means exiting the application.</p>
<p>As long as you use weak references whenever possible you will find it perfectly doable to avoid memory cycles within your application.
If that is ensured, you can rely on GTK to properly manage the memory of GObjects you pass to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h1>
<p>GObjects rely heavily on inheritance.
Therefore, it makes sense that if we want to create a custom GObject, this is done via subclassing.
Let us see how this works by replacing the button in our &quot;Hello World!&quot; app with a custom one.</p>
<p>First, we need to create an implementation struct that holds the state and overrides the virtual methods.
It is advised to keep it in a private module, since its state and methods are only meant to be used by the GObject itself.
It therefore corresponds to the private section of objects in languages like Java and C++.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::glib;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {}
</code></pre>
<p>The description of the subclassing is in <code>ObjectSubclass</code>.</p>
<ul>
<li><code>NAME</code> should consist of crate-name, module-path and object-name in order to avoid name collisions. Use <a href="https://wiki.c2.com/?PascalCase">PascalCase</a> here.</li>
<li><code>Type</code> refers to the actual GObject that will be created afterwards.</li>
<li><code>ParentType</code> is the GObject we inherit of.</li>
</ul>
<p>After that, we would have the option to override the virtual methods of our ancestors.
Since we only want to have a plain button for now, we override nothing.
We still have to add the empty <code>impl</code> though.
Next, we describe our custom GObject.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/custom_button/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground">mod imp;

use glib::Object;
use gtk::glib;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        Object::new(&amp;[]).expect(&quot;Failed to create `CustomButton`.&quot;)
    }

    pub fn with_label(label: &amp;str) -&gt; Self {
        Object::new(&amp;[(&quot;label&quot;, &amp;label)]).expect(&quot;Failed to create `CustomButton`.&quot;)
    }
}
<span class="boring">
</span><span class="boring">impl Default for CustomButton {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.wrapper.html"><code>glib::wrapper!</code></a> does the most of the work of subclassing for us.
Coming from most other languages you would probably expect that you only have to mention the base class you want to inherit from.
However, as of today, subclassing of GObjects in Rust requires to mention all ancestors and interfaces apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.
For <code>gtk::Button</code>, we can look them up in the corresponding <a href="https://docs.gtk.org/gtk4/class.Button.html#hierarchy">doc page</a> of GTK4.</p>
<p>After these steps, nothing is stopping us anymore from replacing <code>gtk::Button</code> with our <code>CustomButton</code>.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">mod custom_button;

use custom_button::CustomButton;
use gtk::prelude::*;
use gtk::{Application, ApplicationWindow};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::with_label(&quot;Press me!&quot;);
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>We are able to use <code>CustomButton</code> as a drop-in replacement for <code>gtk::Button</code>.
This is cool, but also not very tempting to do in a real application.
For the gain of zero benefits, it did involve quite a bit of boilerplate after all.</p>
<p>So let us make it a bit more interesting!
<code>gtk::Button</code> does not hold much state, but we can let <code>CustomButton</code> hold a number.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/2/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::glib;
use gtk::prelude::*;
use gtk::subclass::prelude::*;
use std::cell::Cell;

// Object holding the state
#[derive(Default)]
pub struct CustomButton {
    number: Cell&lt;i32&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);
        obj.set_label(&amp;self.number.get().to_string());
    }
}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self, button: &amp;Self::Type) {
        self.number.set(self.number.get() + 1);
        button.set_label(&amp;self.number.get().to_string())
    }
}
</code></pre>
<p>We override <code>constructed</code> in <code>ObjectImpl</code> so that the label of the button initializes with <code>number</code>.
We also override <code>clicked</code> in <code>ButtonImpl</code> so that every click increases <code>number</code> and updates the label.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::new();
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>In <code>build_ui</code> we stop calling <code>connect_clicked</code>, and that was it.
After a rebuild, the app now features our <code>CustomButton</code> with the label &quot;0&quot;.
Every time we click on the button, the number displayed by the label increases by 1.</p>
<div style="text-align:center"><img src="img/gobject_subclassing.png" /></div>
<p>So, when do we want to inherit from GObject?</p>
<ul>
<li>We want to use a certain widget, but with added state and overridden virtual functions.</li>
<li>We want to pass a Rust object to a function, but the function expects a GObject.</li>
<li>We want to add properties or signals to an object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-values"><a class="header" href="#generic-values">Generic Values</a></h1>
<p>Some GObject-related functions rely on generic values for their arguments or return parameters.
Since GObject introspection works through a C interface, these functions cannot rely on any powerful Rust concepts.
In these cases <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html"><code>glib::Value</code></a> or <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/struct.Variant.html"><code>glib::Variant</code></a> are used.</p>
<h2 id="value"><a class="header" href="#value">Value</a></h2>
<p>Let us start with <code>Value</code>.
Conceptually, a <code>Value</code> is similar to a Rust <code>enum</code> defined like this:</p>
<pre><code class="language-rust  no_run noplayground">enum Value &lt;T&gt; {
    bool(bool),
    i8(i8),
    i32(i32),
    u32(u32),
    i64(i64),
    u64(u64),
    f32(f32),
    f64(f64),
    // boxed types
    String(Option&lt;String&gt;),
    Object(Option&lt;dyn IsA&lt;glib::Object&gt;&gt;),
}
</code></pre>
<p>For example, this is how you would use a <code>Value</code> representing an <code>i32</code>.</p>
<p><span class="filename">Filename: listings/gobject_values/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Value`
    let integer_value = 10.to_value();

    // Retrieve `i32` from `Value`
    let integer = integer_value
        .get::&lt;i32&gt;()
        .expect(&quot;The value needs to be of type `i32`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, &quot;Hello!&quot;.to_string());
</span><span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}
</span></code></pre>
<p>Also note that in the <code>enum</code> above boxed types such as <code>String</code> or <code>glib::Object</code> are wrapped in an <code>Option</code>.
This comes from C, where every boxed type can potentially be <code>None</code> (or <code>NULL</code> in C terms).
You can still access it the same way as with the <code>i32</code> above.
<code>get</code> will then not only return <code>Err</code> if you specified the wrong type, but also if the <code>Value</code> represents <code>None</code>.</p>
<p><span class="filename">Filename: listings/gobject_values/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    // Store string as `Value`
    let string_value = &quot;Hello!&quot;.to_value();

    // Retrieve `String` from `Value`
    let string = string_value
        .get::&lt;String&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(string, &quot;Hello!&quot;.to_string());
<span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}
</span></code></pre>
<p>If you want to differentiate between specifying the wrong type and a <code>Value</code> representing <code>None</code>, just call <code>get::&lt;Option&lt;T&gt;&gt;</code> instead.</p>
<p><span class="filename">Filename: listings/gobject_values/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, &quot;Hello!&quot;.to_string());
</span><span class="boring">
</span>    // Store `Option&lt;String&gt;` as `Value`
    let string_some_value = &quot;Hello!&quot;.to_value();
    let string_none_value = None::&lt;String&gt;.to_value();

    // Retrieve `String` from `Value`
    let string_some = string_some_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);
    let string_none = string_none_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
    assert_eq!(string_none, None);
<span class="boring">}
</span></code></pre>
<p>We will use <code>Value</code> when we deal with properties and signals later on.</p>
<h2 id="variant"><a class="header" href="#variant">Variant</a></h2>
<p>A <code>Variant</code> is used whenever data needs to be serialized, for example for sending it to another process or over the network, or for storing it on disk.
In that sense, a <code>Variant</code> is similar to a Rust object that implements <a href="https://docs.rs/serde/latest/serde/trait.Serialize.html"><code>serde::Serialize</code></a> and <a href="https://docs.rs/serde/latest/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.
It would be possible to add derive macros similar to the ones of <code>serde</code> for serializing/deserializing arbitrary Rust structs.
It is just that nobody did the work yet.
Pull requests to add this functionality would be very appreciated!</p>
<p>Although <code>GVariant</code> supports arbitrarily complex types, the Rust bindings are currently limited to <code>bool</code>, <code>u8</code>, <code>i16</code>, <code>u16</code>, <code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f64</code>, <code>&amp;str</code>/<code>String</code>, and <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.VariantDict.html"><code>VariantDict</code></a>.
Containers of the above types are possible as well, such as <code>HashMap</code>, <code>Vec</code>, <code>Option</code>, tuples up to 16 elements, and <code>Variant</code>.
These can even be arbitrarily nested like e.g. <code>HashMap&lt;Option&lt;u32&gt;, Vec&lt;HashMap&lt;String, Variant&gt;&gt;&gt;</code>.</p>
<p>In the most simple case, converting Rust types to <code>Variant</code> and vice-versa is very similar to the way it worked with <code>Value</code>.</p>
<p><span class="filename">Filename: listings/gobject_values/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Variant`
    let integer_variant = 10.to_variant();

    // Retrieve `i32` from `Variant`
    let integer = integer_variant
        .get::&lt;i32&gt;()
        .expect(&quot;The variant needs to be of type `i32`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    let variant = vec![&quot;Hello&quot;, &quot;there!&quot;].to_variant();
</span><span class="boring">    assert_eq!(variant.n_children(), 2);
</span><span class="boring">    let vec = &amp;variant
</span><span class="boring">        .get::&lt;Vec&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The variant needs to be of type `String`.&quot;);
</span><span class="boring">    assert_eq!(vec[0], &quot;Hello&quot;);
</span><span class="boring">}
</span></code></pre>
<p>However, a <code>Variant</code> is also able to represent containers such as <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> or <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>.
The following snippet shows how to convert between <code>Vec</code> and <code>Variant</code>.
More examples can be found in the <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/index.html">docs</a>.</p>
<p><span class="filename">Filename: listings/gobject_values/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Variant`
</span><span class="boring">    let integer_variant = 10.to_variant();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Variant`
</span><span class="boring">    let integer = integer_variant
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The variant needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    let variant = vec![&quot;Hello&quot;, &quot;there!&quot;].to_variant();
    assert_eq!(variant.n_children(), 2);
    let vec = &amp;variant
        .get::&lt;Vec&lt;String&gt;&gt;()
        .expect(&quot;The variant needs to be of type `String`.&quot;);
    assert_eq!(vec[0], &quot;Hello&quot;);
<span class="boring">}
</span></code></pre>
<p>We will use <code>Variant</code> when saving settings using <code>gio::Settings</code> or activating actions via <code>gio::Action</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<p>Properties provide a public API for accessing state of GObjects.</p>
<p>Let us see how this is done by experimenting with the <code>Switch</code> widget.
One of its properties is the <a href="https://docs.gtk.org/gtk4/property.Switch.state.html">state</a>.
According to the GTK docs, it can be read and be written to.
That is why <code>gtk-rs</code> provides corresponding <a href="../docs/gtk4/struct.Switch.html#method.state"><code>state</code></a> and <a href="../docs/gtk4/struct.Switch.html#method.set_state"><code>set_state</code></a> methods.</p>
<p><span class="filename">Filename: listings/gobject_properties/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Box, Orientation, Switch};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain state
    switch.set_state(true);
    let current_state = switch.state();

    // This prints: &quot;The current state is true&quot;
    println!(&quot;The current state is {}&quot;, current_state);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Alternatively, we can use the general <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.property"><code>property</code></a> and <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.set_property"><code>set_property</code></a> methods.
We use the <a href="https://matematikaadit.github.io/posts/rust-turbofish.html">turbofish</a> syntax to specify the type if it cannot be inferred.</p>
<p><span class="filename">Filename: listings/gobject_properties/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Box, Orientation, Switch};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain state
    switch.set_property(&quot;state&quot;, &amp;true);
    let current_state = switch.property::&lt;bool&gt;(&quot;state&quot;);

    // This prints: &quot;The current state is true&quot;
    println!(&quot;The current state is {}&quot;, current_state);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Both <code>property</code> and <code>set_property</code> panic if the property does not exist, has the wrong type or has the wrong permissions.
This is fine in most situations where these cases are hardcoded within the program.
If this does not apply for your program you might want to use <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.try_property"><code>try_property</code></a> and <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.try_set_property"><code>try_set_property</code></a> instead.</p>
<p>Properties can not only be accessed via getters &amp; setters, they can also be bound to each other.
Let us see how that would look like for two <code>Switch</code> instances.</p>
<p><span class="filename">Filename: listings/gobject_properties/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switches
    let switch_1 = Switch::new();
    let switch_2 = Switch::new();
<span class="boring">
</span><span class="boring">    switch_1
</span><span class="boring">        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>In our case, we want to bind the &quot;state&quot; property of <code>switch_1</code> to the &quot;state&quot; property of <code>switch_2</code>.
We also want the binding to be bidirectional, so we specify this with the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html"><code>BindingFlags</code></a>.</p>
<p><span class="filename">Filename: listings/gobject_properties/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the switches
</span><span class="boring">    let switch_1 = Switch::new();
</span><span class="boring">    let switch_2 = Switch::new();
</span><span class="boring">
</span>    switch_1
        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
        .flags(BindingFlags::BIDIRECTIONAL)
        .build();
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Now when we click on one of the two switches, the other one is toggled as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_switches.png" /></div>
<h2 id="adding-properties-to-custom-gobjects"><a class="header" href="#adding-properties-to-custom-gobjects">Adding Properties to Custom GObjects</a></h2>
<p>We can also add properties to custom GObjects.
We can demonstrate that by binding the <code>number</code> of our <code>CustomButton</code> to a property.
For that we need to be able to <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily evaluate</a> expressions.
The crate <code>once_cell</code> provides the <code>Lazy</code> type which allows us to do that.
<code>once_cell</code> is already part of Rust nightly.
Until it hits stable, we will add it as external dependency.</p>
<p><span class="filename">Filename: listings/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
once_cell = &quot;1&quot;
</code></pre>
<p>Now we define the &quot;number&quot; property within the <code>ObjectImpl</code> implementation.
The <code>properties</code> method describes our set of properties.
When naming our property, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
Then we describe its type, range and default value.
We also declare that the property can be read and be written to.
<code>set_property</code> describes how the underlying values can be changed.
<code>property</code> takes care of returning the underlying value.
The formerly private <code>number</code> is now accessible via the <code>property</code> and <code>set_property</code> methods.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, ParamSpecInt, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn properties() -&gt; &amp;'static [ParamSpec] {
        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
            vec![ParamSpecInt::new(
                // Name
                &quot;number&quot;,
                // Nickname
                &quot;number&quot;,
                // Short description
                &quot;number&quot;,
                // Minimum value
                i32::MIN,
                // Maximum value
                i32::MAX,
                // Default value
                0,
                // The property can be read and written to
                ParamFlags::READWRITE,
            )]
        });
        PROPERTIES.as_ref()
    }

    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
        match pspec.name() {
            &quot;number&quot; =&gt; {
                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
                self.number.replace(input_number);
            }
            _ =&gt; unimplemented!(),
        }
    }

    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
        match pspec.name() {
            &quot;number&quot; =&gt; self.number.get().to_value(),
            _ =&gt; unimplemented!(),
        }
    }

    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);

        // Bind label to number
        // `SYNC_CREATE` ensures that the label will be immediately set
        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">        let incremented_number = self.number.get() + 1;
</span><span class="boring">        button.set_property(&quot;number&quot;, &amp;incremented_number);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We can immediately take advantage of this new property by binding the &quot;label&quot; property to it.
It even converts the integer value of &quot;number&quot; to the string of &quot;label&quot;.
Now we do not have to adapt the label in the &quot;clicked&quot; callback anymore.</p>
<p>Let us see what we can do with this by creating two custom buttons.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the buttons
    let button_1 = CustomButton::new();
    let button_2 = CustomButton::new();
<span class="boring">
</span><span class="boring">    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
</span><span class="boring">        .transform_to(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
</span><span class="boring">        .transform_from(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">        println!(&quot;The current number of `button_1` is {}.&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>We have already seen that bound properties do not necessarily have to be of the same type.
By leveraging <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_to"><code>transform_to</code></a> and <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_from"><code>transform_from</code></a>, we can assure that <code>button_2</code> always displays a number which is 1 higher than the number of <code>button_1</code>.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span>    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
    button_1
        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
        .transform_to(|_, value| {
            let number = value
                .get::&lt;i32&gt;()
                .expect(&quot;The property needs to be of type `i32`.&quot;);
            let incremented_number = number + 1;
            Some(incremented_number.to_value())
        })
        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
        .transform_from(|_, value| {
            let number = value
                .get::&lt;i32&gt;()
                .expect(&quot;The property needs to be of type `i32`.&quot;);
            let decremented_number = number - 1;
            Some(decremented_number.to_value())
        })
        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
        .build();
<span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">        println!(&quot;The current number of `button_1` is {}.&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Now if we click on one button, the &quot;number&quot; and &quot;label&quot; properties of the other button change as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_buttons.png"/></div>
<p>The final nice feature of properties is, that you can connect a callback to the event when a property gets changed.
We can do this like this:</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
</span><span class="boring">        .transform_to(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
</span><span class="boring">        .transform_from(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // The closure will be called
    // whenever the property &quot;number&quot; of `button_1` gets changed
    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
        let number = button.property::&lt;i32&gt;(&quot;number&quot;);
        println!(&quot;The current number of `button_1` is {}.&quot;, number);
    });
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Now, whenever the &quot;number&quot; property gets changed, the closure gets executed and prints the current value of &quot;number&quot;.</p>
<p>Introducing properties to your custom GObjects is useful if you want to</p>
<ul>
<li>allow consumers to be able to access internal state</li>
<li>bind state of (different) GObjects</li>
<li>notify consumers whenever a property value changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>GObject signals are a system for registering callbacks for specific events.
For example, if we press on a button, the &quot;clicked&quot; signal will be emitted.
The signal then takes care that all the registered callbacks will be executed.</p>
<p><code>gtk-rs</code> provides convenience methods for registering callbacks.
In our &quot;Hello World&quot; example we <a href="../docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked">connected</a> the &quot;clicked&quot; signal to a closure which sets the label of the button to &quot;Hello World&quot; as soon as it gets called.</p>
<p><span class="filename">Filename: listings/gobject_signals/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>If we wanted to, we could have 
connected to it with the generic <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect_local"><code>connect_local</code></a> method.</p>
<p><span class="filename">Filename: listings/gobject_signals/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_local(&quot;clicked&quot;, false, move |args| {
        // Get the button from the arguments
        let button = args[0]
            .get::&lt;Button&gt;()
            .expect(&quot;The value needs to be of type `Button`.&quot;);
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
        None
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Similar to the generic way of accessing properties, the advantage of <code>connect_local</code> is that it also works with custom signals.</p>
<blockquote>
<p>If you want to connect from a different thread than the main thread, make sure to use <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect"><code>connect</code></a> instead of <code>connect_local</code>. However, that also means that your connected closure has to implement <a href="https://doc.rust-lang.org/stable/core/marker/trait.Send.html"><code>Send</code></a> + <a href="https://doc.rust-lang.org/stable/core/marker/trait.Sync.html"><code>Sync</code></a>.</p>
</blockquote>
<h2 id="adding-signals-to-custom-gobjects"><a class="header" href="#adding-signals-to-custom-gobjects">Adding Signals to Custom GObjects</a></h2>
<p>Let us see how we can create our own signals.
Again we do that by extending our <code>CustomButton</code>.
First we override the necessary methods in <code>ObjectImpl</code>.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, ParamSpecInt, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn signals() -&gt; &amp;'static [Signal] {
        static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
            vec![Signal::builder(
                // Signal name
                &quot;max-number-reached&quot;,
                // Types of the values which will be sent to the signal handler
                &amp;[i32::static_type().into()],
                // Type of the value the signal handler sends back
                &lt;()&gt;::static_type().into(),
            )
            .build()]
        });
        SIGNALS.as_ref()
    }
<span class="boring">
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![ParamSpecInt::new(
</span><span class="boring">                // Name
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Nickname
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Short description
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Minimum value
</span><span class="boring">                i32::MIN,
</span><span class="boring">                // Maximum value
</span><span class="boring">                i32::MAX,
</span><span class="boring">                // Default value
</span><span class="boring">                0,
</span><span class="boring">                // The property can be read and written to
</span><span class="boring">                ParamFlags::READWRITE,
</span><span class="boring">            )]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; {
</span><span class="boring">                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">                self.number.replace(input_number);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; self.number.get().to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">static MAX_NUMBER: i32 = 8;
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">        let incremented_number = self.number.get() + 1;
</span><span class="boring">        // If `number` reached `MAX_NUMBER`,
</span><span class="boring">        // emit &quot;max-number-reached&quot; signal and set `number` back to 0
</span><span class="boring">        if incremented_number == MAX_NUMBER {
</span><span class="boring">            button.emit_by_name::&lt;()&gt;(&quot;max-number-reached&quot;, &amp;[&amp;incremented_number]);
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;0);
</span><span class="boring">        } else {
</span><span class="boring">            button.set_property(&quot;number&quot;, &amp;incremented_number);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
</code></pre>
<p>The <code>signals</code> method is responsible for defining a set of signals.
In our case, we only create a single signal named &quot;max-number-reached&quot;.
When naming our signal, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
When emitted, it sends a single <code>i32</code> value and expects nothing in return.</p>
<p>We want the signal to be emitted, whenever <code>number</code> reaches <code>MAX_NUMBER</code>.
Together with the signal we send the value <code>number</code> currently holds.
After we did that, we set <code>number</code> back to 0.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, ParamSpecInt, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn signals() -&gt; &amp;'static [Signal] {
</span><span class="boring">        static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![Signal::builder(
</span><span class="boring">                // Signal name
</span><span class="boring">                &quot;max-number-reached&quot;,
</span><span class="boring">                // Types of the values which will be sent to the signal handler
</span><span class="boring">                &amp;[i32::static_type().into()],
</span><span class="boring">                // Type of the value the signal handler sends back
</span><span class="boring">                &lt;()&gt;::static_type().into(),
</span><span class="boring">            )
</span><span class="boring">            .build()]
</span><span class="boring">        });
</span><span class="boring">        SIGNALS.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![ParamSpecInt::new(
</span><span class="boring">                // Name
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Nickname
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Short description
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Minimum value
</span><span class="boring">                i32::MIN,
</span><span class="boring">                // Maximum value
</span><span class="boring">                i32::MAX,
</span><span class="boring">                // Default value
</span><span class="boring">                0,
</span><span class="boring">                // The property can be read and written to
</span><span class="boring">                ParamFlags::READWRITE,
</span><span class="boring">            )]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; {
</span><span class="boring">                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">                self.number.replace(input_number);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; self.number.get().to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>static MAX_NUMBER: i32 = 8;

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self, button: &amp;Self::Type) {
        let incremented_number = self.number.get() + 1;
        // If `number` reached `MAX_NUMBER`,
        // emit &quot;max-number-reached&quot; signal and set `number` back to 0
        if incremented_number == MAX_NUMBER {
            button.emit_by_name::&lt;()&gt;(&quot;max-number-reached&quot;, &amp;[&amp;incremented_number]);
            button.set_property(&quot;number&quot;, &amp;0);
        } else {
            button.set_property(&quot;number&quot;, &amp;incremented_number);
        }
    }
}

</code></pre>
<p>If we now press on the button, the number of its label increases until it reaches <code>MAX_NUMBER</code>.
Then it emits the &quot;max-number-reached&quot; signal which we can nicely connect to.
Whenever we now receive the &quot;max-number-reached&quot; signal, the accompanying number is printed to standard output.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span>    button.connect_local(&quot;max-number-reached&quot;, false, move |args| {
        // Get the number from the arguments
        // args[0] would return the `CustomButton` instance
        let number = args[1]
            .get::&lt;i32&gt;()
            .expect(&quot;The value needs to be of type `i32`.&quot;);
        println!(&quot;The maximum number {} has been reached&quot;, number);
        None
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>You now know how to connect to every kind of signal and how to create your own.
Custom signals are especially useful, if you want to notify consumers of your GObject that a certain event occurred.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-main-event-loop"><a class="header" href="#the-main-event-loop">The Main Event Loop</a></h1>
<p>We now got comfortable using callbacks, but how do they actually work?
All of this happens asynchronously, so there must be something managing the events and scheduling the responses.
Unsurprisingly, this is called the main event loop.</p>
<div style="text-align:center"><img src="img/main_event_loop.png" /></div>
<p>The main loop manages all kinds of events — from mouse clicks and keyboard presses to file events.
It does all of that within the same thread.
Quickly iterating between all tasks gives the illusion of parallelism.
That is why you can move the window at the same time as a progress bar is growing.</p>
<p>However, you surely saw GUIs that became unresponsive, at least for a few seconds.
That happens when a single task takes too long.
Let us look at one example.</p>
<p><span class="filename">Filename: listings/main_event_loop/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindow, Button};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        std::thread::sleep(five_seconds);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>After we press the button, the GUI is completely frozen for five seconds.
We can't even move the window.
The <code>sleep</code> call is an artificial example,
but it is not unusual wanting to run a slightly longer operation in one go.</p>
<h2 id="how-to-avoid-blocking-the-main-loop"><a class="header" href="#how-to-avoid-blocking-the-main-loop">How to Avoid Blocking the Main Loop</a></h2>
<p>In order to avoid blocking the main loop we can spawn a new thread and let the operation run there.</p>
<p><span class="filename">Filename: listings/main_event_loop/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>If you come from another language than Rust, you might be uncomfortable with the thought of spawning new threads before even looking at other options.
Luckily, Rust's safety guarantees allow you to stop worrying about the nasty bugs that concurrency tends to bring.</p>
<p>Normally we want to keep track of the work in the thread.
In our case, we don't want the user to spawn additional threads while an existing one is still running.
In order to achieve that we can create a channel.
The main loop allows us to send a message from multiple places to a single receiver at the main thread.
We want to send a <code>bool</code> to inform, whether we want the button to react to clicks or not.</p>
<p><span class="filename">Filename: listings/main_event_loop/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            sender.send(false).expect(&quot;Could not send through channel&quot;);
            let ten_seconds = Duration::from_secs(10);
            thread::sleep(ten_seconds);
            // Activate the button again
            sender.send(true).expect(&quot;Could not send through channel&quot;);
        });
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Spawning threads is not the only way to run operations asynchronously.
You can also let the main loop take care of running <code>async</code> functions.
If you do that from the main thread use <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html#method.spawn_local"><code>spawn_local</code></a>, from other threads <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html#method.spawn"><code>spawn</code></a> has to be used.
The converted code looks and behaves very similar to the multi-threaded code.</p>
<p><span class="filename">Filename: listings/main_event_loop/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{clone, timeout_future_seconds, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |_| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@strong sender =&gt; async move {
            // Deactivate the button until the operation is done
            sender.send(false).expect(&quot;Could not send through channel&quot;);
            timeout_future_seconds(5).await;
            // Activate the button again
            sender.send(true).expect(&quot;Could not send through channel&quot;);
        }));
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Since we are single-threaded again, we could even get rid of the channels while achieving the same result.</p>
<p><span class="filename">Filename: listings/main_event_loop/5/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{clone, timeout_future_seconds, MainContext};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@weak button =&gt; async move {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            timeout_future_seconds(5).await;
            // Activate the button again
            button.set_sensitive(true);
        }));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>But why did we not do the same thing with our multi-threaded example?</p>
<pre><pre class="playground"><code class="language-rust  no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">       .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE
    
    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Simply because we would get this error message:</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>After reference cycles we found the second disadvantage of GTK GObjects: They are not thread safe.</p>
<p>So when should you spawn an <code>async</code> block and when should you spawn a thread?</p>
<ul>
<li>If you have <code>async</code> functions for your IO-bound operations at your disposal, feel free to spawn them on the main loop.</li>
<li>If your operation is computation-bound or there is no <code>async</code> function available, you have to spawn threads.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>We have now learned multiple ways to handle states.
However, every time we close the application all of it is gone.
Let us learn how to use <code>GSettings</code> by storing the state of a <a href="../docs/gtk4/struct.Switch.html"><code>Switch</code></a> in it.</p>
<p>At the very beginning we have to create a <code>GSchema</code> xml file in order to describe the kind of data our application plans to store in the settings.</p>
<p><span class="filename">Filename: listings/settings/1/org.gtk-rs.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk-rs.example&quot; path=&quot;/org/gtk-rs/example/&quot;&gt;
    &lt;key name=&quot;is-switch-enabled&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default switch state&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Let us get through it step by step.
The <code>id</code> is the same application id we used when we created our application.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();
<span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk-rs.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>The <code>path</code> must start and end with a forward slash character ('/') and must not contain two sequential slash characters.
When creating a <code>path</code>, we advise to take the <code>id</code>, replace the '.' with '/' and add '/' at the front and end of it.</p>
<p>We only want to store a single key with the <code>name</code> &quot;is-switch-enabled&quot;.
This is a boolean value so its <code>type</code> is &quot;b&quot; (see <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant Format Strings</a> for the other options).
Finally, we define its default value and add a summary.</p>
<p>Now we need to copy and compile the schema.
As of right now, <code>cargo</code> is not suitable for that task which is why you will need another build system on top of it.
You can find an example on how to do this with <a href="https://mesonbuild.com/"><code>meson</code></a> in the <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template"><code>gtk-rust-template</code></a>.</p>
<blockquote>
<p>However, we promised that <code>cargo</code> alone is enough to follow the book.
For local testing, you can install the schema by executing the following commands on a Linux or macOS machine:</p>
<pre><code class="language-bash">sudo cp org.gtk-rs.example.gschema.xml /usr/share/glib-2.0/schemas/
sudo glib-compile-schemas /usr/share/glib-2.0/schemas/
</code></pre>
<p>On Windows run:</p>
<pre><code class="language-powershell">cp org.gtk-rs.example.gschema.xml C:/ProgramData/glib-2.0/schemas/
glib-compile-schemas C:/ProgramData/glib-2.0/schemas/
</code></pre>
</blockquote>
<p>We initialize the <code>Settings</code> object by specifying the application id.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Initialize settings
    let settings = Settings::new(&quot;org.gtk-rs.example&quot;);
<span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Then we get the settings key and use it when we create our <code>Switch</code>.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk-rs.example&quot;);
</span><span class="boring">
</span>    // Get the last switch state from the settings
    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);

    // Create a switch
    let switch = Switch::builder()
        .margin_top(48)
        .margin_bottom(48)
        .margin_start(48)
        .margin_end(48)
        .valign(Align::Center)
        .halign(Align::Center)
        .state(is_switch_enabled)
        .build();
<span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Finally, we assure that the switch state is stored in the settings whenever we click on it.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk-rs.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    switch.connect_state_set(move |_, is_enabled| {
        // Save changed switch state in the settings
        settings
            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
            .expect(&quot;Could not set setting.&quot;);
        // Do not inhibit the default handler
        Inhibit(false)
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>The <code>Switch</code> now retains its state even after closing the application.
But we can make this even better.
The <code>Switch</code> has a property &quot;state&quot; and <code>Settings</code> allows us to bind properties to a specific setting.
So let us do exactly that.</p>
<p>We can remove the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/trait.SettingsExt.html#tymethod.boolean"><code>boolean</code></a> call before initializing the <code>Switch</code> as well as the <code>connect_state_set</code> call.
We then bind the setting to the property by specifying the key, object and name of the property.
Additionally, we specify <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.SettingsBindFlags.html"><code>SettingsBindFlags</code></a> to control the direction in which the binding works.</p>
<p><span class="filename">Filename: listings/settings/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::{Settings, SettingsBindFlags};
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk-rs.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    settings
        .bind(&quot;is-switch-enabled&quot;, &amp;switch, &quot;state&quot;)
        .flags(SettingsBindFlags::DEFAULT)
        .build();
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Whenever you have a property which nicely correspond to a setting, you probably want to bind it to it.
In other cases, interacting with the settings via the getter and setter methods tends to be the right choice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-window-state"><a class="header" href="#saving-window-state">Saving Window State</a></h1>
<p>Quite often, we want the window state to persist between sessions.
If the user resizes or maximizes the window, they might expect to find it in the same state the next time they open the app.
GTK does not provide this functionality out of the box, but luckily it is not too hard to manually implement it.
We basically want two integers (<code>height</code> &amp; <code>width</code>) and a boolean (<code>is_maximized</code>) to persist.
We already know how to do this by using <code>Settings</code>.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/org.gtk-rs.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk-rs.example&quot; path=&quot;/org/gtk-rs/example/&quot;&gt;
    &lt;key name=&quot;window-width&quot; type=&quot;i&quot;&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window width&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name=&quot;window-height&quot; type=&quot;i&quot;&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window height&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name=&quot;is-maximized&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default window maximized behaviour&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Since we do not care about intermediate state, we only load the window state when the window is constructed and save it when we close the window.
That can be done by creating a custom window.
First, we create one and add methods for getting and setting the window state.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/custom_window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
    }

    pub fn save_window_size(&amp;self) -&gt; Result&lt;(), glib::BoolError&gt; {
        // Get `settings` from `imp::Window`
        let settings = &amp;self.imp().settings;

        // Get the size of the window
        let size = self.default_size();

        // Set the window state in `settings`
        settings.set_int(&quot;window-width&quot;, size.0)?;
        settings.set_int(&quot;window-height&quot;, size.1)?;
        settings.set_boolean(&quot;is-maximized&quot;, self.is_maximized())?;

        Ok(())
    }

    fn load_window_size(&amp;self) {
        // Get `settings` from `imp::Window`
        let settings = &amp;self.imp().settings;

        // Get the window state from `settings`
        let width = settings.int(&quot;window-width&quot;);
        let height = settings.int(&quot;window-height&quot;);
        let is_maximized = settings.boolean(&quot;is-maximized&quot;);

        // Set the size of the window
        self.set_default_size(width, height);

        // If the window was maximized when it was closed, maximize it again
        if is_maximized {
            self.maximize();
        }
    }
}

</code></pre>
<p>The implementation struct holds the <code>settings</code>.
We also override the <code>constructed</code> and <code>close_request</code> methods, where we load or save the window state. </p>
<p><span class="filename">Filename: listings/saving_window_state/1/custom_window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{subclass::prelude::*, ApplicationWindow};
</span><span class="boring">
</span>pub struct Window {
    pub settings: Settings,
}

#[glib::object_subclass]
impl ObjectSubclass for Window {
    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
    type Type = super::Window;
    type ParentType = ApplicationWindow;

    fn new() -&gt; Self {
        Self {
            settings: Settings::new(&quot;org.gtk-rs.example&quot;),
        }
    }
}
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);
        // Load latest window state
        obj.load_window_size();
    }
}
impl WidgetImpl for Window {}
impl WindowImpl for Window {
    // Save window state right before the window will be closed
    fn close_request(&amp;self, obj: &amp;Self::Type) -&gt; Inhibit {
        if let Err(err) = obj.save_window_size() {
            log::error!(&quot;Failed to save window state, {}&quot;, &amp;err);
        }
        // Do not inhibit the default handler
        Inhibit(false)
    }
}
impl ApplicationWindowImpl for Window {}

</code></pre>
<p>That is it!
Now our window retains its state between app sessions.</p>
<p>Please note how we handle a failure in saving into the settings.
We do not want to panic for recoverable errors.
We might also not want to present all problems at the GUI.
In our case we could not even do this, because the window will be immediately closed after the error occurs.
Logging is the standard way of handling a situation like this.
For that, we need to add the <code>log</code> crate and one of its front-ends, such as <code>pretty_env_logger</code>, to our dependencies.</p>
<p><span class="filename">Filename: listings/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;
pretty_env_logger = &quot;0.4&quot;
</code></pre>
<p>We then have to initialize <code>pretty_env_logger</code> by calling <code>init</code> in <code>main</code>.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_window;
</span><span class="boring">
</span><span class="boring">use custom_window::Window;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, Button};
</span><span class="boring">
</span>fn main() {
    // Initialize logger
    pretty_env_logger::init();

    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>We can now modify the log level by setting the <code>RUST_LOG</code> environment variable as can be seen <a href="https://docs.rs/env_logger/latest/env_logger/">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-widgets"><a class="header" href="#list-widgets">List Widgets</a></h1>
<p>Sometimes you want to display a list of elements in a certain arrangement.
<a href="../docs/gtk4/struct.ListBox.html"><code>ListBox</code></a> and <a href="../docs/gtk4/struct.FlowBox.html"><code>FlowBox</code></a> are two container widgets which allow you to do this.
<code>ListBox</code> describes a vertical list and <code>FlowBox</code> describes a grid.</p>
<p>Let us explore this concept by adding labels to a <code>ListBox</code>.
Each label will display an integer starting from 0 and ranging up to 100.</p>
<p><span class="filename">Filename: listings/list_widgets/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&amp;number.to_string()));
        list_box.append(&amp;label);
    }
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>We cannot display so many widgets at once.
Therefore, we add <code>ListBox</code> to a <a href="../docs/gtk/struct.ScrolledWindow.html"><code>ScrolledWindow</code></a>.
Now we can scroll through our elements.</p>
<p><span class="filename">Filename: listings/list_widgets/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `ListBox` and add labels with integers from 0 to 100
</span><span class="boring">    let list_box = ListBox::new();
</span><span class="boring">    for number in 0..=100 {
</span><span class="boring">        let label = Label::new(Some(&amp;number.to_string()));
</span><span class="boring">        list_box.append(&amp;label);
</span><span class="boring">    }
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_box)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}
</span></code></pre>
<div style="text-align:center"><img src="img/lists_list_box.png"/></div>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>That was easy enough.
However, we currently create one widget per element.
Since each widget takes up a bit of resources, many of them can lead to slow and unresponsive user interfaces.
Depending on the widget type even thousands of elements might not be a problem.
But how could we possibly deal with the infinite amount of posts in a social media timeline?</p>
<p>We use scalable lists instead!</p>
<ul>
<li>The <strong>model</strong> holds our data, filters it and describes its order.</li>
<li>The <strong>list item factory</strong> defines how the data transforms into widgets.</li>
<li>The <strong>view</strong> specifies how the widgets are then arranged.</li>
</ul>
<p>What makes this concept scalable is that GTK only has to create slightly more widgets than we can currently look at.
As we scroll through our elements, the widgets which become invisible will be reused.
The following figure demonstrates how this works in practice.</p>
<div style="text-align:center"><img src="img/scalable_lists_concept.png"/></div>
<p>100 000 elements is something <code>ListBox</code> will struggle with, so let us use this to demonstrate scalable lists.</p>
<p>We start by defining and filling up our model.
The model is an instance of <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
The main limitation here is that <code>gio::ListStore</code> only accepts GObjects.
What we would need is a GObject which holds an integer and exposes it as property.
To get that we just have to adapt the <code>CustomButton</code> we created in the subclassing <a href="gobject_subclassing.html">chapter</a>.
We only need to let it inherit from GObject instead of <code>Button</code> and let the <code>new</code> method accept an integer as parameter.</p>
<p><span class="filename">Filename: listings/list_widgets/2/integer_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
}

impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::new(&amp;[(&quot;number&quot;, &amp;number)]).expect(&quot;Failed to create `IntegerObject`.&quot;)
    }
}
<span class="boring">
</span></code></pre>
<p>The <code>imp</code> module can stay the same apart from the rename from <code>CustomButton</code> to <code>IntegerObject</code>.</p>
<p><span class="filename">Filename: listings/list_widgets/2/integer_object/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{ParamFlags, ParamSpec, ParamSpecInt, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct IntegerObject {
    number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for IntegerObject {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppIntegerObject&quot;;
</span><span class="boring">    type Type = super::IntegerObject;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for IntegerObject {
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![ParamSpecInt::new(
</span><span class="boring">                // Name
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Nickname
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Short description
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Minimum value
</span><span class="boring">                i32::MIN,
</span><span class="boring">                // Maximum value
</span><span class="boring">                i32::MAX,
</span><span class="boring">                // Default value
</span><span class="boring">                0,
</span><span class="boring">                // The property can be read and written to
</span><span class="boring">                ParamFlags::READWRITE,
</span><span class="boring">            )]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; {
</span><span class="boring">                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">                self.number.replace(input_number);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; self.number.get().to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span></code></pre>
<p>We now fill the model with integers from 0 to 100 000.
Please note that models only takes care of the data.
Neither <code>Label</code> nor any other widget is mentioned here.</p>
<p><span class="filename">Filename: listings/list_widgets/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();

    // Create new model
    let model = gio::ListStore::new(IntegerObject::static_type());

    // Add the vector to the model at position 0 and 0 removals
    model.splice(0, 0, &amp;vector);
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>The <code>ListItemFactory</code> takes care of the widgets as well as their relationship to the model.
Here, we use the <a href="../docs/gtk4/struct.SignalListItemFactory.html"><code>SignalListItemFactory</code></a> which emits a signal for every relevant step in the life of a <a href="../docs/gtk4/struct.ListItem.html"><code>ListItem</code></a>.
The &quot;setup&quot; signal will be emitted when new widgets have to be created.
We connect to it to create a <code>Label</code> for every requested widget.</p>
<p><span class="filename">Filename: listings/list_widgets/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span>    let factory = SignalListItemFactory::new();
    factory.connect_setup(move |_, list_item| {
        let label = Label::new(None);
        list_item.set_child(Some(&amp;label));
    });
<span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>In the &quot;bind&quot; step we bind the data in our model to the individual list items.</p>
<p><span class="filename">Filename: listings/list_widgets/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .item()
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Get `i32` from `IntegerObject`
        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);

        // Get `Label` from `ListItem`
        let label = list_item
            .child()
            .expect(&quot;The child has to exist.&quot;)
            .downcast::&lt;Label&gt;()
            .expect(&quot;The child has to be a `Label`.&quot;);

        // Set &quot;label&quot; to &quot;number&quot;
        label.set_label(&amp;number.to_string());
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>We only want single items to be selectable, so we choose <a href="../docs/gtk4/struct.SingleSelection.html"><code>SingleSelection</code></a>.
The other options would have been <a href="../docs/gtk4/struct.MultiSelection.html"><code>MultiSelection</code></a> or <a href="../docs/gtk4/struct.NoSelection.html"><code>NoSelection</code></a>.
Then we pass the model and the factory to the <a href="../docs/gtk4/struct.ListView.html"><code>ListView</code></a>.</p>
<p><span class="filename">Filename: listings/list_widgets/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span>    let selection_model = SingleSelection::new(Some(&amp;model));
    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Every <code>ListView</code> has to be a direct child of a <code>ScrolledWindow</code>, so we are adding it to one.</p>
<p><span class="filename">Filename: listings/list_widgets/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_view)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}
</span></code></pre>
<p>We can now easily scroll through our long list of integers.</p>
<div style="text-align:center"><img src="img/lists_list_view_1.png"/></div>
<p>Let us see what else we can do.
We might want to increase the number every time we activate its row.
For that we first add the method <code>increase_number</code> to our <code>IntegerObject</code>.</p>
<p><span class="filename">Filename: listings/list_widgets/3/integer_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::new(&amp;[(&quot;number&quot;, &amp;number)]).expect(&quot;Failed to create `IntegerObject`.&quot;)
    }

    pub fn increase_number(self) {
        let old_number = self.property::&lt;i32&gt;(&quot;number&quot;);
        self.set_property(&quot;number&quot;, old_number + 1);
    }
}
</code></pre>
<p>In order to interact with our <code>ListView</code>, we connect to its &quot;activate&quot; signal.</p>
<p><span class="filename">Filename: listings/list_widgets/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Bind &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        integer_object
</span><span class="boring">            .bind_property(&quot;number&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
        let integer_object = model
            .item(position)
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Increase &quot;number&quot; of `IntegerObject`
        integer_object.increase_number();
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Now every time we activate an element, for example by double-clicking on it,
the corresponding &quot;number&quot; property of the <code>IntegerObject</code> in the model will be increased by 1.
However, just because the <code>IntegerObject</code> has been modified the corresponding <code>Label</code> does not immediately change.
One naive approach would be to bind the properties in the &quot;bind&quot; step of the <code>SignalListItemFactory</code>.</p>
<p><span class="filename">Filename: listings/list_widgets/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .item()
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Get `Label` from `ListItem`
        let label = list_item
            .child()
            .expect(&quot;The child has to exist.&quot;)
            .downcast::&lt;Label&gt;()
            .expect(&quot;The child has to be a `Label`.&quot;);

        // Bind &quot;label&quot; to &quot;number&quot;
        integer_object
            .bind_property(&quot;number&quot;, &amp;label, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>At first glance, that seems to work.
However, as you scroll around and activate a few list elements,
you will notice that sometimes multiple numbers change even though you only activated a single one.
This relates to how the view works internally.
Not every model item belongs to a single widget, but the widgets get recycled instead as you scroll through the view.
That also means that in our case, multiple numbers will be bound to the same widget.</p>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>Situations like these are so common that GTK offers an alternative to property binding: <a href="../docs/gtk4/struct.Expression.html">expressions</a>.
As a first step it allows us to remove the &quot;bind&quot; step.
Let us see how the &quot;setup&quot; step now works.</p>
<p><span class="filename">Filename: listings/list_widgets/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, Widget,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
        list_item
            .property_expression(&quot;item&quot;)
            .chain_property::&lt;IntegerObject&gt;(&quot;number&quot;)
            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>An expression provides a way to describe references to values.
One interesting part here is that these references can be several steps away.
This allowed us in the snippet above to bind the property &quot;number&quot; of the property &quot;item&quot; of <code>list_item</code> to the property &quot;label&quot; of <code>label</code>.</p>
<p>It is also worth noting that at the &quot;setup&quot; stage there is no way of knowing which list item belongs to which label, simply because this changes as we scroll through the list.
Here, another power of expressions becomes evident.
Expressions allow us to describe relationships between objects or properties that might not even exist yet.
We just had to tell it to change the label whenever the number that belongs to it changes.
That way, we also do not face the problem that multiple labels are bound to the same number.
When we now activate a label, only the corresponding number visibly changes.</p>
<p>Let us extend our app a bit more.
We can, for example, filter our model to only allow even numbers.</p>
<p><span class="filename">Filename: listings/list_widgets/5/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, CustomSorter, FilterChange, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression(&quot;item&quot;)
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;(&quot;number&quot;)
</span><span class="boring">            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span>    let filter = gtk::CustomFilter::new(move |obj| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object = obj
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);

        // Get property &quot;number&quot; from `IntegerObject`
        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);

        // Only allow even numbers
        number % 2 == 0
    });
    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
<span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">        let number_2 = integer_object_2.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Additionally, we can reverse the order of our model.</p>
<p><span class="filename">Filename: listings/list_widgets/5/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, CustomSorter, FilterChange, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression(&quot;item&quot;)
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;(&quot;number&quot;)
</span><span class="boring">            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = gtk::CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        number % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
</span><span class="boring">
</span>    let sorter = CustomSorter::new(move |obj1, obj2| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object_1 = obj1
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
        let integer_object_2 = obj2
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);

        // Get property &quot;number&quot; from `IntegerObject`
        let number_1 = integer_object_1.property::&lt;i32&gt;(&quot;number&quot;);
        let number_2 = integer_object_2.property::&lt;i32&gt;(&quot;number&quot;);

        // Reverse sorting order -&gt; large numbers come first
        number_2.cmp(&amp;number_1).into()
    });
    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>To ensure that our filter and sorter get updated when we modify the numbers, we call the <code>changed</code> method on them.</p>
<p><span class="filename">Filename: listings/list_widgets/5/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, CustomSorter, FilterChange, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).into_iter().map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model at position 0 and 0 removals
</span><span class="boring">    model.splice(0, 0, &amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression(&quot;item&quot;)
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;(&quot;number&quot;)
</span><span class="boring">            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = gtk::CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number = integer_object.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        number % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
</span><span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">        let number_2 = integer_object_2.property::&lt;i32&gt;(&quot;number&quot;);
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
        let integer_object = model
            .item(position)
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Increase &quot;number&quot; of `IntegerObject`
        integer_object.increase_number();

        // Notify that the filter and sorter have been changed
        filter.changed(FilterChange::Different);
        sorter.changed(SorterChange::Different);
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>After our changes, the application looks like this:</p>
<div style="text-align:center"><img src="img/lists_list_view_2.png"/></div>
<h3 id="string-list"><a class="header" href="#string-list">String List</a></h3>
<p>Often, all you want is to display a list of strings.
However, if you either need to filter and sort your displayed data or have too many elements to be displayed by <code>ListBox</code>, you will still want to use a view.
GTK provides a convenient model for this use case: <a href="../docs/gtk4/struct.StringList.html"><code>gtk::StringList</code></a>.</p>
<p>Let us see with a small example how to use this API.
Filter and sorter is controlled by the factory, so nothing changes here.
This is why we will skip this topic here.</p>
<p>First, we add a bunch of strings to our model.</p>
<p><span class="filename">Filename: listings/list_widgets/6/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `StringList` with number from 0 to 100_000
    // `StringList` implements FromIterator&lt;String&gt;
    let model: StringList = (0..=100_000)
        .into_iter()
        .map(|number| format!(&quot;Task number {}&quot;, number))
        .collect();
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression(&quot;item&quot;)
</span><span class="boring">            .chain_property::&lt;StringObject&gt;(&quot;string&quot;)
</span><span class="boring">            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Note that we can create a <code>StringList</code> directly from an iterator over strings.
This means we do not have to create a custom GObject for our model anymore.</p>
<p>As usual, we connect the label to the list item via an expression.
Here we can use <a href="../docs/gtk4/struct.StringObject.html"><code>StringObject</code></a>, which exposes its content via the <a href="https://docs.gtk.org/gtk4/property.StringObject.string.html">property &quot;string&quot;</a>.</p>
<p><span class="filename">Filename: listings/list_widgets/6/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `StringList` with number from 0 to 100_000
</span><span class="boring">    // `StringList` implements FromIterator&lt;String&gt;
</span><span class="boring">    let model: StringList = (0..=100_000)
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|number| format!(&quot;Task number {}&quot;, number))
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
        list_item
            .property_expression(&quot;item&quot;)
            .chain_property::&lt;StringObject&gt;(&quot;string&quot;)
            .bind(&amp;label, &quot;label&quot;, Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We now know how to display a list of data.
Small amount of elements can be handled by <code>ListBox</code> or <code>FlowBox</code>.
These widgets are easy to use and allow, if necessary, to be bound to a model such as <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
Their data can then be modified, sorted and filtered more easily.
However, if we need the widgets to be scalable, we still need to use <a href="../docs/gtk4/struct.ListView.html"><code>ListView</code></a>, <a href="../docs/gtk4/struct.ColumnView.html"><code>ColumnView</code></a> or <a href="../docs/gtk4/struct.GridView.html"><code>GridView</code></a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface-builder"><a class="header" href="#interface-builder">Interface Builder</a></h1>
<h2 id="gtk-builder"><a class="header" href="#gtk-builder">GTK Builder</a></h2>
<p>Until now, whenever we constructed pre-defined widgets we relied on the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>.
As a reminder, that is how we used it in our trusty &quot;Hello World!&quot; app.</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, Button};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}
</code></pre>
<p>Creating widgets directly from code is perfectly fine.
However, with most toolkits you can describe your user interface with a markup language and GTK is no exception here.
For example the following <code>xml</code> snippet describes the window widget of the &quot;Hello World!&quot; app. </p>
<p><span class="filename">Filename: listings/interface_builder/1/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>The most outer tag always has to be the <code>&lt;interface&gt;</code>.
Then you start listing the elements you want to describe.
In our case, we want to have a <code>gtk::ApplicationWindow</code>.
These <code>xml</code> files are independent of the programming language, which is why the classes have the original names.
Luckily, they all convert like this: <code>gtk::ApplicationWindow</code> → <code>GtkApplicationWindow</code>.
We want to access the window later on, so we also give it an <code>id</code>.
Then we can specify properties which are specified <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html">here</a> for <code>ApplicationWindow</code>.
Since <code>ApplicationWindow</code> can contain other widgets we use the <code>&lt;child&gt;</code> tag to add a <code>Button</code>.</p>
<p>To instantiate the widgets described by the <code>xml</code> files we use <a href="../docs/gtk4/struct.Builder.html"><code>gtk::Builder</code></a>.
All widgets that can be described that way can be found <a href="../docs/gtk4/prelude/trait.BuildableExt.html#implementors-1">here</a></p>
<blockquote>
<p>Puh, yet another builder? Let us summarize what we have so far:</p>
<ul>
<li><a href="https://flathub.org/apps/details/org.gnome.Builder">GNOME Builder</a>, an IDE used to create GNOME apps, </li>
<li><a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>, a design pattern used to create objects with many optional parameters and</li>
<li><a href="../docs/gtk4/struct.Builder.html"><code>gtk::Builder</code></a>, the interface builder which creates widgets from <code>xml</code> files.</li>
</ul>
<p>That was it with the builders.
Promised!</p>
</blockquote>
<p>This is how it then looks in practice:</p>
<p><span class="filename">Filename: listings/interface_builder/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Init `gtk::Builder` from file
    let builder = gtk::Builder::from_string(include_str!(&quot;window.ui&quot;));

    // Get window and button from `gtk::Builder`
    let window: ApplicationWindow = builder
        .object(&quot;window&quot;)
        .expect(&quot;Could not get object `window` from builder.&quot;);
    let button: Button = builder
        .object(&quot;button&quot;)
        .expect(&quot;Could not get object `button` from builder.&quot;);

    // Set application
    window.set_application(Some(app));

    // Connect to &quot;clicked&quot; signal
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre>
<p>This is a bit disappointing.
Even though we have already described the UI in the markup file, the amount of code is still pretty much the same.
There are still cases where it is valuable to know of the existence of <code>gtk::Builder</code>.
We will see for example that <a href="../docs/gtk4/struct.ShortcutsWindow.html"><code>ShortcutsWindow</code></a> is quite a bit easier to instantiate that way.</p>
<p>At least we did not lose any flexibility by using <code>gtk::Builder</code>.
It is for example still possible to refer to custom widgets such as this bare-bones <code>CustomButton</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/2/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {}
</span></code></pre>
<p>Within the <code>xml</code> file we reference the widget with the <code>NAME</code> we gave it in <code>imp.rs</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;MyGtkAppCustomButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>We also have to make sure to register the custom widget before it is used by the interface builder.</p>
<p><span class="filename">Filename: listings/interface_builder/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">
</span>fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal
    app.connect_activate(build_ui);

    // Register custom button
    CustomButton::static_type();

    // Run the application
    app.run();
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Init `gtk::Builder` from file
</span><span class="boring">    let builder = gtk::Builder::from_string(include_str!(&quot;window.ui&quot;));
</span><span class="boring">
</span><span class="boring">    // Get window and button from `gtk::Builder`
</span><span class="boring">    let window: ApplicationWindow = builder
</span><span class="boring">        .object(&quot;window&quot;)
</span><span class="boring">        .expect(&quot;Could not get object `window` from builder.&quot;);
</span><span class="boring">    let button: CustomButton = builder
</span><span class="boring">        .object(&quot;button&quot;)
</span><span class="boring">        .expect(&quot;Could not get object `button` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">    // Set application
</span><span class="boring">    window.set_application(Some(app));
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;clicked&quot; signal
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<h2 id="composite-templates"><a class="header" href="#composite-templates">Composite Templates</a></h2>
<p>The actual reason why we devote a whole chapter to the interface builder is the existence of composite templates.
Again, composite templates are described by <code>xml</code> files.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;MyGtkAppCustomButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>At first glance, the content seems to be nearly the same.
Before, we described a pre-existing widget.</p>
<pre><code class="language-xml">&lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
</code></pre>
<p>Now, we create a custom widget and let it inherit from a pre-existing one.</p>
<pre><code class="language-xml">&lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
</code></pre>
<p>Within our code we create a custom widget inheriting from <code>gtk::ApplicationWindow</code> to make use of our template.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground">mod imp;

use glib::Object;
use gtk::Application;
use gtk::{gio, glib};

glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
    }
}
</code></pre>
<p>In the private struct, we then add the derive macro <code>gtk::CompositeTemplate</code>.
We also specify that the template information comes from a file <code>window.ui</code> in the same folder.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">            button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>One very convenient feature of templates is the template child.
You use it by adding a struct member with the same name as one <code>id</code> attribute in the template.
Template child then:</p>
<ul>
<li>assures that the widget gets registered without doing it manually in <code>main.rs</code>, and</li>
<li>stores a reference to the widget for later use.</li>
</ul>
<p>We need both for our custom button, so we add it to the struct.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        Self::bind_template(klass);
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">            button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Within the <code>ObjectSubclass</code> trait, we make sure that <code>NAME</code> corresponds to <code>class</code> in the template and <code>ParentType</code> corresponds to <code>parent</code> in the template.
We also bind and initialize the template in <code>class_init</code> and <code>instance_init</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Connect to &quot;clicked&quot; signal of `button`
        self.button.connect_clicked(move |button| {
            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
            button.set_label(&quot;Hello World!&quot;);
        });
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Finally, we connect the callback to the &quot;clicked&quot; signal of <code>button</code> within <code>constructed</code>.
The button is easily available thanks to the stored reference in <code>self</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">pub mod custom_button;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create new window and present it
    let window = Window::new(app);
    window.present();
}
</code></pre>
<p>With composite templates, <code>main.rs</code> actually became more concise.
With regard to capabilities, we also get the best of both worlds.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Thanks to custom widgets we can</p>
<ul>
<li>keep state and part of it as properties,</li>
<li>add signals as well as</li>
<li>override behavior.</li>
</ul>
<p>Thanks to composite templates we can</p>
<ul>
<li>describe complex user interfaces concisely, and</li>
<li>easily access widgets within the template. </li>
</ul>
<p>The API of the interface builder is extensive so especially at the beginning you will want to check out the documentation.
The basic syntax is explained with <a href="../docs/gtk4/struct.Builder.html#gtkbuilder-ui-definitions"><code>Builder</code></a>, syntax specific to widgets with <a href="../docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>Widget</code></a>.
If a certain widget accepts additional element, then they are typically explained in the docs of the widget.</p>
<p>In the following chapter, we will see how composite templates help us to create slightly bigger apps such as a To-Do app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-simple-to-do-app"><a class="header" href="#building-a-simple-to-do-app">Building a Simple To-Do App</a></h1>
<p>After we have learned so many concepts, it is finally time to put them into practice.
We are going to build a To-Do app!</p>
<p>For now, we would already be satisfied with a minimal version.
An entry to input new tasks and a list view to display them will suffice.
Something like this:</p>
<div style="text-align:center"><img src="img/todo_app_1_mockup.png" /></div>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>This mockup can be described by the following composite template.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;TodoWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;width-request&quot;&gt;360&lt;/property&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;To-Do&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkBox&quot;&gt;
        &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkEntry&quot; id=&quot;entry&quot;/&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkScrolledWindow&quot;&gt;
            &lt;property name=&quot;hscrollbar-policy&quot;&gt;never&lt;/property&gt;
            &lt;property name=&quot;min-content-height&quot;&gt;360&lt;/property&gt;
            &lt;property name=&quot;vexpand&quot;&gt;true&lt;/property&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkListView&quot; id=&quot;list_view&quot;/&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to use the composite template, we create a custom widget.
The <code>parent</code> is <code>gtk::ApplicationWindow</code>, so we inherit from it.
As usual, we have to list all <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#ancestors">ancestors</a> and <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#implements">interfaces</a> apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Then we initialize the composite template for <code>imp::Window</code>.
We store references to the entry, the list view as well as the list model.
This will come in handy when we later add methods to our window.
After that, we add the typical boilerplate for initializing composite templates.
We only have to assure that the <code>class</code> attribute of the template in <code>window.ui</code> matches <code>NAME</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{CompositeTemplate, Entry, ListView};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub list_view: TemplateChild&lt;ListView&gt;,
    pub model: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        Self::bind_template(klass);
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        obj.setup_model();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p><code>main.rs</code> also does not hold any surprises for us.</p>
<p><span class="filename">Filename: listings/todo_app/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod todo_object;
</span><span class="boring">mod todo_row;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">
</span><span class="boring">use window::Window;
</span><span class="boring">
</span>fn main() {
    // Initialize logger
    pretty_env_logger::init();

    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.Todo&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a new custom window and show it
    let window = Window::new(app);
    window.present();
}
</code></pre>
<h2 id="to-do-object"><a class="header" href="#to-do-object">To-Do Object</a></h2>
<p>So far so good.
The main user interface is done, but the entry does not react to input yet.
Also, where would the input go?
We have not even set up the list model yet.
Let us do that!</p>
<div style="text-align:center"><img src="img/todo_app_1_empty.png" /></div>
<p>As discussed in the <a href="./list_widgets.html">list widgets chapter</a>,
we start out by creating a custom GObject.
This object will store the state of the task consisting of:</p>
<ul>
<li>a boolean describing whether the task is completed or not, and</li>
<li>a string holding the task name.</li>
</ul>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
}

impl TodoObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
            .expect(&quot;Failed to create `TodoObject`.&quot;)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TodoData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span></code></pre>
<p>Unlike the lists chapter, the state is stored in a struct rather than in individual members of <code>imp::TodoObject</code>.
This will be very convenient when saving the state in one of the following chapters.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
</span><span class="boring">            .expect(&quot;Failed to create `TodoObject`.&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct TodoData {
    pub completed: bool,
    pub content: String,
}
</code></pre>
<p>Exposing <code>completed</code> and <code>content</code> as properties does not become much different that way, so we will not discuss it further.
If you are curious, you can press on the small eye symbol on the top right of the code snippet to read the implementation.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{ParamFlags, ParamSpec, ParamSpecBoolean, ParamSpecString, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use super::TodoData;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct TodoObject {
    pub data: Rc&lt;RefCell&lt;TodoData&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TodoObject {
    const NAME: &amp;'static str = &quot;TodoObject&quot;;
    type Type = super::TodoObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TodoObject {
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![
</span><span class="boring">                ParamSpecBoolean::new(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Default value
</span><span class="boring">                    false,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                ),
</span><span class="boring">                ParamSpecString::new(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Default value
</span><span class="boring">                    None,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                ),
</span><span class="boring">            ]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;completed&quot; =&gt; {
</span><span class="boring">                let input_value = value.get().expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                self.data.borrow_mut().completed = input_value;
</span><span class="boring">            }
</span><span class="boring">            &quot;content&quot; =&gt; {
</span><span class="boring">                let input_value = value
</span><span class="boring">                    .get()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">                self.data.borrow_mut().content = input_value;
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;completed&quot; =&gt; self.data.borrow().completed.to_value(),
</span><span class="boring">            &quot;content&quot; =&gt; self.data.borrow().content.to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="to-do-row"><a class="header" href="#to-do-row">To-Do Row</a></h2>
<p>Let us move on to the individual tasks.
The row of a task should look like this:</p>
<div style="text-align:center"><img src="img/todo_row.png" /></div>
<p>Again, we describe the mockup with a composite template.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/todo_row.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;TodoRow&quot; parent=&quot;GtkBox&quot;&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkCheckButton&quot; id=&quot;completed_button&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkLabel&quot; id=&quot;content_label&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In the code, we <a href="https://docs.gtk.org/gtk4/class.Box.html#hierarchy">derive</a> <code>TodoRow</code> from <code>gtk:Box</code>:</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
    @extends gtk::Box, gtk::Widget,
    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
}
<span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let completed_button = imp.completed_button.get();
</span><span class="boring">        let content_label = imp.content_label.get();
</span><span class="boring">        let mut bindings = imp.bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.content` to `todo_row.content_label.label`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .transform_to(|_, active_value| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                let active = active_value
</span><span class="boring">                    .get::&lt;bool&gt;()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                if active {
</span><span class="boring">                    // If &quot;active&quot; is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in imp.bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In <code>imp::TodoRow</code>, we hold references to <code>completed_button</code> and <code>content_label</code>.
We also store a mutable vector of bindings.
Why we need that will become clear as soon as we get to bind the state of <code>TodoObject</code> to the corresponding <code>TodoRow</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default, CompositeTemplate)]
#[template(file = &quot;todo_row.ui&quot;)]
pub struct TodoRow {
    #[template_child]
    pub completed_button: TemplateChild&lt;CheckButton&gt;,
    #[template_child]
    pub content_label: TemplateChild&lt;Label&gt;,
    // Vector holding the bindings to properties of `TodoObject`
    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TodoRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoRow&quot;;
    type Type = super::TodoRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        Self::bind_template(klass);
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TodoRow {}
</span></code></pre>
<p>Now we can bring everything together.
We override the <code>imp::Window::constructed</code> in order to set up window contents at the time of its construction.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{CompositeTemplate, Entry, ListView};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub list_view: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub model: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Setup
        obj.setup_model();
        obj.setup_callbacks();
        obj.setup_factory();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Since we need to access the list model quite often, we add the convenience method <code>Window::model</code> for that.
In <code>Window::setup_model</code> we create a new model.
Then we store a reference to the model in <code>imp::Window</code> as well as in <code>gtk::ListView</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    fn model(&amp;self) -&gt; &amp;gio::ListStore {
        // Get state
        let imp = self.imp();
        imp.model.get().expect(&quot;Could not get model&quot;)
    }

    fn setup_model(&amp;self) {
        // Create new model
        let model = gio::ListStore::new(TodoObject::static_type());

        // Get state and set model
        let imp = self.imp();
        imp.model.set(model).expect(&quot;Could not set model&quot;);

        // Wrap model with selection and pass it to the list view
        let selection_model = NoSelection::new(Some(self.model()));
        imp.list_view.set_model(Some(&amp;selection_model));
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In <code>Window::setup_callbacks</code> we connect to the &quot;activate&quot; signal of the entry.
This signal is triggered when we press the enter key in the entry.
Then a new <code>TodoObject</code> with the content will be created and appended to the model.
Finally, the entry will be cleared.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_callbacks(&amp;self) {
        // Get state
        let imp = self.imp();
        let model = self.model();

        // Setup callback so that activation
        // creates a new todo object and clears the entry
        imp.entry
            .connect_activate(clone!(@weak model =&gt; move |entry| {
                let buffer = entry.buffer();
                let content = buffer.text();
                let todo_object = TodoObject::new(false, content);
                model.append(&amp;todo_object);
                buffer.set_text(&quot;&quot;);
            }));
    }
<span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The list elements for the <code>gtk::ListView</code> are produced by a factory.
Before we move on to the implementation, let us take a step back and think about which behavior we expect here.
<code>content_label</code> of <code>TodoRow</code> should follow <code>content</code> of <code>TodoObject</code>.
We also want <code>completed_button</code> of <code>TodoRow</code> follow <code>completed</code> of <code>TodoObject</code>.
This could be achieved with expressions similar to what we did in the lists chapter.</p>
<p>However, if we toggle the state of <code>completed_button</code> of <code>TodoRow</code>, <code>completed</code> of <code>TodoObject</code> should change too.
Unfortunately, expressions cannot handle bidirectional relationships.
This means we have to use property bindings.
We will need to unbind them manually when they are no longer needed.</p>
<p>We will create empty <code>TodoRow</code> objects in the &quot;setup&quot; step in <code>Window::setup_factory</code> and deal with binding in the &quot;bind&quot; and &quot;unbind&quot; steps.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_factory(&amp;self) {
        // Create a new factory
        let factory = SignalListItemFactory::new();

        // Create an empty `TodoRow` during setup
        factory.connect_setup(move |_, list_item| {
            // Create `TodoRow`
            let todo_row = TodoRow::new();
            list_item.set_child(Some(&amp;todo_row));
        });

        // Tell factory how to bind `TodoRow` to a `TodoObject`
        factory.connect_bind(move |_, list_item| {
            // Get `TodoObject` from `ListItem`
            let todo_object = list_item
                .item()
                .expect(&quot;The item has to exist.&quot;)
                .downcast::&lt;TodoObject&gt;()
                .expect(&quot;The item has to be an `TodoObject`.&quot;);

            // Get `TodoRow` from `ListItem`
            let todo_row = list_item
                .child()
                .expect(&quot;The child has to exist.&quot;)
                .downcast::&lt;TodoRow&gt;()
                .expect(&quot;The child has to be a `TodoRow`.&quot;);

            todo_row.bind(&amp;todo_object);
        });

        // Tell factory how to unbind `TodoRow` from `TodoObject`
        factory.connect_unbind(move |_, list_item| {
            // Get `TodoRow` from `ListItem`
            let todo_row = list_item
                .child()
                .expect(&quot;The child has to exist.&quot;)
                .downcast::&lt;TodoRow&gt;()
                .expect(&quot;The child has to be a `TodoRow`.&quot;);

            todo_row.unbind();
        });

        // Set the factory of the list view
        let imp = self.imp();
        imp.list_view.set_factory(Some(&amp;factory));
    }
<span class="boring">}
</span></code></pre>
<p>Binding properties in <code>TodoRow::bind</code> works just like in former chapters.
The only difference is that we store the bindings in a vector.
This is necessary because a <code>TodoRow</code> will be reused as you scroll through the list.
That means that over time a <code>TodoRow</code> will need to bound to a new <code>TodoObject</code> and has to be unbound from the old one.
Unbinding will only work if it can access the stored <code>glib::Binding</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
        // Get state
        let imp = self.imp();
        let completed_button = imp.completed_button.get();
        let content_label = imp.content_label.get();
        let mut bindings = imp.bindings.borrow_mut();

        // Bind `todo_object.completed` to `todo_row.completed_button.active`
        let completed_button_binding = todo_object
            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
            .build();
        // Save binding
        bindings.push(completed_button_binding);

        // Bind `todo_object.content` to `todo_row.content_label.label`
        let content_label_binding = todo_object
            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
        // Save binding
        bindings.push(content_label_binding);

        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
        let content_label_binding = todo_object
            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .transform_to(|_, active_value| {
                let attribute_list = AttrList::new();
                let active = active_value
                    .get::&lt;bool&gt;()
                    .expect(&quot;The value needs to be of type `bool`.&quot;);
                if active {
                    // If &quot;active&quot; is true, content of the label will be strikethrough
                    let attribute = AttrInt::new_strikethrough(true);
                    attribute_list.insert(attribute);
                }
                Some(attribute_list.to_value())
            })
            .build();
        // Save binding
        bindings.push(content_label_binding);
    }
<span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in imp.bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><code>TodoRow::unbind</code> takes care of the cleanup.
It iterates through the vector and unbinds each binding.
In the end, it clears the vector.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let completed_button = imp.completed_button.get();
</span><span class="boring">        let content_label = imp.content_label.get();
</span><span class="boring">        let mut bindings = imp.bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.content` to `todo_row.content_label.label`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .transform_to(|_, active_value| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                let active = active_value
</span><span class="boring">                    .get::&lt;bool&gt;()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                if active {
</span><span class="boring">                    // If &quot;active&quot; is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn unbind(&amp;self) {
        // Get state
        let imp = self.imp();

        // Unbind all stored bindings
        for binding in imp.bindings.borrow_mut().drain(..) {
            binding.unbind();
        }
    }
<span class="boring">}
</span></code></pre>
<p>That was it, we created a basic To-Do app!
We will extend it with additional functionality in the following chapters.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_app_1_animation.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>By now, we have already learned many ways to glue our widgets together.
We can send messages through channels, emit signals, share reference-counted state and bind properties.
Now, we will complete our set by learning about actions.</p>
<p>An action is a piece of functionality bound to a certain GObject.
Let us check out the simplest case where we activate an action without a parameter.</p>
<p><span class="filename">Filename: listings/actions/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger &quot;win.close&quot;.
</span><span class="boring">    app.set_accels_for_action(&quot;win.close&quot;, &amp;[&quot;&lt;primary&gt;W&quot;]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .width_request(360)
        .build();

    // Add action &quot;close&quot; to `window` taking no parameter
    let action_close = SimpleAction::new(&quot;close&quot;, None);
    action_close.connect_activate(clone!(@weak window =&gt; move |_, _| {
        window.close();
    }));
    window.add_action(&amp;action_close);

    // Present window
    window.present();
}
</code></pre></pre>
<p>First, we created a new <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.SimpleAction.html"><code>gio::SimpleAction</code></a> which is named &quot;close&quot; and takes no parameter.
We also connected a callback which closes the window.</p>
<p><span class="filename">Filename: listings/actions/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span>fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Set keyboard accelerator to trigger &quot;win.close&quot;.
    app.set_accels_for_action(&quot;win.close&quot;, &amp;[&quot;&lt;primary&gt;W&quot;]);

    // Run the application
    app.run();
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action &quot;close&quot; to `window` taking no parameter
</span><span class="boring">    let action_close = SimpleAction::new(&quot;close&quot;, None);
</span><span class="boring">    action_close.connect_activate(clone!(@weak window =&gt; move |_, _| {
</span><span class="boring">        window.close();
</span><span class="boring">    }));
</span><span class="boring">    window.add_action(&amp;action_close);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>One of the most popular reasons to use actions are keyboard accelerators, so we added one here.
With <a href="../docs/gtk4/prelude/trait.GtkApplicationExt.html#tymethod.set_accels_for_action"><code>set_accels_for_action</code></a> one can assign one or more accelerators to a certain action.
Check the documentation of <a href="../docs/gtk4/functions/fn.accelerator_parse.html"><code>accelerator_parse</code></a> in order to learn more about its syntax.
Here we assigned <code>&lt;primary&gt;W</code> which translates to <kbd>Ctrl</kbd> + <kbd>W</kbd> on Linux and Windows and ⌘ + <kbd>W</kbd> on macOS.</p>
<p>Before we move on to other aspects of actions, let us appreciate a few things that are curious here.
The &quot;win&quot; part of &quot;win.close&quot; is the group of the action.
But how does GTK know that &quot;win&quot; is the action group of our window?
The answer is that it is so common to add actions to windows and applications that there are already two predefined groups available:</p>
<ul>
<li>&quot;app&quot; for actions global to the application, and</li>
<li>&quot;win&quot; for actions tied to an application window.</li>
</ul>
<p>If that was not the case, we would have to add the action group manually via <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.SimpleActionGroup.html"><code>gio::SimpleActionGroup</code></a>.</p>
<p><span class="filename">Filename: listings/actions/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger &quot;win.close&quot;.
</span><span class="boring">    app.set_accels_for_action(&quot;win.close&quot;, &amp;[&quot;&lt;primary&gt;W&quot;]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action &quot;close&quot; to `window` taking no parameter
</span><span class="boring">    let action_close = SimpleAction::new(&quot;close&quot;, None);
</span><span class="boring">    action_close.connect_activate(clone!(@weak window =&gt; move |_, _| {
</span><span class="boring">        window.close();
</span><span class="boring">    }));
</span><span class="boring">    window.add_action(&amp;action_close);
</span><span class="boring">
</span>    // Create a new action group and add actions to it
    let actions = SimpleActionGroup::new();
    window.insert_action_group(&quot;win&quot;, Some(&amp;actions));
    actions.add_action(&amp;action_close);
<span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Also, if we had multiple instances of the same windows we would expect that only the currently focused window will be closed when activating &quot;win.close&quot;.
And indeed, the &quot;win.close&quot; will be dispatched to the currently focused window.
However, that also means that we actually define one action per window instance.
If we want to have a single globally accessible action instead, we call <code>add_action</code> on our application instead.</p>
<blockquote>
<p>Adding &quot;win.close&quot; was useful as a simple example.
However, in the future we will use the pre-defined <a href="../docs/gtk4/struct.Window.html#actions">&quot;window.close&quot;</a> action which does exactly the same thing.</p>
</blockquote>
<h2 id="parameter-and-state"><a class="header" href="#parameter-and-state">Parameter and State</a></h2>
<p>An action, like most functions, can take a parameter.
However, unlike most functions it can also be stateful.
Let us see how this works.</p>
<p><span class="filename">Filename: listings/actions/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{prelude::*, Align};
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, Label, Orientation};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .width_request(360)
        .build();

    let original_state = 0;
    let label = Label::builder()
        .label(&amp;format!(&quot;Counter: {}&quot;, original_state))
        .build();

    // Add action &quot;count&quot; to `window` taking an integer as parameter
    let action_count = SimpleAction::new_stateful(
        &quot;count&quot;,
        Some(&amp;i32::static_variant_type()),
        &amp;original_state.to_variant(),
    );
    action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
        // Get state
        let mut state = action
            .state()
            .expect(&quot;Could not get state.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The variant needs to be of type `i32`.&quot;);

        // Get parameter
        let parameter = parameter
            .expect(&quot;Could not get parameter.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The variant needs to be of type `i32`.&quot;);

        // Increase state by parameter and store state
        state += parameter;
        action.set_state(&amp;state.to_variant());

        // Update label with new state
        label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
    }));
    window.add_action(&amp;action_count);

    // Create a button with label
    let button = Button::builder().label(&quot;Press me!&quot;).build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Activate &quot;win.count&quot; and pass &quot;1&quot; as parameter
        let parameter = 1;
        button
            .activate_action(&quot;win.count&quot;, Some(&amp;parameter.to_variant()))
            .expect(&quot;The action does not exist.&quot;);
    });

    // Create a `gtk::Box` and add `button` and `label` to it
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .spacing(12)
        .halign(Align::Center)
        .build();
    gtk_box.append(&amp;button);
    gtk_box.append(&amp;label);

    // Add `gtk_box` to the window
    window.set_child(Some(&amp;gtk_box));

    // Present window
    window.present();
}
</code></pre>
<p>Here we created a &quot;win.count&quot; action that increases its state by the given parameter every time it is activated.
It also takes care of updating the <code>label</code> with the current state.
The button activates the action with each click while passing &quot;1&quot; as parameter.
This is how our app works:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_counter.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<h2 id="actionable"><a class="header" href="#actionable">Actionable</a></h2>
<p>Connecting actions to the &quot;clicked&quot; signal of buttons is a typical use case, which is why all buttons implement the <a href="../docs/gtk4/struct.Actionable.html"><code>Actionable</code></a> interface.
This way, the action can be specified by setting the &quot;action-name&quot; property.
If the action accepts a parameter, it can be set via the &quot;action-target&quot; property.
With <a href="../docs/gtk4/builders/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a>, we can set everything up by calling its methods.</p>
<p><span class="filename">Filename: listings/actions/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{prelude::*, Align};
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, Label, Orientation};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let original_state = 0;
</span><span class="boring">    let label = Label::builder()
</span><span class="boring">        .label(&amp;format!(&quot;Counter: {}&quot;, original_state))
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action &quot;count&quot; to `window` taking an integer as parameter
</span><span class="boring">    let action_count = SimpleAction::new_stateful(
</span><span class="boring">        &quot;count&quot;,
</span><span class="boring">        Some(&amp;i32::static_variant_type()),
</span><span class="boring">        &amp;original_state.to_variant(),
</span><span class="boring">    );
</span><span class="boring">    action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
</span><span class="boring">        // Get state
</span><span class="boring">        let mut state = action
</span><span class="boring">        .state()
</span><span class="boring">        .expect(&quot;Could not get state.&quot;)
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get parameter
</span><span class="boring">        let parameter = parameter
</span><span class="boring">            .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase state by parameter and save state
</span><span class="boring">        state += parameter;
</span><span class="boring">        action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">        // Update label with new state
</span><span class="boring">        label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    window.add_action(&amp;action_count);
</span><span class="boring">
</span>    // Create a button with label and action
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .action_name(&quot;win.count&quot;)
        .action_target(&amp;1.to_variant())
        .build();
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add `button` and `label` to it
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button);
</span><span class="boring">    gtk_box.append(&amp;label);
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<p>Actionable widgets are also easily accessible through the interface builder.
As usual, we build up the window via a composite template.
Within the template we can then set the &quot;action-name&quot; and &quot;action-target&quot; properties.</p>
<p><span class="filename">Filename: listings/actions/5/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkBox&quot; id=&quot;gtk_box&quot;&gt;
        &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;halign&quot;&gt;center&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkButton&quot; id=&quot;button&quot;&gt;
            &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
            &lt;property name=&quot;action-name&quot;&gt;win.count&lt;/property&gt;
            &lt;property name=&quot;action-target&quot;&gt;1&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkLabel&quot; id=&quot;label&quot;&gt;
            &lt;property name=&quot;label&quot;&gt;Counter: 0&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>We will connect the actions and add them to the window in the <code>Window::add_actions</code> method.</p>
<p><span class="filename">Filename: listings/actions/5/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span>impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
    }

    fn add_actions(&amp;self) {
        let imp = self.imp();
        let label = imp.label.get();

        // Add stateful action &quot;count&quot; to `window` taking an integer as parameter
        let original_state = 0;
        let action_count = SimpleAction::new_stateful(
            &quot;count&quot;,
            Some(&amp;i32::static_variant_type()),
            &amp;original_state.to_variant(),
        );

        action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
            // Get state
            let mut state = action
                .state()
                .expect(&quot;Could not get state.&quot;)
                .get::&lt;i32&gt;()
                .expect(&quot;The value needs to be of type `i32`.&quot;);

            // Get parameter
            let parameter = parameter
                .expect(&quot;Could not get parameter.&quot;)
                .get::&lt;i32&gt;()
                .expect(&quot;The value needs to be of type `i32`.&quot;);

            // Increase state by parameter and save state
            state += parameter;
            action.set_state(&amp;state.to_variant());

            // Update label with new state
            label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
        }));
        self.add_action(&amp;action_count);
    }
}
</code></pre>
<p>Finally, <code>add_actions</code> will be called within <code>constructed</code>.</p>
<p><span class="filename">Filename: listings/actions/5/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Add actions
        obj.add_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>This app behaves the same as our previous example, but it leads us to menu creation.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>If you want to create a <a href="https://developer.gnome.org/hig/patterns/controls/menus.html">menu</a> you have to use actions and you will want to use the interface builder.
Typically, a menu entry has an action fitting one of these three descriptions:</p>
<ul>
<li>no parameter and no state, or</li>
<li>no parameter and boolean state, or</li>
<li>string parameter and string state.</li>
</ul>
<p>Let us modify our small app to demonstrate these cases.
First we extend <code>add_actions</code>.
For the action without parameter or state, we can use the pre-defined &quot;window.close&quot; action.
Therefore we do not have to add anything here.</p>
<p>With the action &quot;sensitive-button&quot;, we manipulate the &quot;sensitive&quot; property of <code>button</code>.
Here, the convention is that actions with no parameter and boolean state should behave like toggle actions.
This means that the caller can expect the boolean state to toggle after activating the action. Luckily for us, that is the default behavior for <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.PropertyAction.html"><code>gio::PropertyAction</code></a> with a boolean property.</p>
<p><span class="filename">Filename: listings/actions/6/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{PropertyAction, SimpleAction};
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_actions(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let label = imp.label.get();
</span><span class="boring">
</span><span class="boring">        // Add stateful action &quot;count&quot; to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = SimpleAction::new_stateful(
</span><span class="boring">            &quot;count&quot;,
</span><span class="boring">            Some(&amp;i32::static_variant_type()),
</span><span class="boring">            &amp;original_state.to_variant(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect(&quot;Could not get state.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and save state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_count);
</span><span class="boring">
</span>        // Add property action &quot;sensitive-button&quot; to `window`
        let button = imp.button.get();
        let action_sensitive_button = PropertyAction::new(&quot;sensitive-button&quot;, &amp;button, &quot;sensitive&quot;);
        self.add_action(&amp;action_sensitive_button);
<span class="boring">
</span><span class="boring">
</span><span class="boring">        // Add stateful action &quot;orientation&quot; to `window` taking a string as parameter
</span><span class="boring">        let gtk_box = imp.gtk_box.get();
</span><span class="boring">        let action_orientation = SimpleAction::new_stateful(
</span><span class="boring">            &quot;orientation&quot;,
</span><span class="boring">            Some(&amp;String::static_variant_type()),
</span><span class="boring">            &amp;&quot;Vertical&quot;.to_variant(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        action_orientation.connect_activate(clone!(@weak gtk_box =&gt;
</span><span class="boring">            move |action, parameter| {
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">                let orientation = match parameter.as_str() {
</span><span class="boring">                    &quot;Horizontal&quot; =&gt; Orientation::Horizontal,
</span><span class="boring">                    &quot;Vertical&quot; =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!()
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                // Set orientation and save state
</span><span class="boring">                gtk_box.set_orientation(orientation);
</span><span class="boring">                action.set_state(&amp;parameter.to_variant());
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>A <code>PropertyAction</code> is useful when you need an action that manipulates the property of a GObject.
The property then acts as the state of the action.
As mentioned above, if the property is a boolean the action has no parameter and toggles the property on activation.
In all other cases, the action has a parameter of the same type as the property.
When activating the action, the property gets set to the same value as the parameter of the action.</p>
</blockquote>
<p>Finally, we add &quot;win.orientation&quot;, an action with string parameter and string state.
This action can be used to change the orientation of <code>gtk_box</code>.
Here the convention is that the state should be set to the given parameter.
We do not need the action state to implement orientation switching, however it is useful for making the menu display the current orientation.</p>
<p><span class="filename">Filename: listings/actions/6/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{PropertyAction, SimpleAction};
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_actions(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let label = imp.label.get();
</span><span class="boring">
</span><span class="boring">        // Add stateful action &quot;count&quot; to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = SimpleAction::new_stateful(
</span><span class="boring">            &quot;count&quot;,
</span><span class="boring">            Some(&amp;i32::static_variant_type()),
</span><span class="boring">            &amp;original_state.to_variant(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect(&quot;Could not get state.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and save state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_count);
</span><span class="boring">
</span><span class="boring">        // Add property action &quot;sensitive-button&quot; to `window`
</span><span class="boring">        let button = imp.button.get();
</span><span class="boring">        let action_sensitive_button = PropertyAction::new(&quot;sensitive-button&quot;, &amp;button, &quot;sensitive&quot;);
</span><span class="boring">        self.add_action(&amp;action_sensitive_button);
</span><span class="boring">
</span>
        // Add stateful action &quot;orientation&quot; to `window` taking a string as parameter
        let gtk_box = imp.gtk_box.get();
        let action_orientation = SimpleAction::new_stateful(
            &quot;orientation&quot;,
            Some(&amp;String::static_variant_type()),
            &amp;&quot;Vertical&quot;.to_variant(),
        );

        action_orientation.connect_activate(clone!(@weak gtk_box =&gt;
            move |action, parameter| {
                // Get parameter
                let parameter = parameter
                    .expect(&quot;Could not get parameter.&quot;)
                    .get::&lt;String&gt;()
                    .expect(&quot;The value needs to be of type `String`.&quot;);

                let orientation = match parameter.as_str() {
                    &quot;Horizontal&quot; =&gt; Orientation::Horizontal,
                    &quot;Vertical&quot; =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!()
                };

                // Set orientation and save state
                gtk_box.set_orientation(orientation);
                action.set_state(&amp;parameter.to_variant());
        }));
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Even though <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Menu.html"><code>gio::Menu</code></a> can also be created with the bindings, the most convenient way is to use the interface builder for that.
We do that by adding the menu in front of the template.</p>
<p><span class="filename">Filename: listings/actions/6/window/window.ui</span></p>
<pre><code class="language-diff"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;interface&gt;
+  &lt;menu id=&quot;main-menu&quot;&gt;
+    &lt;item&gt;
+      &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Close window&lt;/attribute&gt;
+      &lt;attribute name=&quot;action&quot;&gt;window.close&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Sensitive button&lt;/attribute&gt;
+      &lt;attribute name=&quot;action&quot;&gt;win.sensitive-button&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;section&gt;
+      &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Orientation&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Horizontal&lt;/attribute&gt;
+        &lt;attribute name=&quot;action&quot;&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name=&quot;target&quot;&gt;Horizontal&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Vertical&lt;/attribute&gt;
+        &lt;attribute name=&quot;action&quot;&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name=&quot;target&quot;&gt;Vertical&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/section&gt;
+  &lt;/menu&gt;
   &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
     &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
+    &lt;property name=&quot;width-request&quot;&gt;360&lt;/property&gt;
+    &lt;child type=&quot;titlebar&quot;&gt;
+      &lt;object class=&quot;GtkHeaderBar&quot;&gt;
+        &lt;child type =&quot;end&quot;&gt;
+          &lt;object class=&quot;GtkMenuButton&quot;&gt;
+            &lt;property name=&quot;icon-name&quot;&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name=&quot;menu-model&quot;&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class=&quot;GtkBox&quot; id=&quot;gtk_box&quot;&gt;
         &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
</code></pre>
<p>Since we connect the menu to the <a href="../docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> via the <a href="https://docs.gtk.org/gtk4/property.MenuButton.menu-model.html">menu-model</a> property, the <code>Menu</code> is expected to be a <a href="../docs/gtk4/struct.PopoverMenu.html"><code>gtk::PopoverMenu</code></a>.
The documentation for <code>PopoverMenu</code> also explains its <code>xml</code> syntax for the interface builder.</p>
<p>Also note how we specified the target:</p>
<pre><code class="language-xml">&lt;attribute name=&quot;target&quot;&gt;Horizontal&lt;/attribute&gt;
</code></pre>
<p>String is the default type of the target which is why we did not have to specify a type.
With targets of other types you need to manually specify the correct <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant format string</a>.
For example, an <code>i32</code> variable with value &quot;5&quot; would correspond to this:</p>
<pre><code class="language-xml">&lt;attribute name=&quot;target&quot; type=&quot;i&quot;&gt;5&lt;/attribute&gt;
</code></pre>
<p>This is how the app looks in action:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_menu.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<blockquote>
<p>We changed the icon of the <code>MenuButton</code> by setting its property &quot;icon-name&quot; to &quot;open-menu-symbolic&quot;.
You can find more icons with the <a href="https://apps.gnome.org/app/org.gnome.design.IconLibrary/">Icon Library</a>.
Pre-installed system icons such as &quot;open-menu-symbolic&quot; can be used without additional steps.
We will learn in the <a href="resources.html">resources</a> chapter how to bundle the others.</p>
</blockquote>
<h2 id="settings-1"><a class="header" href="#settings-1">Settings</a></h2>
<p>The menu entries nicely display the state of our stateful actions, but after the app is closed all changes to that state are lost.
As usual, we solve this problem with <code>gio::Settings</code>.
First we create a schema with settings corresponding to the stateful actions we created before.</p>
<p><span class="filename">Filename: listings/actions/7/org.gtk-rs.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk-rs.example&quot; path=&quot;/org/gtk-rs/example/&quot;&gt;
    &lt;key name=&quot;sensitive-button&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;true&lt;/default&gt;
      &lt;summary&gt;Whether the button is sensitive&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name=&quot;orientation&quot; type=&quot;s&quot;&gt;
      &lt;choices&gt;
        &lt;choice value='Horizontal'/&gt;
        &lt;choice value='Vertical'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'Vertical'&lt;/default&gt;
      &lt;summary&gt;Orientation of GtkBox&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Then we add the settings to <code>imp::Window</code>.
Since <code>gio::Settings</code> does not implement <code>Default</code>, we stop deriving <code>Default</code> for <code>imp::Window</code> and implement it manually.</p>
<p><span class="filename">Filename: listings/actions/7/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Button, CompositeTemplate, Label};
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
    #[template_child]
    pub label: TemplateChild&lt;Label&gt;,
    pub settings: Settings,
}

impl Default for Window {
    fn default() -&gt; Self {
        Window {
            gtk_box: TemplateChild::default(),
            button: TemplateChild::default(),
            label: TemplateChild::default(),
            settings: Settings::new(&quot;org.gtk-rs.example&quot;),
        }
    }
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        obj.add_actions();
</span><span class="boring">        obj.bind_settings();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Creating stateful actions from setting entries is so common that <code>Settings</code> provides a method for that exact purpose.
We create actions with <code>create_actions</code> and then add them to the action group of our window.</p>
<p><span class="filename">Filename: listings/actions/7/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_actions(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let label = imp.label.get();
</span><span class="boring">
</span><span class="boring">        // Add stateful action &quot;count&quot; to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = SimpleAction::new_stateful(
</span><span class="boring">            &quot;count&quot;,
</span><span class="boring">            Some(&amp;i32::static_variant_type()),
</span><span class="boring">            &amp;original_state.to_variant(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">            .state()
</span><span class="boring">            .expect(&quot;Could not get state.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The variant needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The variant needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and save state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_count);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;close&quot; to `window` taking no parameter
</span><span class="boring">        let action_close = SimpleAction::new(&quot;close&quot;, None);
</span><span class="boring">
</span><span class="boring">        action_close.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_close);
</span><span class="boring">
</span>        // Create action from key &quot;sensitive-button&quot; and add to action group &quot;win&quot;
        let action_sensitive_button = imp.settings.create_action(&quot;sensitive-button&quot;);
        self.add_action(&amp;action_sensitive_button);

        // Create action from key &quot;orientation&quot; and add to action group &quot;win&quot;
        let action_orientation = imp.settings.create_action(&quot;orientation&quot;);
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Bind setting &quot;sensitive-button&quot; to &quot;sensitive&quot; property of `button`
</span><span class="boring">        let button = imp.button.get();
</span><span class="boring">        imp.settings
</span><span class="boring">            .bind(&quot;sensitive-button&quot;, &amp;button, &quot;sensitive&quot;)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting &quot;orientation&quot; to &quot;orientation&quot; property of `button`
</span><span class="boring">        let gtk_box = imp.gtk_box.get();
</span><span class="boring">        imp.settings
</span><span class="boring">            .bind(&quot;orientation&quot;, &amp;gtk_box, &quot;orientation&quot;)
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect(&quot;The variant needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    &quot;Horizontal&quot; =&gt; Orientation::Horizontal,
</span><span class="boring">                    &quot;Vertical&quot; =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Since actions from <code>create_actions</code> follow the aforementioned conventions, we can keep further changes to a minimum.
The action &quot;win.sensitive-button&quot; toggles its state with each activation and the state of the &quot;win.orientation&quot; action follows the given parameter.</p>
<p>We still have to specify what should happen when the actions are activated though.
For the stateful actions, instead of adding callbacks to their &quot;activate&quot; signals we bind the settings to properties we want to manipulate.</p>
<p><span class="filename">Filename: listings/actions/7/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::SimpleAction;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_actions(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let label = imp.label.get();
</span><span class="boring">
</span><span class="boring">        // Add stateful action &quot;count&quot; to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = SimpleAction::new_stateful(
</span><span class="boring">            &quot;count&quot;,
</span><span class="boring">            Some(&amp;i32::static_variant_type()),
</span><span class="boring">            &amp;original_state.to_variant(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        action_count.connect_activate(clone!(@weak label =&gt; move |action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">            .state()
</span><span class="boring">            .expect(&quot;Could not get state.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The variant needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect(&quot;Could not get parameter.&quot;)
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The variant needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and save state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!(&quot;Counter: {}&quot;, state));
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_count);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;close&quot; to `window` taking no parameter
</span><span class="boring">        let action_close = SimpleAction::new(&quot;close&quot;, None);
</span><span class="boring">
</span><span class="boring">        action_close.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_close);
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;sensitive-button&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_sensitive_button = imp.settings.create_action(&quot;sensitive-button&quot;);
</span><span class="boring">        self.add_action(&amp;action_sensitive_button);
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;orientation&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_orientation = imp.settings.create_action(&quot;orientation&quot;);
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn bind_settings(&amp;self) {
        // Get state
        let imp = self.imp();

        // Bind setting &quot;sensitive-button&quot; to &quot;sensitive&quot; property of `button`
        let button = imp.button.get();
        imp.settings
            .bind(&quot;sensitive-button&quot;, &amp;button, &quot;sensitive&quot;)
            .build();

        // Bind setting &quot;orientation&quot; to &quot;orientation&quot; property of `button`
        let gtk_box = imp.gtk_box.get();
        imp.settings
            .bind(&quot;orientation&quot;, &amp;gtk_box, &quot;orientation&quot;)
            .mapping(|variant, _| {
                let orientation = variant
                    .get::&lt;String&gt;()
                    .expect(&quot;The variant needs to be of type `String`.&quot;);

                let orientation = match orientation.as_str() {
                    &quot;Horizontal&quot; =&gt; Orientation::Horizontal,
                    &quot;Vertical&quot; =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                Some(orientation.to_value())
            })
            .build();
    }
<span class="boring">}
</span></code></pre>
<p>Finally, we make sure that <code>bind_settings</code> is called within <code>constructed</code>.</p>
<p><span class="filename">Filename: listings/actions/7/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Button, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    pub settings: Settings,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Window {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Window {
</span><span class="boring">            gtk_box: TemplateChild::default(),
</span><span class="boring">            button: TemplateChild::default(),
</span><span class="boring">            label: TemplateChild::default(),
</span><span class="boring">            settings: Settings::new(&quot;org.gtk-rs.example&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Setup
        obj.add_actions();
        obj.bind_settings();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Actions are extremely powerful and we are only scratching the surface here.
If you want to learn more about them, the <a href="https://developer.gnome.org/documentation/tutorials/actions.html">GNOME developer documentation</a> is a good place to start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manipulating-state-of-to-do-app"><a class="header" href="#manipulating-state-of-to-do-app">Manipulating State of To-Do App</a></h1>
<h2 id="filtering-tasks"><a class="header" href="#filtering-tasks">Filtering Tasks</a></h2>
<p>Now it is time to continue working on our To-Do app.
One nice feature to add would be filtering of the tasks.
What a chance to use our newly gained knowledge of actions!
Using actions, we can access the filter via the menu as well as via keyboard shortcuts.
This is how we want this to work in the end:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_app_2_animation.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<p>Note that the screencast also shows a button with label &quot;Clear&quot; which will remove all done tasks.
This will come in handy when we later make the app preserve the tasks between sessions.</p>
<p>Let us start by adding a menu and a header bar to <code>window.ui</code>.
After reading the <a href="actions.html">actions</a> chapter the added code should feel familiar.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/window.ui</span></p>
<pre><code class="language-diff"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;interface&gt;
+  &lt;menu id=&quot;main-menu&quot;&gt;
+    &lt;submenu&gt;
+      &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Filtering&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_All&lt;/attribute&gt;
+        &lt;attribute name=&quot;action&quot;&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name=&quot;target&quot;&gt;All&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Open&lt;/attribute&gt;
+        &lt;attribute name=&quot;action&quot;&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name=&quot;target&quot;&gt;Open&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Done&lt;/attribute&gt;
+        &lt;attribute name=&quot;action&quot;&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name=&quot;target&quot;&gt;Done&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/submenu&gt;
+    &lt;item&gt;
+      &lt;attribute name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Keyboard Shortcuts&lt;/attribute&gt;
+      &lt;attribute name=&quot;action&quot;&gt;win.show-help-overlay&lt;/attribute&gt;
+    &lt;/item&gt;
+  &lt;/menu&gt;
   &lt;template class=&quot;TodoWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
     &lt;property name=&quot;width-request&quot;&gt;360&lt;/property&gt;
     &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;To-Do&lt;/property&gt;
+    &lt;child type=&quot;titlebar&quot;&gt;
+      &lt;object class=&quot;GtkHeaderBar&quot;&gt;
+        &lt;child type=&quot;start&quot;&gt;
+          &lt;object class=&quot;GtkButton&quot; id=&quot;clear_button&quot;&gt;
+            &lt;property name=&quot;label&quot;&gt;Clear&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+        &lt;child type =&quot;end&quot;&gt;
+          &lt;object class=&quot;GtkMenuButton&quot; id=&quot;menu_button&quot;&gt;
+            &lt;property name=&quot;icon-name&quot;&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name=&quot;menu-model&quot;&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class=&quot;GtkBox&quot;&gt;
         &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
</code></pre>
<p>We also create a settings schema.
Again, the settings correspond to the stateful actions called by the menu.</p>
<p><span class="filename">Filename: listings/todo_app/2/org.gtk-rs.Todo.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk-rs.Todo&quot; path=&quot;/org/gtk-rs/Todo/&quot;&gt;
    &lt;key name=&quot;filter&quot; type=&quot;s&quot;&gt;
      &lt;choices&gt;
        &lt;choice value='All'/&gt;
        &lt;choice value='Open'/&gt;
        &lt;choice value='Done'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'All'&lt;/default&gt;
      &lt;summary&gt;Filter of the tasks&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Then we add <code>settings</code> and a reference to <code>clear_button</code> to <code>imp::Window</code>.
We stop deriving <code>Default</code> for <code>imp::Window</code> and implement it manually.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Button, CompositeTemplate, Entry, ListView, MenuButton};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub menu_button: TemplateChild&lt;MenuButton&gt;,
    #[template_child]
    pub list_view: TemplateChild&lt;ListView&gt;,
    #[template_child]
    pub clear_button: TemplateChild&lt;Button&gt;,
    pub model: OnceCell&lt;gio::ListStore&gt;,
    pub settings: Settings,
}

impl Default for Window {
    fn default() -&gt; Self {
        Window {
            entry: TemplateChild::default(),
            menu_button: TemplateChild::default(),
            list_view: TemplateChild::default(),
            clear_button: TemplateChild::default(),
            model: OnceCell::default(),
            settings: Settings::new(&quot;org.gtk-rs.Todo&quot;),
        }
    }
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        obj.setup_model();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_shortcut_window();
</span><span class="boring">        obj.setup_filter_action();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self, window: &amp;Self::Type) -&gt; Inhibit {
</span><span class="boring">        // Store todo data in vector
</span><span class="boring">        let mut backup_data = Vec::new();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = window.model().item(position) {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_data = item
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;)
</span><span class="boring">                .todo_data();
</span><span class="boring">            // Add todo data to vector and increase position
</span><span class="boring">            backup_data.push(todo_data);
</span><span class="boring">            position += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Save state in file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer_pretty(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request(window)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>We also add the getter methods <code>is_completed</code> and <code>todo_data</code> to <code>TodoObject</code>.
We will make use of them in the following snippets.</p>
<p><span class="filename">Filename: listings/todo_app/2/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl TodoObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
            .expect(&quot;Failed to create `TodoObject`.&quot;)
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        let imp = self.imp();
        imp.data.borrow().completed
    }

    pub fn todo_data(&amp;self) -&gt; TodoData {
        let imp = self.imp();
        imp.data.borrow().clone()
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Serialize, Deserialize, Clone)]
</span><span class="boring">pub struct TodoData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span></code></pre>
<p>Similar to the previous chapter, we let <code>settings</code> create the action.
Then we add the newly created action &quot;filter&quot; to our window.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = imp.settings.get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
</span><span class="boring">        let selection_model = NoSelection::new(Some(&amp;filter_model));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        imp.settings.connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TodoData&gt; =
</span><span class="boring">                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
</span><span class="boring">            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.model().splice(0, 0, &amp;todo_objects);
</span><span class="boring">        } else {
</span><span class="boring">            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback so that click on the clear_button
</span><span class="boring">        // removes all done tasks
</span><span class="boring">        imp.clear_button
</span><span class="boring">            .connect_clicked(clone!(@weak model =&gt; move |_| {
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = model.item(position) {
</span><span class="boring">                    // Get `TodoObject` from `glib::Object`
</span><span class="boring">                    let todo_object = item
</span><span class="boring">                        .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if todo_object.is_completed() {
</span><span class="boring">                        model.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_shortcut_window(&amp;self) {
</span><span class="boring">        // Get `ShortcutsWindow` via `gtk::Builder`
</span><span class="boring">        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
</span><span class="boring">        let shortcuts = builder
</span><span class="boring">            .object(&quot;shortcuts&quot;)
</span><span class="boring">            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">        // After calling this method,
</span><span class="boring">        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
</span><span class="boring">        self.set_help_overlay(Some(&amp;shortcuts));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_filter_action(&amp;self) {
        // Get state
        let imp = self.imp();

        // Create action from key &quot;filter&quot;
        let filter_action = imp.settings.create_action(&quot;filter&quot;);

        // Add action &quot;filter&quot; to action group &quot;win&quot;
        self.add_action(&amp;filter_action);
    }
<span class="boring">}
</span></code></pre>
<p>After activating the action &quot;win.filter&quot;, the corresponding setting will be changed.
So we need a method which translates this setting into a filter that the <code>gtk::FilterListModel</code> understands.
The possible states are &quot;All&quot;, &quot;Open&quot; and &quot;Done&quot;. 
We return <code>Some(filter)</code> for &quot;Open&quot; and &quot;Done&quot;.
If the state is &quot;All&quot; nothing has to be filtered out, so we return <code>None</code>.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
        // Get state
        let imp = self.imp();

        // Get filter_state from settings
        let filter_state: String = imp.settings.get(&quot;filter&quot;);

        // Create custom filters
        let filter_open = CustomFilter::new(|obj| {
            // Get `TodoObject` from `glib::Object`
            let todo_object = obj
                .downcast_ref::&lt;TodoObject&gt;()
                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);

            // Only allow completed tasks
            !todo_object.is_completed()
        });
        let filter_done = CustomFilter::new(|obj| {
            // Get `TodoObject` from `glib::Object`
            let todo_object = obj
                .downcast_ref::&lt;TodoObject&gt;()
                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);

            // Only allow done tasks
            todo_object.is_completed()
        });

        // Return the correct filter
        match filter_state.as_str() {
            &quot;All&quot; =&gt; None,
            &quot;Open&quot; =&gt; Some(filter_open),
            &quot;Done&quot; =&gt; Some(filter_done),
            _ =&gt; unreachable!(),
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
</span><span class="boring">        let selection_model = NoSelection::new(Some(&amp;filter_model));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        imp.settings.connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TodoData&gt; =
</span><span class="boring">                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
</span><span class="boring">            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.model().splice(0, 0, &amp;todo_objects);
</span><span class="boring">        } else {
</span><span class="boring">            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback so that click on the clear_button
</span><span class="boring">        // removes all done tasks
</span><span class="boring">        imp.clear_button
</span><span class="boring">            .connect_clicked(clone!(@weak model =&gt; move |_| {
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = model.item(position) {
</span><span class="boring">                    // Get `TodoObject` from `glib::Object`
</span><span class="boring">                    let todo_object = item
</span><span class="boring">                        .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if todo_object.is_completed() {
</span><span class="boring">                        model.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_shortcut_window(&amp;self) {
</span><span class="boring">        // Get `ShortcutsWindow` via `gtk::Builder`
</span><span class="boring">        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
</span><span class="boring">        let shortcuts = builder
</span><span class="boring">            .object(&quot;shortcuts&quot;)
</span><span class="boring">            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">        // After calling this method,
</span><span class="boring">        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
</span><span class="boring">        self.set_help_overlay(Some(&amp;shortcuts));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_filter_action(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;filter&quot;
</span><span class="boring">        let filter_action = imp.settings.create_action(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;filter&quot; to action group &quot;win&quot;
</span><span class="boring">        self.add_action(&amp;filter_action);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now, we can set up the model.
We initialize <code>filter_model</code> with the state from the settings by calling the method <code>filter</code>.
Whenever the state of the key &quot;filter&quot; changes, we call the method <code>filter</code> again to get the updated <code>filter_model</code>.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = imp.settings.get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_model(&amp;self) {
        // Create new model
        let model = gio::ListStore::new(TodoObject::static_type());

        // Get state and set model
        let imp = self.imp();
        imp.model.set(model).expect(&quot;Could not set model&quot;);

        // Wrap model with filter and selection and pass it to the list view
        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
        let selection_model = NoSelection::new(Some(&amp;filter_model));
        imp.list_view.set_model(Some(&amp;selection_model));

        // Filter model whenever the value of the key &quot;filter&quot; changes
        imp.settings.connect_changed(
            Some(&quot;filter&quot;),
            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
                filter_model.set_filter(window.filter().as_ref());
            }),
        );
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TodoData&gt; =
</span><span class="boring">                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
</span><span class="boring">            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.model().splice(0, 0, &amp;todo_objects);
</span><span class="boring">        } else {
</span><span class="boring">            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback so that click on the clear_button
</span><span class="boring">        // removes all done tasks
</span><span class="boring">        imp.clear_button
</span><span class="boring">            .connect_clicked(clone!(@weak model =&gt; move |_| {
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = model.item(position) {
</span><span class="boring">                    // Get `TodoObject` from `glib::Object`
</span><span class="boring">                    let todo_object = item
</span><span class="boring">                        .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if todo_object.is_completed() {
</span><span class="boring">                        model.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_shortcut_window(&amp;self) {
</span><span class="boring">        // Get `ShortcutsWindow` via `gtk::Builder`
</span><span class="boring">        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
</span><span class="boring">        let shortcuts = builder
</span><span class="boring">            .object(&quot;shortcuts&quot;)
</span><span class="boring">            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">        // After calling this method,
</span><span class="boring">        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
</span><span class="boring">        self.set_help_overlay(Some(&amp;shortcuts));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_filter_action(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;filter&quot;
</span><span class="boring">        let filter_action = imp.settings.create_action(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;filter&quot; to action group &quot;win&quot;
</span><span class="boring">        self.add_action(&amp;filter_action);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In <code>setup_callbacks</code>, we add a signal handler to <code>clear_button</code>, which removes all completed tasks when activated.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = imp.settings.get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
</span><span class="boring">        let selection_model = NoSelection::new(Some(&amp;filter_model));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        imp.settings.connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TodoData&gt; =
</span><span class="boring">                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
</span><span class="boring">            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.model().splice(0, 0, &amp;todo_objects);
</span><span class="boring">        } else {
</span><span class="boring">            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_callbacks(&amp;self) {
        // Get state
        let imp = self.imp();
        let model = self.model();

        // Setup callback so that activation
        // creates a new todo object and clears the entry
        imp.entry
            .connect_activate(clone!(@weak model =&gt; move |entry| {
                let buffer = entry.buffer();
                let content = buffer.text();
                let todo_object = TodoObject::new(false, content);
                model.append(&amp;todo_object);
                buffer.set_text(&quot;&quot;);
            }));

        // Setup callback so that click on the clear_button
        // removes all done tasks
        imp.clear_button
            .connect_clicked(clone!(@weak model =&gt; move |_| {
                let mut position = 0;
                while let Some(item) = model.item(position) {
                    // Get `TodoObject` from `glib::Object`
                    let todo_object = item
                        .downcast_ref::&lt;TodoObject&gt;()
                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);

                    if todo_object.is_completed() {
                        model.remove(position);
                    } else {
                        position += 1;
                    }
                }
            }));
    }
<span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_shortcut_window(&amp;self) {
</span><span class="boring">        // Get `ShortcutsWindow` via `gtk::Builder`
</span><span class="boring">        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
</span><span class="boring">        let shortcuts = builder
</span><span class="boring">            .object(&quot;shortcuts&quot;)
</span><span class="boring">            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">        // After calling this method,
</span><span class="boring">        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
</span><span class="boring">        self.set_help_overlay(Some(&amp;shortcuts));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_filter_action(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;filter&quot;
</span><span class="boring">        let filter_action = imp.settings.create_action(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;filter&quot; to action group &quot;win&quot;
</span><span class="boring">        self.add_action(&amp;filter_action);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In <code>setup_shortcut_window</code>, we add a handy way to let users of our app know which shortcuts they can use.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = imp.settings.get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
</span><span class="boring">        let selection_model = NoSelection::new(Some(&amp;filter_model));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        imp.settings.connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TodoData&gt; =
</span><span class="boring">                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
</span><span class="boring">            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.model().splice(0, 0, &amp;todo_objects);
</span><span class="boring">        } else {
</span><span class="boring">            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback so that click on the clear_button
</span><span class="boring">        // removes all done tasks
</span><span class="boring">        imp.clear_button
</span><span class="boring">            .connect_clicked(clone!(@weak model =&gt; move |_| {
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = model.item(position) {
</span><span class="boring">                    // Get `TodoObject` from `glib::Object`
</span><span class="boring">                    let todo_object = item
</span><span class="boring">                        .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if todo_object.is_completed() {
</span><span class="boring">                        model.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_shortcut_window(&amp;self) {
        // Get `ShortcutsWindow` via `gtk::Builder`
        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
        let shortcuts = builder
            .object(&quot;shortcuts&quot;)
            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);

        // After calling this method,
        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
        self.set_help_overlay(Some(&amp;shortcuts));
    }
<span class="boring">
</span><span class="boring">    fn setup_filter_action(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;filter&quot;
</span><span class="boring">        let filter_action = imp.settings.create_action(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;filter&quot; to action group &quot;win&quot;
</span><span class="boring">        self.add_action(&amp;filter_action);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The entries can be organized with <a href="../docs/gtk4/struct.ShortcutsSection.html"><code>gtk::ShortcutsSection</code></a> and <a href="../docs/gtk4/struct.ShortcutsGroup.html"><code>gtk::ShortcutsGroup</code></a>.
If we specify the action name, we also do not have to repeat the keyboard accelerator.
<a href="../docs/gtk4/struct.ShortcutsShortcut.html"><code>gtk::ShortcutsShortcut</code></a> looks it up on its own.
The <code>shortcuts.ui</code> file looks like this:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkShortcutsWindow&quot; id=&quot;shortcuts&quot;&gt;
    &lt;property name=&quot;modal&quot;&gt;True&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkShortcutsSection&quot;&gt;
        &lt;property name=&quot;section-name&quot;&gt;shortcuts&lt;/property&gt;
        &lt;property name=&quot;max-height&quot;&gt;10&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkShortcutsGroup&quot;&gt;
            &lt;property name=&quot;title&quot; translatable=&quot;yes&quot; context=&quot;shortcut window&quot;&gt;General&lt;/property&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkShortcutsShortcut&quot;&gt;
                &lt;property name=&quot;title&quot; translatable=&quot;yes&quot; context=&quot;shortcut window&quot;&gt;Show shortcuts&lt;/property&gt;
                &lt;property name=&quot;action-name&quot;&gt;win.show-help-overlay&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkShortcutsShortcut&quot;&gt;
                &lt;property name=&quot;title&quot; translatable=&quot;yes&quot; context=&quot;shortcut window&quot;&gt;Filter to show all tasks&lt;/property&gt;
                &lt;property name=&quot;action-name&quot;&gt;win.filter('All')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkShortcutsShortcut&quot;&gt;
                &lt;property name=&quot;title&quot; translatable=&quot;yes&quot; context=&quot;shortcut window&quot;&gt;Filter to show only open tasks&lt;/property&gt;
                &lt;property name=&quot;action-name&quot;&gt;win.filter('Open')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkShortcutsShortcut&quot;&gt;
                &lt;property name=&quot;title&quot; translatable=&quot;yes&quot; context=&quot;shortcut window&quot;&gt;Filter to show only completed tasks&lt;/property&gt;
                &lt;property name=&quot;action-name&quot;&gt;win.filter('Done')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<blockquote>
<p>Note the way we set <code>action-name</code> for <code>ShortcutsShortcut</code>.
Instead of using a separate property for the target, it takes a <em>detailed</em> action name.
Detailed names look like this: <code>action_group.action_name(target)</code>.
Formatting of the target depends on its type and is documented <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html#method.parse_detailed_name">here</a>.
In particular, strings have to be enclosed single quotes as you can see in this example.</p>
</blockquote>
<p>Finally, we bind the shortcuts to their actions with <code>set_accels_for_action</code>.
Here as well, a detailed action name is used.
Since this has to be done at the application level, <code>setup_shortcuts</code> takes a <code>gtk::Application</code> as parameter.</p>
<p><span class="filename">Filename: listings/todo_app/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod todo_object;
</span><span class="boring">mod todo_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">
</span><span class="boring">use window::Window;
</span><span class="boring">
</span>fn main() {
    // Initialize logger
    pretty_env_logger::init();

    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.Todo&quot;)
        .build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn setup_shortcuts(app: &amp;Application) {
    app.set_accels_for_action(&quot;win.filter('All')&quot;, &amp;[&quot;&lt;primary&gt;a&quot;]);
    app.set_accels_for_action(&quot;win.filter('Open')&quot;, &amp;[&quot;&lt;primary&gt;o&quot;]);
    app.set_accels_for_action(&quot;win.filter('Done')&quot;, &amp;[&quot;&lt;primary&gt;d&quot;]);
    app.set_accels_for_action(&quot;win.show-help-overlay&quot;, &amp;[&quot;&lt;primary&gt;question&quot;]);
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and show it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre>
<h2 id="saving-and-restoring-tasks"><a class="header" href="#saving-and-restoring-tasks">Saving and Restoring Tasks</a></h2>
<p>Since we use <code>Settings</code>, our filter state will persist between sessions.
However, the tasks themselves will not.
Let us implement that.</p>
<p>We could store our tasks in <code>Settings</code>, but it would be inconvenient.
When it comes to serializing and deserializing nothing beats the crate <a href="https://lib.rs/crates/serde"><code>serde</code></a>.
Combined with <a href="https://lib.rs/crates/serde_json"><code>serde_json</code></a> we can save our tasks as serialized <a href="https://en.wikipedia.org/wiki/JSON">json</a> files
First, we extend our <code>Cargo.toml</code> with the <code>serde</code> and <code>serde_json</code> crate.</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
</code></pre>
<p>Serde is a framework for serializing and deserializing Rust data structures.
The <code>derive</code> feature allows us to make our structures (de-)serializable with a single line of code.
We also use the <code>rc</code> feature so that Serde can deal with <code>std::rc::Rc</code> objects.</p>
<p>This is why we stored the data of <code>TodoObject</code> in a distinct <code>TodoData</code> structure.
Doing so allows us to derive <code>Serialize</code> and <code>Deserialize</code> for <code>TodoData</code>.</p>
<p><span class="filename">Filename: listings/todo_app/2/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
</span><span class="boring">            .expect(&quot;Failed to create `TodoObject`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn is_completed(&amp;self) -&gt; bool {
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.data.borrow().completed
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn todo_data(&amp;self) -&gt; TodoData {
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.data.borrow().clone()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Serialize, Deserialize, Clone)]
pub struct TodoData {
    pub completed: bool,
    pub content: String,
}
</code></pre>
<p>We plan to store our data as a file, so we create a utility function to provide a suitable file path for us.
We use <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.user_data_dir.html"><code>glib::user_data_dir</code></a> to get the path to the config directory and create a new subdirectory for our app.
Then we return the file path.</p>
<p><span class="filename">Filename: listings/todo_app/2/utils.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>pub fn data_path() -&gt; PathBuf {
    let mut path = glib::user_data_dir();
    path.push(&quot;org.gtk-rs.Todo&quot;);
    std::fs::create_dir_all(&amp;path).expect(&quot;Could not create directory.&quot;);
    path.push(&quot;data.json&quot;);
    path
}
</code></pre>
<p>We override the <code>close_request</code> virtual function to save the tasks when the window is closed.
To do so, we first iterate through all entries and store them in a <code>Vec</code>.
Then we serialize the <code>Vec</code> and store the data as a json file.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Button, CompositeTemplate, Entry, ListView, MenuButton};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub menu_button: TemplateChild&lt;MenuButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub list_view: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub clear_button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    pub model: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub settings: Settings,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Window {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Window {
</span><span class="boring">            entry: TemplateChild::default(),
</span><span class="boring">            menu_button: TemplateChild::default(),
</span><span class="boring">            list_view: TemplateChild::default(),
</span><span class="boring">            clear_button: TemplateChild::default(),
</span><span class="boring">            model: OnceCell::default(),
</span><span class="boring">            settings: Settings::new(&quot;org.gtk-rs.Todo&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        obj.setup_model();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_shortcut_window();
</span><span class="boring">        obj.setup_filter_action();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self, window: &amp;Self::Type) -&gt; Inhibit {
        // Store todo data in vector
        let mut backup_data = Vec::new();
        let mut position = 0;
        while let Some(item) = window.model().item(position) {
            // Get `TodoObject` from `glib::Object`
            let todo_data = item
                .downcast_ref::&lt;TodoObject&gt;()
                .expect(&quot;The object needs to be of type `TodoObject`.&quot;)
                .todo_data();
            // Add todo data to vector and increase position
            backup_data.push(todo_data);
            position += 1;
        }

        // Save state in file
        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
        serde_json::to_writer_pretty(file, &amp;backup_data)
            .expect(&quot;Could not write data to json file&quot;);

        // Pass close request on to the parent
        self.parent_close_request(window)
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Note that we used <a href="https://docs.serde.rs/serde_json/fn.to_writer_pretty.html"><code>serde_json::to_writer_pretty</code></a> here.
The <code>pretty</code> suffix suggests that the json file is formatted in a readable way.
For your own app you might not care about this and go for <a href="https://docs.serde.rs/serde_json/fn.to_writer.html"><code>serde_json::to_writer</code></a> which produces smaller files.
For this example we like it, because it allows us to see into what a <code>Vec&lt;TodoData&gt;</code> will be serialized.</p>
<p><span class="filename">Filename: data.json</span></p>
<pre><code class="language-json">[
  {
    &quot;completed&quot;: true,
    &quot;content&quot;: &quot;Task Number Two&quot;
  },
  {
    &quot;completed&quot;: false,
    &quot;content&quot;: &quot;Task Number Five&quot;
  },
  {
    &quot;completed&quot;: true,
    &quot;content&quot;: &quot;Task Number Six&quot;
  },
  {
    &quot;completed&quot;: false,
    &quot;content&quot;: &quot;Task Number Seven&quot;
  },
  {
    &quot;completed&quot;: false,
    &quot;content&quot;: &quot;Task Number Eight&quot;
  }
]
</code></pre>
<p>When we start the app, we will want to restore the saved data.
Let us add a <code>restore_data</code> method for that.
We make sure to handle the case where there is no data file there yet.
It might be the first time that we started the app and therefore there is no former session to restore.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::{TodoData, TodoObject};
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory};
</span><span class="boring">use log::info;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = imp.settings.get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_object = obj
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            todo_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.model()), self.filter().as_ref());
</span><span class="boring">        let selection_model = NoSelection::new(Some(&amp;filter_model));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        imp.settings.connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;TodoData&gt; =
                serde_json::from_reader(file).expect(&quot;Could not get backup data from json file.&quot;);

            // Convert `Vec&lt;TodoData&gt;` to `Vec&lt;TodoObject&gt;`
            let todo_objects: Vec&lt;TodoObject&gt; = backup_data
                .into_iter()
                .map(|todo_data| TodoObject::new(todo_data.completed, todo_data.content))
                .collect();

            // Insert restored objects into model
            self.model().splice(0, 0, &amp;todo_objects);
        } else {
            info!(&quot;Backup file does not exist yet {:?}&quot;, data_path());
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback so that click on the clear_button
</span><span class="boring">        // removes all done tasks
</span><span class="boring">        imp.clear_button
</span><span class="boring">            .connect_clicked(clone!(@weak model =&gt; move |_| {
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = model.item(position) {
</span><span class="boring">                    // Get `TodoObject` from `glib::Object`
</span><span class="boring">                    let todo_object = item
</span><span class="boring">                        .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if todo_object.is_completed() {
</span><span class="boring">                        model.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_shortcut_window(&amp;self) {
</span><span class="boring">        // Get `ShortcutsWindow` via `gtk::Builder`
</span><span class="boring">        let builder = gtk::Builder::from_string(include_str!(&quot;shortcuts.ui&quot;));
</span><span class="boring">        let shortcuts = builder
</span><span class="boring">            .object(&quot;shortcuts&quot;)
</span><span class="boring">            .expect(&quot;Could not get object `shortcuts` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">        // After calling this method,
</span><span class="boring">        // calling the action &quot;win.show-help-overlay&quot; will show the shortcut window
</span><span class="boring">        self.set_help_overlay(Some(&amp;shortcuts));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_filter_action(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Create action from key &quot;filter&quot;
</span><span class="boring">        let filter_action = imp.settings.create_action(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Add action &quot;filter&quot; to action group &quot;win&quot;
</span><span class="boring">        self.add_action(&amp;filter_action);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Finally, we make sure that everything is set up in <code>constructed</code>.</p>
<p><span class="filename">Filename: listings/todo_app/2/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Button, CompositeTemplate, Entry, ListView, MenuButton};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub menu_button: TemplateChild&lt;MenuButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub list_view: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub clear_button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    pub model: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub settings: Settings,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Window {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Window {
</span><span class="boring">            entry: TemplateChild::default(),
</span><span class="boring">            menu_button: TemplateChild::default(),
</span><span class="boring">            list_view: TemplateChild::default(),
</span><span class="boring">            clear_button: TemplateChild::default(),
</span><span class="boring">            model: OnceCell::default(),
</span><span class="boring">            settings: Settings::new(&quot;org.gtk-rs.Todo&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        Self::bind_template(klass);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Setup
        obj.setup_model();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_factory();
        obj.setup_shortcut_window();
        obj.setup_filter_action();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self, window: &amp;Self::Type) -&gt; Inhibit {
</span><span class="boring">        // Store todo data in vector
</span><span class="boring">        let mut backup_data = Vec::new();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = window.model().item(position) {
</span><span class="boring">            // Get `TodoObject` from `glib::Object`
</span><span class="boring">            let todo_data = item
</span><span class="boring">                .downcast_ref::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TodoObject`.&quot;)
</span><span class="boring">                .todo_data();
</span><span class="boring">            // Add todo data to vector and increase position
</span><span class="boring">            backup_data.push(todo_data);
</span><span class="boring">            position += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Save state in file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer_pretty(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request(window)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Our To-Do app suddenly became much more useful.
Not only can we filter tasks, we also retain our tasks between sessions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css"><a class="header" href="#css">CSS</a></h1>
<p>When you want to modify the style of your website, you use <a href="https://de.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>.
Similarly, GTK supports its own variant of CSS in order to style your app.</p>
<blockquote>
<p>We will not explain every piece of syntax used in this chapter.
If you are new to CSS or just need a refresher, have a look at the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax">MDN Web Docs</a>.</p>
</blockquote>
<p>Let us say we have a button and we want to set its font color to magenta.
Every type of widget has a corresponding CSS node.
In the case of <code>gtk::Button</code>, this node is called <code>button</code>.
Therefore, we create a <code>style.css</code> file with the following content:</p>
<p><span class="filename">Filename: listings/css/1/style.css</span></p>
<pre><code class="language-css">button {
  color: magenta;
}
</code></pre>
<p>Next, we need to load the CSS file in the startup step of the application.
As usual, the widgets are created during the &quot;activate&quot; step.</p>
<p><span class="filename">Filename: listings/css/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::gdk;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, CssProvider, StyleContext};
</span><span class="boring">
</span>fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to signals
    app.connect_startup(|_| load_css());
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_data(include_bytes!(&quot;style.css&quot;));

    // Add the provider to the default screen
    StyleContext::add_provider_for_display(
        &amp;Display::default().expect(&quot;Could not connect to a display.&quot;),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}

fn build_ui(app: &amp;Application) {
    // Create button
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Create a new window and show it
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();
    window.show();
}
</code></pre>
<p>When we now run the app, we notice that our button <em>and</em> the &quot;close&quot; button are magenta.
Probably not what we wanted, but that is what our CSS snippet does.
We did not specify for which button the rule should apply, so it was applied to both of them.</p>
<div style="text-align:center"><img src="img/css_1.png"/></div>
<blockquote>
<p>The <code>GtkInspector</code> comes in quite handy (not only) when playing with CSS.
Make sure that the window of your app is focused and press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>.
A window will pop up which lets you browse and even manipulate the state of your app.
Open the CSS view and override the button color with the following snippet.</p>
<pre><code class="language-css">button {
 color: blue;
}
</code></pre>
<p>With the pause button you can toggle whether your CSS code is active or not.</p>
</blockquote>
<h2 id="style-classes-applied-by-gtk"><a class="header" href="#style-classes-applied-by-gtk">Style Classes Applied by GTK</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">Class selectors</a> are one way to choose which specific elements a CSS rule applies to.
GTK adds style classes to many of its widgets, often depending on their content.
A <a href="../docs/gtk4/struct.Button.html#css-nodes"><code>gtk::Button</code></a>, for example, will get the <code>text-button</code> style class when its content is a label.
That is why we create a new CSS rule which only applies to <code>button</code> nodes with the style class <code>text_button</code>.</p>
<p><span class="filename">Filename: listings/css/2/style.css</span></p>
<pre><code class="language-css">button.text-button {
  color: magenta;
}
</code></pre>
<p>Now only the font of our button becomes magenta.</p>
<div style="text-align:center"><img src="img/css_2.png"/></div>
<h2 id="adding-your-own-style-class"><a class="header" href="#adding-your-own-style-class">Adding Your Own Style Class</a></h2>
<p>With <a href="../docs/gtk4/prelude/trait.WidgetExt.html#tymethod.add_css_class"><code>add_css_class</code></a> we can also add our own style classes to widgets.
One use-case for this is when you want a rule to apply to a hand-picked set of widgets.
For example if we have two buttons, but want only one of them to have magenta font.
Relying on one of the style classes which GTK adds will not help since both will get the same ones.
Which is why we add the style class <code>button-1</code> to the first one.</p>
<p><span class="filename">Filename: listings/css/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::gdk;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, CssProvider, StyleContext};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_data(include_bytes!(&quot;style.css&quot;));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    StyleContext::add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect(&quot;Could not connect to a display.&quot;),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label(&quot;Press me!&quot;);
    let button_2 = Button::with_label(&quot;Press me!&quot;);

    button_1.add_css_class(&quot;button_1&quot;);
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and show it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre>
<p>Then, we create a CSS rule that applies to <code>button</code> nodes with the style class <code>button-1</code>.</p>
<p><span class="filename">Filename: listings/css/3/style.css</span></p>
<pre><code class="language-css">button.button-1 {
  color: magenta;
}
</code></pre>
<p>We can see that this way only the first button gets colored magenta.</p>
<div style="text-align:center"><img src="img/css_3.png"/></div>
<h2 id="specifying-name-of-a-widget"><a class="header" href="#specifying-name-of-a-widget">Specifying Name of a Widget</a></h2>
<p>If you want that your rule only applies to a single widget, matching with style classes can be fine.
Ideally however, you would give the widget a name and match with that name instead.
This way your intentions are more clear, compared to matching with style classes that can apply to multiple widgets. </p>
<p>Again, we have two buttons but want to color only one of them magenta.
We set the name of the first one with <a href="../docs/gtk4/prelude/trait.WidgetExt.html#tymethod.set_widget_name"><code>set_widget_name</code></a>.</p>
<p><span class="filename">Filename: listings/css/4/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::gdk;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button, CssProvider, StyleContext};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_data(include_bytes!(&quot;style.css&quot;));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    StyleContext::add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect(&quot;Could not connect to a display.&quot;),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label(&quot;Press me!&quot;);
    let button_2 = Button::with_label(&quot;Press me!&quot;);

    button_1.set_widget_name(&quot;button-1&quot;);
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and show it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre>
<p>Then, create a CSS rule that applies to <code>button</code> nodes with the name <code>button-1</code>.
The name is specified after the <code>#</code> symbol.</p>
<p><span class="filename">Filename: listings/css/4/style.css</span></p>
<pre><code class="language-css">button#button-1 {
  color: magenta;
}
</code></pre>
<p>Again, the style rule only applies to the first button.</p>
<div style="text-align:center"><img src="img/css_4.png"/></div>
<h2 id="css-rules-provided-by-gtk"><a class="header" href="#css-rules-provided-by-gtk">CSS Rules Provided by GTK</a></h2>
<p>Certain styles are common enough that GTK provides CSS rules for them.
For example, if you want to indicate that your button leads to a destructive or suggested action you do not have to provide your own CSS rules.
All you have to do is to add &quot;destructive-action&quot; or &quot;suggested-action&quot; style class to your button.
Most widgets will document these rules in their documentation under <a href="../docs/gtk4/struct.Button.html#css-nodes">CSS nodes</a>.</p>
<p><span class="filename">Filename: listings/css/5/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label(&quot;Destructive&quot;);
    let button_2 = Button::with_label(&quot;Suggested&quot;);

    button_1.add_css_class(&quot;destructive-action&quot;);
    button_2.add_css_class(&quot;suggested-action&quot;);
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(6)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and show it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre>
<div style="text-align:center"><img src="img/css_5.png"/></div>
<h2 id="interface-builder-1"><a class="header" href="#interface-builder-1">Interface Builder</a></h2>
<p>We can also add style classes with the interface builder.
Just add the <code>&lt;style&gt;</code> element to your widget.
The <code>&lt;style&gt;</code> element is documented together with <a href="../docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>gtk::Widget</code></a>.
Adding again destructive and suggested buttons, would then look like this:</p>
<p><span class="filename">Filename: listings/css/6/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkBox&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkButton&quot;&gt;
            &lt;property name=&quot;label&quot;&gt;Destructive&lt;/property&gt;
            &lt;style&gt;
              &lt;class name=&quot;destructive-action&quot;/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkButton&quot;&gt;
            &lt;property name=&quot;label&quot;&gt;Suggested&lt;/property&gt;
            &lt;style&gt;
              &lt;class name=&quot;suggested-action&quot;/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="pseudo-classes"><a class="header" href="#pseudo-classes">Pseudo-classes</a></h2>
<p>Sometimes you want your CSS rules to apply under even more precise conditions than style classes allow.
That is where <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">pseudo-classes</a> come in.
Let us use a single button with name <code>button-1</code> to demonstrate this concept.</p>
<p><span class="filename">Filename: listings/css/7/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkButton&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Hover over me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;name&quot;&gt;button-1&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>By adding the pseudo-class <code>hover</code>, we say that we want this rule to only apply to a <code>button</code> node with name <code>button-1</code> when hovering over it with the mouse pointer.</p>
<p><span class="filename">Filename: listings/css/7/style.css</span></p>
<pre><code class="language-css">button#button-1:hover {
  color: magenta;
  background: yellow;
}
</code></pre>
<p>If we now hover over the button, we see that over the span of one second its background turns yellow and its font turns magenta.
After we removed the cursor, the button returns to its original state.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/css_6.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>In the previous examples, a widget always corresponded to a single CSS node.
This is not always the case.
For example, <a href="../docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> has multiple CSS nodes.
Let us see how that works.</p>
<p>First, we create a single <code>MenuButton</code>.</p>
<p><span class="filename">Filename: listings/css/8/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkMenuButton&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>You can make a <code>MenuButton</code> show an icon or a label.
If you choose to do neither of those, as we currently do, it shows an image displaying an arrow.</p>
<p>An inheritance tree of <a href="../docs/gtk4/struct.MenuButton.html#css-nodes">CSS nodes</a> displays this situation:</p>
<pre><code>menubutton
╰── button.toggle
    ╰── &lt;content&gt;
         ╰── [arrow]
</code></pre>
<p>We see that the <code>menubutton</code> node has children, which themselves have children and attached style classes.
Now we know that we have to add a CSS rule that applies to the <code>arrow</code> node, which is a descendant of <code>menubutton</code>.</p>
<p><span class="filename">Filename: listings/css/8/style.css</span></p>
<pre><code class="language-css">menubutton arrow {
  color: magenta;
}
</code></pre>
<p>Indeed, we get a <code>MenuButton</code> with a magenta arrow.</p>
<div style="text-align:center"><img src="img/css_8.png"/></div>
<h2 id="exported-colors"><a class="header" href="#exported-colors">Exported Colors</a></h2>
<p>Now that we know how to use CSS, it is time to update our To-Do app.
Before, the individual tasks were a bit hard to distinguish.
It would be nice if the todo rows would be surrounded by borders.
Let us add that!</p>
<p>The class <code>TodoRow</code> inherits from <code>gtk::Box</code>, so we could just match for the node <code>box</code>.
However, if we create a custom widget we might as well give it its own CSS name.
Keep in mind, that this is not the same as when we gave a specific instance of a widget a name.
When calling <a href="../docs/gtk4/subclass/widget/trait.WidgetClassSubclassExt.html#method.set_css_name"><code>set_css_name</code> </a>, we change the name of the CSS node of a widget.
In our case, the widget <code>TodoRow</code> now corresponds to the node <code>todo-row</code>.</p>
<p><span class="filename">Filename: listings/todo_app/3/todo_row/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default, CompositeTemplate)]
</span><span class="boring">#[template(file = &quot;todo_row.ui&quot;)]
</span><span class="boring">pub struct TodoRow {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub completed_button: TemplateChild&lt;CheckButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub content_label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    // Vector holding the bindings to properties of `TodoObject`
</span><span class="boring">    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TodoRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoRow&quot;;
    type Type = super::TodoRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        Self::bind_template(klass);
        klass.set_css_name(&quot;todo-row&quot;);
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TodoRow {}
</span></code></pre>
<p>Now we have to decide which color to use for the borders.
Luckily, the stylesheet that GTK uses provides pre-defined colors for various use-cases.
As of this writing, the exported colors of the default stylesheet can only be found in its <a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/b2c227e9c57839a2a4e24462a71ae0bad9a95264/gtk/theme/Default/_colors-public.scss">source code</a>.</p>
<p>There we find the color <code>borders</code>, which should be used for the widget's border color.
We can then access the pre-defined color by adding an <code>@</code> in front of its name.</p>
<p><span class="filename">Filename: listings/todo_app/3/style.css</span></p>
<pre><code class="language-css">todo-row {
  border: 1px solid @borders;
}
</code></pre>
<p>Now our tasks have borders around them, and we are one step further in finishing our To-Do app.</p>
<div style="text-align:center"><img src="img/todo_app_change.png"/></div>
<p>This was also an excellent opportunity to show how to set the CSS name of custom widget and how to access exported colors.
In the end, we find that GTK provides a style rule to add borders to a node.
This seems nicer, so we will use that instead.
We match the style rule by adding the style class <code>frame</code> to our <code>TodoRow</code>.</p>
<p><span class="filename">Filename: listings/todo_app/4/todo_row/todo_row.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;TodoRow&quot; parent=&quot;GtkBox&quot;&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkCheckButton&quot; id=&quot;completed_button&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkLabel&quot; id=&quot;content_label&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;style&gt;
      &lt;class name=&quot;frame&quot;/&gt;
    &lt;/style&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>There are surely enough ways to define CSS rules.
Let us briefly recap the syntax we learned.
The following rule matches the node <code>arrow</code>, which is a descendant of the node <code>button</code> with the name <code>button-1</code> and the style classes <code>toggle</code> and <code>text-button</code>.
The rule then actually applies, when we also hover over <code>arrow</code>.</p>
<pre><code class="language-css">button#button-1.toggle.text-button arrow:hover {
  color: magenta;
}
</code></pre>
<p>When the rule applies, the <code>color</code> parameter will be set to magenta.
You can find the full list of supported parameters in GTK's <a href="https://docs.gtk.org/gtk4/css-properties.html#gtk-css-properties">documentation</a>.</p>
<p>In the following chapter we will learn how to make a binary bundle with CSS files, icons and any other resources that our app might need at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
