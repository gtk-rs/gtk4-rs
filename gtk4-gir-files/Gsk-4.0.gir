<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="Gdk" version="4.0"/>
  <include name="Graphene" version="1.0"/>
  <package name="gtk4"/>
  <c:include name="gsk/gsk.h"/>
  <namespace name="Gsk" version="4.0" shared-library="libgtk-4.so.1" c:identifier-prefixes="Gsk" c:symbol-prefixes="gsk">
    <function-macro name="BROADWAY_RENDERER" c:identifier="GSK_BROADWAY_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_CLASS" c:identifier="GSK_BROADWAY_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_GET_CLASS" c:identifier="GSK_BROADWAY_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="BlendMode" glib:type-name="GskBlendMode" glib:get-type="gsk_blend_mode_get_type" c:type="GskBlendMode">
      <doc xml:space="preserve">The blend modes available for render nodes.

The implementation of each blend mode is deferred to the
rendering pipeline.

See https://www.w3.org/TR/compositing-1/#blending for more information
on blending and blend modes.</doc>
      <member name="default" value="0" c:identifier="GSK_BLEND_MODE_DEFAULT" glib:nick="default">
        <doc xml:space="preserve">The default blend mode, which specifies no blending</doc>
      </member>
      <member name="multiply" value="1" c:identifier="GSK_BLEND_MODE_MULTIPLY" glib:nick="multiply">
        <doc xml:space="preserve">The source color is multiplied by the destination
  and replaces the destination</doc>
      </member>
      <member name="screen" value="2" c:identifier="GSK_BLEND_MODE_SCREEN" glib:nick="screen">
        <doc xml:space="preserve">Multiplies the complements of the destination and source
  color values, then complements the result.</doc>
      </member>
      <member name="overlay" value="3" c:identifier="GSK_BLEND_MODE_OVERLAY" glib:nick="overlay">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the
  destination color value. This is the inverse of hard-list</doc>
      </member>
      <member name="darken" value="4" c:identifier="GSK_BLEND_MODE_DARKEN" glib:nick="darken">
        <doc xml:space="preserve">Selects the darker of the destination and source colors</doc>
      </member>
      <member name="lighten" value="5" c:identifier="GSK_BLEND_MODE_LIGHTEN" glib:nick="lighten">
        <doc xml:space="preserve">Selects the lighter of the destination and source colors</doc>
      </member>
      <member name="color_dodge" value="6" c:identifier="GSK_BLEND_MODE_COLOR_DODGE" glib:nick="color-dodge">
        <doc xml:space="preserve">Brightens the destination color to reflect the source color</doc>
      </member>
      <member name="color_burn" value="7" c:identifier="GSK_BLEND_MODE_COLOR_BURN" glib:nick="color-burn">
        <doc xml:space="preserve">Darkens the destination color to reflect the source color</doc>
      </member>
      <member name="hard_light" value="8" c:identifier="GSK_BLEND_MODE_HARD_LIGHT" glib:nick="hard-light">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the source color value</doc>
      </member>
      <member name="soft_light" value="9" c:identifier="GSK_BLEND_MODE_SOFT_LIGHT" glib:nick="soft-light">
        <doc xml:space="preserve">Darkens or lightens the colors, depending on the source color value</doc>
      </member>
      <member name="difference" value="10" c:identifier="GSK_BLEND_MODE_DIFFERENCE" glib:nick="difference">
        <doc xml:space="preserve">Subtracts the darker of the two constituent colors from the lighter color</doc>
      </member>
      <member name="exclusion" value="11" c:identifier="GSK_BLEND_MODE_EXCLUSION" glib:nick="exclusion">
        <doc xml:space="preserve">Produces an effect similar to that of the difference mode but lower in contrast</doc>
      </member>
      <member name="color" value="12" c:identifier="GSK_BLEND_MODE_COLOR" glib:nick="color">
        <doc xml:space="preserve">Creates a color with the hue and saturation of the source color and the luminosity of the destination color</doc>
      </member>
      <member name="hue" value="13" c:identifier="GSK_BLEND_MODE_HUE" glib:nick="hue">
        <doc xml:space="preserve">Creates a color with the hue of the source color and the saturation and luminosity of the destination color</doc>
      </member>
      <member name="saturation" value="14" c:identifier="GSK_BLEND_MODE_SATURATION" glib:nick="saturation">
        <doc xml:space="preserve">Creates a color with the saturation of the source color and the hue and luminosity of the destination color</doc>
      </member>
      <member name="luminosity" value="15" c:identifier="GSK_BLEND_MODE_LUMINOSITY" glib:nick="luminosity">
        <doc xml:space="preserve">Creates a color with the luminosity of the source color and the hue and saturation of the destination color</doc>
      </member>
    </enumeration>
    <class name="BlendNode" c:symbol-prefix="blend_node" c:type="GskBlendNode" parent="RenderNode" glib:type-name="GskBlendNode" glib:get-type="gsk_blend_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a blending function between its two child nodes.</doc>
      <constructor name="new" c:identifier="gsk_blend_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will use @blend_mode to blend the @top
node onto the @bottom node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="BlendNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">The bottom node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">The node to be blended onto the @bottom node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="blend_mode" transfer-ownership="none">
            <doc xml:space="preserve">The blend mode to use</doc>
            <type name="BlendMode" c:type="GskBlendMode"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blend_mode" c:identifier="gsk_blend_node_get_blend_mode">
        <doc xml:space="preserve">Retrieves the blend mode used by @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blend mode</doc>
          <type name="BlendMode" c:type="GskBlendMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bottom_child" c:identifier="gsk_blend_node_get_bottom_child">
        <doc xml:space="preserve">Retrieves the bottom #GskRenderNode child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bottom child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_top_child" c:identifier="gsk_blend_node_get_top_child">
        <doc xml:space="preserve">Retrieves the top #GskRenderNode child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the top child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending #GskRenderNode</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BlurNode" c:symbol-prefix="blur_node" c:type="GskBlurNode" parent="RenderNode" glib:type-name="GskBlurNode" glib:get-type="gsk_blur_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a blur effect to its single child.</doc>
      <constructor name="new" c:identifier="gsk_blur_node_new">
        <doc xml:space="preserve">Creates a render node that blurs the child.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GskRenderNode</doc>
          <type name="BlurNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">the child node to blur</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the blur radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_blur_node_get_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode of the blur @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blurred child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur #GskRenderNode</doc>
            <type name="BlurNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_radius" c:identifier="gsk_blur_node_get_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur #GskRenderNode</doc>
            <type name="BlurNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BorderNode" c:symbol-prefix="border_node" c:type="GskBorderNode" parent="RenderNode" glib:type-name="GskBorderNode" glib:get-type="gsk_border_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a border.</doc>
      <constructor name="new" c:identifier="gsk_border_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will stroke a border rectangle inside the
given @outline. The 4 sides of the border can have different widths and
colors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="BorderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect describing the outline of the border</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="border_width" transfer-ownership="none">
            <doc xml:space="preserve">the stroke width of the border on
    the top, right, bottom and left side respectively.</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="border_color" transfer-ownership="none">
            <doc xml:space="preserve">the color used on the top, right,
    bottom and left side.</doc>
            <array zero-terminated="0" c:type="const GdkRGBA*" fixed-size="4">
              <type name="Gdk.RGBA" c:type="GdkRGBA"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_colors" c:identifier="gsk_border_node_get_colors">
        <doc xml:space="preserve">Retrieves the colors of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 #GdkRGBA structs
    for the top, right, bottom and left color of the border</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_border_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the outline of the border</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_widths" c:identifier="gsk_border_node_get_widths">
        <doc xml:space="preserve">Retrieves the stroke widths of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 floats
  for the top, right, bottom and left stroke width of the border,
  respectively</doc>
          <array zero-terminated="0" c:type="const float*" fixed-size="4">
            <type name="gfloat" c:type="float"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BroadwayRenderer" c:symbol-prefix="broadway_renderer" c:type="GskBroadwayRenderer" parent="Renderer" glib:type-name="GskBroadwayRenderer" glib:get-type="gsk_broadway_renderer_get_type" glib:type-struct="BroadwayRendererClass">
      <constructor name="new" c:identifier="gsk_broadway_renderer_new">
        <doc xml:space="preserve">Creates a new Broadway renderer.

The Broadway renderer is the default renderer for the broadway backend.
It will only work with broadway surfaces, otherwise it will fail the
call to gsk_renderer_realize().

This function is only available when GTK was compiled with Broadway
support.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Broadway renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="BroadwayRendererClass" c:type="GskBroadwayRendererClass" disguised="1" glib:is-gtype-struct-for="BroadwayRenderer"/>
    <function-macro name="CAIRO_RENDERER" c:identifier="GSK_CAIRO_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_CLASS" c:identifier="GSK_CAIRO_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_GET_CLASS" c:identifier="GSK_CAIRO_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="CairoNode" c:symbol-prefix="cairo_node" c:type="GskCairoNode" parent="RenderNode" glib:type-name="GskCairoNode" glib:get-type="gsk_cairo_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a Cairo surface.</doc>
      <constructor name="new" c:identifier="gsk_cairo_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render a cairo surface
into the area given by @bounds. You can draw to the cairo
surface using gsk_cairo_node_get_draw_context()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="CairoNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render to</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_draw_context" c:identifier="gsk_cairo_node_get_draw_context">
        <doc xml:space="preserve">Creates a Cairo context for drawing using the surface associated
to the render node.

If no surface exists yet, a surface will be created optimized for
rendering to @renderer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a Cairo context used for drawing; use
  cairo_destroy() when done drawing</doc>
          <type name="cairo.Context" c:type="cairo_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_surface" c:identifier="gsk_cairo_node_get_surface">
        <doc xml:space="preserve">Retrieves the Cairo surface used by the render node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a Cairo surface</doc>
          <type name="cairo.Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="CairoRenderer" c:symbol-prefix="cairo_renderer" c:type="GskCairoRenderer" parent="Renderer" glib:type-name="GskCairoRenderer" glib:get-type="gsk_cairo_renderer_get_type" glib:type-struct="CairoRendererClass">
      <constructor name="new" c:identifier="gsk_cairo_renderer_new">
        <doc xml:space="preserve">Creates a new Cairo renderer.

The Cairo renderer is the fallback renderer drawing in ways similar
to how GTK 3 drew its content. Its primary use is as comparison tool.

The Cairo renderer is incomplete. It cannot render 3D transformed
content and will instead render an error marker. Its usage should be
avoided.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Cairo renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="CairoRendererClass" c:type="GskCairoRendererClass" disguised="1" glib:is-gtype-struct-for="CairoRenderer"/>
    <class name="ClipNode" c:symbol-prefix="clip_node" c:type="GskClipNode" parent="RenderNode" glib:type-name="GskClipNode" glib:get-type="gsk_clip_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a rectangular clip to its single child node.</doc>
      <constructor name="new" c:identifier="gsk_clip_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a clip @GskRenderNode</doc>
            <type name="ClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_clip" c:identifier="gsk_clip_node_get_clip">
        <doc xml:space="preserve">Retrieves the clip rectangle for @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a clip rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskClipNode</doc>
            <type name="ClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorMatrixNode" c:symbol-prefix="color_matrix_node" c:type="GskColorMatrixNode" parent="RenderNode" glib:type-name="GskColorMatrixNode" glib:get-type="gsk_color_matrix_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node controlling the color matrix of its single child node.</doc>
      <constructor name="new" c:identifier="gsk_color_matrix_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@color_matrix.

In particular, the node will transform the operation

|[&lt;!-- language="plain" --&gt;
  pixel = color_matrix * pixel + color_offset
]|

for every pixel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="color_matrix" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to apply</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="color_offset" transfer-ownership="none">
            <doc xml:space="preserve">Values to add to the color</doc>
            <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_color_matrix_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting its colors modified by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting its colors modified</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_matrix" c:identifier="gsk_color_matrix_node_get_color_matrix">
        <doc xml:space="preserve">Retrieves the color matrix used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a 4x4 color matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_offset" c:identifier="gsk_color_matrix_node_get_color_offset">
        <doc xml:space="preserve">Retrieves the color offset used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color vector</doc>
          <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix #GskRenderNode</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorNode" c:symbol-prefix="color_node" c:type="GskColorNode" parent="RenderNode" glib:type-name="GskColorNode" glib:get-type="gsk_color_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a solid color.</doc>
      <constructor name="new" c:identifier="gsk_color_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the color specified by @rgba into
the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ColorNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="rgba" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkRGBA specifying a color</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the color into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color" c:identifier="gsk_color_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the node</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskColorNode</doc>
            <type name="ColorNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="ColorStop" c:type="GskColorStop">
      <doc xml:space="preserve">A color stop in a gradient node.</doc>
      <field name="offset" writable="1">
        <doc xml:space="preserve">the offset of the color stop</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve">the color at the given offset</doc>
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
    </record>
    <class name="ConicGradientNode" c:symbol-prefix="conic_gradient_node" c:type="GskConicGradientNode" parent="RenderNode" glib:type-name="GskConicGradientNode" glib:get-type="gsk_conic_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a conic gradient.</doc>
      <constructor name="new" c:identifier="gsk_conic_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that draws a conic gradient. The conic gradient
starts around @center in the direction of @rotation. A rotation of 0 means
that the gradient points up. Color stops are then added clockwise.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ConicGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="rotation" transfer-ownership="none">
            <doc xml:space="preserve">the rotation of the gradient in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient
  The offsets of all color steps must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_angle" c:identifier="gsk_conic_gradient_node_get_angle" version="4.2">
        <doc xml:space="preserve">Retrieves the angle for the gradient in radians, normalized in [0, 2 * PI]

The angle is starting at the top and going clockwise, as expressed
in the css specification:
angle = 90 - gsk_conic_gradient_node_get_rotation()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the angle for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_center" c:identifier="gsk_conic_gradient_node_get_center">
        <doc xml:space="preserve">Retrieves the center pointer for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center point for the gradient</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_stops" c:identifier="gsk_conic_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_conic_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rotation" c:identifier="gsk_conic_gradient_node_get_rotation">
        <doc xml:space="preserve">Retrieves the rotation for the gradient in degrees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the rotation for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ContainerNode" c:symbol-prefix="container_node" c:type="GskContainerNode" parent="RenderNode" glib:type-name="GskContainerNode" glib:get-type="gsk_container_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that can contain other render nodes.</doc>
      <constructor name="new" c:identifier="gsk_container_node_new">
        <doc xml:space="preserve">Creates a new #GskRenderNode instance for holding the given @children.
The new node will acquire a reference to each of the children.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GskRenderNode</doc>
          <type name="ContainerNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">The children of the node</doc>
            <array length="1" zero-terminated="0" c:type="GskRenderNode**">
              <type name="RenderNode" c:type="GskRenderNode*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">Number of children in the @children array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_container_node_get_child">
        <doc xml:space="preserve">Gets one of the children of @container.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @idx'th child of @container</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container #GskRenderNode</doc>
            <type name="ContainerNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the position of the child to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_children" c:identifier="gsk_container_node_get_n_children">
        <doc xml:space="preserve">Retrieves the number of direct children of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children of the #GskRenderNode</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container #GskRenderNode</doc>
            <type name="ContainerNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="Corner" glib:type-name="GskCorner" glib:get-type="gsk_corner_get_type" c:type="GskCorner">
      <doc xml:space="preserve">The corner indices used by #GskRoundedRect.</doc>
      <member name="top_left" value="0" c:identifier="GSK_CORNER_TOP_LEFT" glib:nick="top-left">
        <doc xml:space="preserve">The top left corner</doc>
      </member>
      <member name="top_right" value="1" c:identifier="GSK_CORNER_TOP_RIGHT" glib:nick="top-right">
        <doc xml:space="preserve">The top right corner</doc>
      </member>
      <member name="bottom_right" value="2" c:identifier="GSK_CORNER_BOTTOM_RIGHT" glib:nick="bottom-right">
        <doc xml:space="preserve">The bottom right corner</doc>
      </member>
      <member name="bottom_left" value="3" c:identifier="GSK_CORNER_BOTTOM_LEFT" glib:nick="bottom-left">
        <doc xml:space="preserve">The bottom left corner</doc>
      </member>
    </enumeration>
    <class name="CrossFadeNode" c:symbol-prefix="cross_fade_node" c:type="GskCrossFadeNode" parent="RenderNode" glib:type-name="GskCrossFadeNode" glib:get-type="gsk_cross_fade_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node cross fading between two child nodes.</doc>
      <constructor name="new" c:identifier="gsk_cross_fade_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will do a cross-fade between @start and @end.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="CrossFadeNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">The start node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">The node to be cross_fadeed onto the @start node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">How far the fade has progressed from start to end. The value will
    be clamped to the range [0 ... 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_end_child" c:identifier="gsk_cross_fade_node_get_end_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode at the end of the cross-fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_progress" c:identifier="gsk_cross_fade_node_get_progress">
        <doc xml:space="preserve">Retrieves the progress value of the cross fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the progress value, between 0 and 1</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start_child" c:identifier="gsk_cross_fade_node_get_start_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode at the beginning of the cross-fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading #GskRenderNode</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="DebugNode" c:symbol-prefix="debug_node" c:type="GskDebugNode" parent="RenderNode" glib:type-name="GskDebugNode" glib:get-type="gsk_debug_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that emits a debugging message when drawing its
child node.</doc>
      <constructor name="new" c:identifier="gsk_debug_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will add debug information about
the given @child.

Adding this node has no visual effect.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="DebugNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to add debug info for</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="message" transfer-ownership="full">
            <doc xml:space="preserve">The debug message</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_debug_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug #GskRenderNode</doc>
            <type name="DebugNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="gsk_debug_node_get_message">
        <doc xml:space="preserve">Gets the debug message that was set on this node</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The debug message</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug #GskRenderNode</doc>
            <type name="DebugNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="GLRenderer" c:symbol-prefix="gl_renderer" c:type="GskGLRenderer" parent="Renderer" glib:type-name="GskGLRenderer" glib:get-type="gsk_gl_renderer_get_type" glib:type-struct="GLRendererClass">
      <constructor name="new" c:identifier="gsk_gl_renderer_new">
        <doc xml:space="preserve">Creates a new #GskRenderer using OpenGL. This is the default renderer
used by GTK.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new GL renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="GLRendererClass" c:type="GskGLRendererClass" disguised="1" glib:is-gtype-struct-for="GLRenderer"/>
    <class name="GLShader" c:symbol-prefix="gl_shader" c:type="GskGLShader" parent="GObject.Object" glib:type-name="GskGLShader" glib:get-type="gsk_gl_shader_get_type" glib:type-struct="GLShaderClass">
      <doc xml:space="preserve">An object representing a GL shader program.</doc>
      <constructor name="new_from_bytes" c:identifier="gsk_gl_shader_new_from_bytes">
        <doc xml:space="preserve">Creates a #GskGLShader that will render pixels using the specified code.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskGLShader</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="sourcecode" transfer-ownership="none">
            <doc xml:space="preserve">GLSL sourcecode for the shader, as a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_resource" c:identifier="gsk_gl_shader_new_from_resource">
        <doc xml:space="preserve">Creates a #GskGLShader that will render pixels using the specified code.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskGLShader</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="resource_path" transfer-ownership="none">
            <doc xml:space="preserve">path to a resource that contains the GLSL sourcecode for
    the shader</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="compile" c:identifier="gsk_gl_shader_compile" throws="1">
        <doc xml:space="preserve">Tries to compile the @shader for the given @renderer, and reports
%FALSE with an error if there is a problem. You should use this
function before relying on the shader for rendering and use a
fallback with a simpler shader or without shaders if it fails.

Note that this will modify the rendering state (for example
change the current GL context) and requires the renderer to be
set up. This means that the widget has to be realized. Commonly you
want to call this from the realize signal of a widget, or during
widget snapshot.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_uniform_by_name" c:identifier="gsk_gl_shader_find_uniform_by_name">
        <doc xml:space="preserve">Looks for a uniform by the name @name, and returns the index
of the uniform, or -1 if it was not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The index of the uniform, or -1</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">uniform name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_args" c:identifier="gsk_gl_shader_format_args" introspectable="0">
        <doc xml:space="preserve">Formats the uniform data as needed for feeding the named uniforms
values into the shader. The argument list is a list of pairs of
names, and values for the types that match the declared uniforms
(i.e. double/int/guint/gboolean for primitive values and
`graphene_vecN_t *` for vecN uniforms).

Any uniforms of the shader that are not included in the argument list
are zero-initialized.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated block of data which can be
    passed to gsk_gl_shader_node_new().</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">name-Value pairs for the uniforms of @shader, ending with
    a %NULL name</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="format_args_va" c:identifier="gsk_gl_shader_format_args_va" introspectable="0">
        <doc xml:space="preserve">Formats the uniform data as needed for feeding the named uniforms
values into the shader. The argument list is a list of pairs of
names, and values for the types that match the declared uniforms
(i.e. double/int/guint/gboolean for primitive values and
`graphene_vecN_t *` for vecN uniforms).

It is an error to pass a uniform name that is not declared by the shader.

Any uniforms of the shader that are not included in the argument list
are zero-initialized.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated block of data which can be
    passed to gsk_gl_shader_node_new().</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="uniforms" transfer-ownership="none">
            <doc xml:space="preserve">name-Value pairs for the uniforms of @shader, ending
    with a %NULL name</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_bool" c:identifier="gsk_gl_shader_get_arg_bool">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of bool type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_float" c:identifier="gsk_gl_shader_get_arg_float">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of float type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_int" c:identifier="gsk_gl_shader_get_arg_int">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of int type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_uint" c:identifier="gsk_gl_shader_get_arg_uint">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of uint type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec2" c:identifier="gsk_gl_shader_get_arg_vec2">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of vec2 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store the uniform value in</doc>
            <type name="Graphene.Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec3" c:identifier="gsk_gl_shader_get_arg_vec3">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of vec3 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store the uniform value in</doc>
            <type name="Graphene.Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec4" c:identifier="gsk_gl_shader_get_arg_vec4">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.
The uniform must be of vec4 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store set the uniform value in</doc>
            <type name="Graphene.Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_args_size" c:identifier="gsk_gl_shader_get_args_size">
        <doc xml:space="preserve">Get the size of the data block used to specify arguments for this shader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The size of the data block</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_textures" c:identifier="gsk_gl_shader_get_n_textures">
        <doc xml:space="preserve">Returns the number of textures that the shader requires.

This can be used to check that the a passed shader works
in your usecase. It is determined by looking at the highest
u_textureN value that the shader defines.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of texture inputs required by @shader</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_uniforms" c:identifier="gsk_gl_shader_get_n_uniforms">
        <doc xml:space="preserve">Get the number of declared uniforms for this shader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of declared uniforms</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resource" c:identifier="gsk_gl_shader_get_resource">
        <doc xml:space="preserve">Gets the resource path for the GLSL sourcecode being used
to render this shader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The resource path for the shader,
    or %NULL if none.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="gsk_gl_shader_get_source">
        <doc xml:space="preserve">Gets the GLSL sourcecode being used to render this shader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The source code for the shader</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uniform_name" c:identifier="gsk_gl_shader_get_uniform_name">
        <doc xml:space="preserve">Get the name of the declared uniform for this shader at index @idx.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the declared uniform</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_offset" c:identifier="gsk_gl_shader_get_uniform_offset">
        <doc xml:space="preserve">Get the offset into the data block where data for this uniforms is stored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The data offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_type" c:identifier="gsk_gl_shader_get_uniform_type">
        <doc xml:space="preserve">Get the type of the declared uniform for this shader at index @idx.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The type of the declared uniform</doc>
          <type name="GLUniformType" c:type="GskGLUniformType"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="resource" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Resource containing the source code for the shader.

If the shader source is not coming from a resource, this
will be %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="source" writable="1" construct-only="1" transfer-ownership="none">
        <type name="GLib.Bytes"/>
      </property>
    </class>
    <record name="GLShaderClass" c:type="GskGLShaderClass" glib:is-gtype-struct-for="GLShader">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="GLShaderNode" c:symbol-prefix="gl_shader_node" c:type="GskGLShaderNode" parent="RenderNode" glib:type-name="GskGLShaderNode" glib:get-type="gsk_gl_shader_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node using a GL shader when drawing its children nodes.</doc>
      <constructor name="new" c:identifier="gsk_gl_shader_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the given @shader into the
area given by @bounds. The @args is a block of data to use for uniform
input, as per types and offsets defined by the @shader. Normally this
is generated by gsk_gl_shader_format_args() or #GskGLShaderArgBuilder.

See #GskGLShader for details about how the shader should be written.

All the children will be rendered into textures (if they aren't already
#GskTextureNodes, which will be used directly). These textures will be
sent as input to the shader.

If the renderer doesn't support GL shaders, or if there is any problem
when compiling the shader, then the node will draw pink. You should use
gsk_gl_shader_compile() to ensure the @shader will work for the
renderer before using it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="GLShaderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">the #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the shader into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">Arguments for the uniforms</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">array of child nodes, these will
    be rendered to textures and used as input.</doc>
            <array length="4" zero-terminated="0" c:type="GskRenderNode**">
              <type name="RenderNode" c:type="GskRenderNode*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">Length of @children (currenly the GL backend supports
    up to 4 children)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_args" c:identifier="gsk_gl_shader_node_get_args">
        <doc xml:space="preserve">Gets args for the node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GBytes with the uniform arguments</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="gsk_gl_shader_node_get_child">
        <doc xml:space="preserve">Gets one of the children.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @idx'th child of @node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the position of the child to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_children" c:identifier="gsk_gl_shader_node_get_n_children">
        <doc xml:space="preserve">Returns the number of children</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of children</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shader" c:identifier="gsk_gl_shader_node_get_shader">
        <doc xml:space="preserve">Gets shader code for the node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GskGLShader shader</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="GLUniformType" glib:type-name="GskGLUniformType" glib:get-type="gsk_gl_uniform_type_get_type" c:type="GskGLUniformType">
      <doc xml:space="preserve">This defines the types of the uniforms that #GskGLShaders
declare. It defines both what the type is called in the GLSL shader
code, and what the corresponding C type is on the Gtk side.</doc>
      <member name="none" value="0" c:identifier="GSK_GL_UNIFORM_TYPE_NONE" glib:nick="none">
        <doc xml:space="preserve">No type, used for uninitialized or unspecified values.</doc>
      </member>
      <member name="float" value="1" c:identifier="GSK_GL_UNIFORM_TYPE_FLOAT" glib:nick="float">
        <doc xml:space="preserve">A float uniform</doc>
      </member>
      <member name="int" value="2" c:identifier="GSK_GL_UNIFORM_TYPE_INT" glib:nick="int">
        <doc xml:space="preserve">A GLSL int / gint32 uniform</doc>
      </member>
      <member name="uint" value="3" c:identifier="GSK_GL_UNIFORM_TYPE_UINT" glib:nick="uint">
        <doc xml:space="preserve">A GLSL uint / guint32 uniform</doc>
      </member>
      <member name="bool" value="4" c:identifier="GSK_GL_UNIFORM_TYPE_BOOL" glib:nick="bool">
        <doc xml:space="preserve">A GLSL bool / gboolean uniform</doc>
      </member>
      <member name="vec2" value="5" c:identifier="GSK_GL_UNIFORM_TYPE_VEC2" glib:nick="vec2">
        <doc xml:space="preserve">A GLSL vec2 / graphene_vec2_t uniform</doc>
      </member>
      <member name="vec3" value="6" c:identifier="GSK_GL_UNIFORM_TYPE_VEC3" glib:nick="vec3">
        <doc xml:space="preserve">A GLSL vec3 / graphene_vec3_t uniform</doc>
      </member>
      <member name="vec4" value="7" c:identifier="GSK_GL_UNIFORM_TYPE_VEC4" glib:nick="vec4">
        <doc xml:space="preserve">A GLSL vec4 / graphene_vec4_t uniform</doc>
      </member>
    </enumeration>
    <function-macro name="GL_RENDERER" c:identifier="GSK_GL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_CLASS" c:identifier="GSK_GL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_GET_CLASS" c:identifier="GSK_GL_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <docsection name="GskGLShader">
      <doc xml:space="preserve">A #GskGLShader is a snippet of GLSL that is meant to run in the
fragment shader of the rendering pipeline. A fragment shader
gets the coordinates being rendered as input and produces the
pixel values for that particular pixel. Additionally, the
shader can declare a set of other input arguments, called
uniforms (as they are uniform over all the calls to your shader in
each instance of use). A shader can also receive up to 4
textures that it can use as input when producing the pixel data.

  #GskGLShader is usually used with gtk_snapshot_push_gl_shader()
to produce a #GskGLShaderNode in the rendering hierarchy, and then
its input textures are constructed by rendering the child nodes to
textures before rendering the shader node itself. (You can pass
texture nodes as children if you want to directly use a texture
as input).

The actual shader code is GLSL code that gets combined with
some other code into the fragment shader. Since the exact
capabilities of the GPU driver differs between different OpenGL
drivers and hardware, GTK adds some defines that you can use
to ensure your GLSL code runs on as many drivers as it can.

If the OpenGL driver is GLES, then the shader language version
is set to 100, and GSK_GLES will be defined in the shader.

Otherwise, if the OpenGL driver does not support the 3.2 core profile,
then the shader will run with language version 110 for GL2 and 130 for GL3,
and GSK_LEGACY will be defined in the shader.

If the OpenGL driver supports the 3.2 code profile, it will be used,
the shader language version is set to 150, and GSK_GL3 will be defined
in the shader.

The main function the shader must implement is:

|[&lt;!-- language="plain" --&gt;
 void mainImage(out vec4 fragColor,
                in vec2 fragCoord,
                in vec2 resolution,
                in vec2 uv)
]|

Where the input @fragCoord is the coordinate of the pixel we're
currently rendering, relative to the boundary rectangle that was
specified in the #GskGLShaderNode, and @resolution is the width and
height of that rectangle. This is in the typical GTK coordinate
system with the origin in the top left. @uv contains the u and v
coordinates that can be used to index a texture at the
corresponding point. These coordinates are in the [0..1]x[0..1]
region, with 0, 0 being in the lower left corder (which is typical
for OpenGL).

The output @fragColor should be a RGBA color (with
premultiplied alpha) that will be used as the output for the
specified pixel location. Note that this output will be
automatically clipped to the clip region of the glshader node.

In addition to the function arguments the shader can define
up to 4 uniforms for textures which must be called u_textureN
(i.e. u_texture1 to u_texture4) as well as any custom uniforms
you want of types int, uint, bool, float, vec2, vec3 or vec4.

All textures sources contain premultiplied alpha colors, but if some
there are outer sources of colors there is a gsk_premultiply() helper
to compute premultiplication when needed.

Note that GTK parses the uniform declarations, so each uniform has to
be on a line by itself with no other code, like so:

|[&lt;!-- language="plain" --&gt;
uniform float u_time;
uniform vec3 u_color;
uniform sampler2D u_texture1;
uniform sampler2D u_texture2;
]|

GTK uses the the "gsk" namespace in the symbols it uses in the
shader, so your code should not use any symbols with the prefix gsk
or GSK. There are some helper functions declared that you can use:

|[&lt;!-- language="plain" --&gt;
vec4 GskTexture(sampler2D sampler, vec2 texCoords);
]|

This samples a texture (e.g. u_texture1) at the specified
coordinates, and containes some helper ifdefs to ensure that
it works on all OpenGL versions.

You can compile the shader yourself using gsk_gl_shader_compile(),
otherwise the GSK renderer will do it when it handling the glshader
node. If errors occurs, the returned @error will include the glsl
sources, so you can see what GSK was passing to the compiler. You
can also set GSK_DEBUG=shaders in the environment to see the sources
and other relevant information about all shaders that GSK is handling.

# An example shader

|[&lt;!-- language="plain" --&gt;
uniform float position;
uniform sampler2D u_texture1;
uniform sampler2D u_texture2;

void mainImage(out vec4 fragColor,
               in vec2 fragCoord,
               in vec2 resolution,
               in vec2 uv) {
  vec4 source1 = GskTexture(u_texture1, uv);
  vec4 source2 = GskTexture(u_texture2, uv);

  fragColor = position * source1 + (1.0 - position) * source2;
}
]|</doc>
    </docsection>
    <docsection name="GskRenderNode">
      <doc xml:space="preserve">#GskRenderNode is the basic block in a scene graph to be
rendered using #GskRenderer.

Each node has a parent, except the top-level node; each node may have
children nodes.

Each node has an associated drawing surface, which has the size of
the rectangle set using gsk_render_node_set_bounds().

Render nodes are meant to be transient; once they have been associated
to a #GskRenderer it's safe to release any reference you have on them.
All #GskRenderNodes are immutable, you can only specify their properties
during construction.</doc>
    </docsection>
    <docsection name="GskRenderer">
      <doc xml:space="preserve">#GskRenderer is a class that renders a scene graph defined via a
tree of #GskRenderNode instances.

Typically you will use a #GskRenderer instance to repeatedly call
gsk_renderer_render() to update the contents of its associated #GdkSurface.

It is necessary to realize a #GskRenderer instance using gsk_renderer_realize()
before calling gsk_renderer_render(), in order to create the appropriate
windowing system resources needed to render the scene.</doc>
    </docsection>
    <docsection name="GskRoundedRect">
      <doc xml:space="preserve">#GskRoundedRect defines a rectangle with rounded corners, as is commonly
used in drawing.

Operations on a #GskRoundedRect will normalize the rectangle, to
ensure that the bounds are normalized and that the corner sizes don't exceed
the size of the rectangle. The algorithm used for normalizing corner sizes
is described in [the CSS specification](https://drafts.csswg.org/css-backgrounds-3/#border-radius).</doc>
    </docsection>
    <docsection name="GskTransform">
      <doc xml:space="preserve">#GskTransform is an object to describe transform matrices. Unlike
#graphene_matrix_t, #GskTransform retains the steps in how a transform was
constructed, and allows inspecting them. It is modeled after the way
CSS describes transforms.

#GskTransform objects are immutable and cannot be changed after creation.
This means code can safely expose them as properties of objects without
having to worry about others changing them.</doc>
    </docsection>
    <function-macro name="IS_BROADWAY_RENDERER" c:identifier="GSK_IS_BROADWAY_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BROADWAY_RENDERER_CLASS" c:identifier="GSK_IS_BROADWAY_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER" c:identifier="GSK_IS_CAIRO_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER_CLASS" c:identifier="GSK_IS_CAIRO_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER" c:identifier="GSK_IS_GL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER_CLASS" c:identifier="GSK_IS_GL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_NGL_RENDERER" c:identifier="GSK_IS_NGL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_NGL_RENDERER_CLASS" c:identifier="GSK_IS_NGL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDERER" c:identifier="GSK_IS_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDER_NODE" c:identifier="GSK_IS_RENDER_NODE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER" c:identifier="GSK_IS_VULKAN_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER_CLASS" c:identifier="GSK_IS_VULKAN_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="InsetShadowNode" c:symbol-prefix="inset_shadow_node" c:type="GskInsetShadowNode" parent="RenderNode" glib:type-name="GskInsetShadowNode" glib:get-type="gsk_inset_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for an inset shadow.</doc>
      <constructor name="new" c:identifier="gsk_inset_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render an inset shadow
into the box given by @outline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="InsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region containing the shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_inset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius to apply to the shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="gsk_inset_shadow_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_inset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_inset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_inset_shadow_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_inset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads inwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="LinearGradientNode" c:symbol-prefix="linear_gradient_node" c:type="GskLinearGradientNode" parent="RenderNode" glib:type-name="GskLinearGradientNode" glib:get-type="gsk_linear_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a linear gradient.</doc>
      <constructor name="new" c:identifier="gsk_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will create a linear gradient from the given
points and color stops, and render that into the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="LinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient
  The offsets of all color steps must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color_stops" c:identifier="gsk_linear_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_end" c:identifier="gsk_linear_gradient_node_get_end">
        <doc xml:space="preserve">Retrieves the final point of the linear gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the final point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_linear_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start" c:identifier="gsk_linear_gradient_node_get_start">
        <doc xml:space="preserve">Retrieves the initial point of the linear gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initial point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <function-macro name="NGL_RENDERER" c:identifier="GSK_NGL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NGL_RENDERER_CLASS" c:identifier="GSK_NGL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NGL_RENDERER_GET_CLASS" c:identifier="GSK_NGL_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="NglRenderer" c:symbol-prefix="ngl_renderer" c:type="GskNglRenderer" parent="Renderer" glib:type-name="GskNglRenderer" glib:get-type="gsk_ngl_renderer_get_type" glib:type-struct="NglRendererClass">
      <constructor name="new" c:identifier="gsk_ngl_renderer_new" version="4.2">
        <doc xml:space="preserve">Creates a new #GskRenderer using the new OpenGL renderer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new NGL renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="NglRendererClass" c:type="GskNglRendererClass" disguised="1" glib:is-gtype-struct-for="NglRenderer"/>
    <class name="OpacityNode" c:symbol-prefix="opacity_node" c:type="GskOpacityNode" parent="RenderNode" glib:type-name="GskOpacityNode" glib:get-type="gsk_opacity_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node controlling the opacity of its single child node.</doc>
      <constructor name="new" c:identifier="gsk_opacity_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@opacity.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="OpacityNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="opacity" transfer-ownership="none">
            <doc xml:space="preserve">The opacity to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_opacity_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting opacityed by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting opacityed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an opacity</doc>
            <type name="OpacityNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_opacity" c:identifier="gsk_opacity_node_get_opacity">
        <doc xml:space="preserve">Gets the transparency factor for an opacity node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the opacity factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an opacity</doc>
            <type name="OpacityNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="OutsetShadowNode" c:symbol-prefix="outset_shadow_node" c:type="GskOutsetShadowNode" parent="RenderNode" glib:type-name="GskOutsetShadowNode" glib:get-type="gsk_outset_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for an outset shadow.</doc>
      <constructor name="new" c:identifier="gsk_outset_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render an outset shadow
around the box given by @outline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region surrounded by shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_outset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="gsk_outset_shadow_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_outset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_outset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_outset_shadow_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_outset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads outwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="ParseErrorFunc" c:type="GskParseErrorFunc">
      <doc xml:space="preserve">The type of callback that is called when a parse error occurs
during deserialization of node data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">start of the error location</doc>
          <type name="ParseLocation" c:type="const GskParseLocation*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">end of the error location</doc>
          <type name="ParseLocation" c:type="const GskParseLocation*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the error</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ParseLocation" c:type="GskParseLocation">
      <doc xml:space="preserve">A location in a parse buffer.</doc>
      <field name="bytes" writable="1">
        <doc xml:space="preserve">the offset of the location in the parse buffer, as bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="chars" writable="1">
        <doc xml:space="preserve">the offset of the location in the parse buffer, as characters</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="lines" writable="1">
        <doc xml:space="preserve">the line of the location in the parse buffer</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="line_bytes" writable="1">
        <doc xml:space="preserve">the position in the line, as bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="line_chars" writable="1">
        <doc xml:space="preserve">the position in the line, as characters</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <function-macro name="RENDERER" c:identifier="GSK_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUNDED_RECT_INIT" c:identifier="GSK_ROUNDED_RECT_INIT" introspectable="0">
      <doc xml:space="preserve">Initializes a #GskRoundedRect when declaring it.
All corner sizes will be initialized to 0.</doc>
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate of the origin</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate of the origin</doc>
        </parameter>
        <parameter name="_w">
          <doc xml:space="preserve">the width</doc>
        </parameter>
        <parameter name="_h">
          <doc xml:space="preserve">the height</doc>
        </parameter>
      </parameters>
    </function-macro>
    <class name="RadialGradientNode" c:symbol-prefix="radial_gradient_node" c:type="GskRadialGradientNode" parent="RenderNode" glib:type-name="GskRadialGradientNode" glib:get-type="gsk_radial_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a radial gradient.</doc>
      <constructor name="new" c:identifier="gsk_radial_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that draws a radial gradient. The radial gradient
starts around @center. The size of the gradient is dictated by @hradius
in horizontal orientation and by @vradius in vertial orientation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RadialGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="hradius" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="vradius" transfer-ownership="none">
            <doc xml:space="preserve">the vertical radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the start of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the end of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient
  The offsets of all color steps must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="7" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_center" c:identifier="gsk_radial_gradient_node_get_center">
        <doc xml:space="preserve">Retrieves the center pointer for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center point for the gradient</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_stops" c:identifier="gsk_radial_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_end" c:identifier="gsk_radial_gradient_node_get_end">
        <doc xml:space="preserve">Retrieves the end value for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the end value for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hradius" c:identifier="gsk_radial_gradient_node_get_hradius">
        <doc xml:space="preserve">Retrieves the horizonal radius for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the horizontal radius for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_radial_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start" c:identifier="gsk_radial_gradient_node_get_start">
        <doc xml:space="preserve">Retrieves the start value for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the start value for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vradius" c:identifier="gsk_radial_gradient_node_get_vradius">
        <doc xml:space="preserve">Retrieves the vertical radius for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vertical radius for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="RenderNode" c:symbol-prefix="render_node" c:type="GskRenderNode" abstract="1" glib:type-name="GskRenderNode" glib:get-type="gsk_render_node_get_type" glib:fundamental="1" glib:ref-func="gsk_render_node_ref" glib:unref-func="gsk_render_node_unref">
      <doc xml:space="preserve">A node in the render tree.</doc>
      <function name="deserialize" c:identifier="gsk_render_node_deserialize">
        <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the bytes containing the data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="error_func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="2">
            <doc xml:space="preserve">Callback on parsing errors or %NULL</doc>
            <type name="ParseErrorFunc" c:type="GskParseErrorFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
            <doc xml:space="preserve">user_data for @error_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="draw" c:identifier="gsk_render_node_draw">
        <doc xml:space="preserve">Draw the contents of @node to the given cairo context.

Typically, you'll use this function to implement fallback rendering
of #GskRenderNodes on an intermediate Cairo context, instead of using
the drawing context associated to a #GdkSurface's rendering buffer.

For advanced nodes that cannot be supported using Cairo, in particular
for nodes doing 3D operations, this function may fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">cairo context to draw to</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gsk_render_node_get_bounds">
        <doc xml:space="preserve">Retrieves the boundaries of the @node. The node will not draw outside
of its boundaries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="bounds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the boundaries</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_node_type" c:identifier="gsk_render_node_get_node_type">
        <doc xml:space="preserve">Returns the type of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #GskRenderNode</doc>
          <type name="RenderNodeType" c:type="GskRenderNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_render_node_ref">
        <doc xml:space="preserve">Acquires a reference on the given #GskRenderNode.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GskRenderNode with an additional reference</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="gsk_render_node_serialize">
        <doc xml:space="preserve">Serializes the @node for later deserialization via
gsk_render_node_deserialize(). No guarantees are made about the format
used other than that the same version of GTK will be able to deserialize
the result of a call to gsk_render_node_serialize() and
gsk_render_node_deserialize() will correctly reject files it cannot open
that were created with previous versions of GTK.

The intended use of this functions is testing, benchmarking and debugging.
The format is not meant as a permanent storage format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes representing the node.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_render_node_unref">
        <doc xml:space="preserve">Releases a reference on the given #GskRenderNode.

If the reference was the last, the resources associated to the @node are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_file" c:identifier="gsk_render_node_write_to_file" throws="1">
        <doc xml:space="preserve">This function is equivalent to calling gsk_render_node_serialize()
followed by g_file_set_contents(). See those two functions for details
on the arguments.

It is mostly intended for use inside a debugger to quickly dump a render
node to a file for later inspection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to save it to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="RenderNodeType" glib:type-name="GskRenderNodeType" glib:get-type="gsk_render_node_type_get_type" c:type="GskRenderNodeType">
      <doc xml:space="preserve">The type of a node determines what the node is rendering.</doc>
      <member name="not_a_render_node" value="0" c:identifier="GSK_NOT_A_RENDER_NODE" glib:nick="not-a-render-node">
        <doc xml:space="preserve">Error type. No node will ever have this type.</doc>
      </member>
      <member name="container_node" value="1" c:identifier="GSK_CONTAINER_NODE" glib:nick="container-node">
        <doc xml:space="preserve">A node containing a stack of children</doc>
      </member>
      <member name="cairo_node" value="2" c:identifier="GSK_CAIRO_NODE" glib:nick="cairo-node">
        <doc xml:space="preserve">A node drawing a #cairo_surface_t</doc>
      </member>
      <member name="color_node" value="3" c:identifier="GSK_COLOR_NODE" glib:nick="color-node">
        <doc xml:space="preserve">A node drawing a single color rectangle</doc>
      </member>
      <member name="linear_gradient_node" value="4" c:identifier="GSK_LINEAR_GRADIENT_NODE" glib:nick="linear-gradient-node">
        <doc xml:space="preserve">A node drawing a linear gradient</doc>
      </member>
      <member name="repeating_linear_gradient_node" value="5" c:identifier="GSK_REPEATING_LINEAR_GRADIENT_NODE" glib:nick="repeating-linear-gradient-node">
        <doc xml:space="preserve">A node drawing a repeating linear gradient</doc>
      </member>
      <member name="radial_gradient_node" value="6" c:identifier="GSK_RADIAL_GRADIENT_NODE" glib:nick="radial-gradient-node">
        <doc xml:space="preserve">A node drawing a radial gradient</doc>
      </member>
      <member name="repeating_radial_gradient_node" value="7" c:identifier="GSK_REPEATING_RADIAL_GRADIENT_NODE" glib:nick="repeating-radial-gradient-node">
        <doc xml:space="preserve">A node drawing a repeating radial gradient</doc>
      </member>
      <member name="conic_gradient_node" value="8" c:identifier="GSK_CONIC_GRADIENT_NODE" glib:nick="conic-gradient-node">
        <doc xml:space="preserve">A node drawing a conic gradient</doc>
      </member>
      <member name="border_node" value="9" c:identifier="GSK_BORDER_NODE" glib:nick="border-node">
        <doc xml:space="preserve">A node stroking a border around an area</doc>
      </member>
      <member name="texture_node" value="10" c:identifier="GSK_TEXTURE_NODE" glib:nick="texture-node">
        <doc xml:space="preserve">A node drawing a #GdkTexture</doc>
      </member>
      <member name="inset_shadow_node" value="11" c:identifier="GSK_INSET_SHADOW_NODE" glib:nick="inset-shadow-node">
        <doc xml:space="preserve">A node drawing an inset shadow</doc>
      </member>
      <member name="outset_shadow_node" value="12" c:identifier="GSK_OUTSET_SHADOW_NODE" glib:nick="outset-shadow-node">
        <doc xml:space="preserve">A node drawing an outset shadow</doc>
      </member>
      <member name="transform_node" value="13" c:identifier="GSK_TRANSFORM_NODE" glib:nick="transform-node">
        <doc xml:space="preserve">A node that renders its child after applying a matrix transform</doc>
      </member>
      <member name="opacity_node" value="14" c:identifier="GSK_OPACITY_NODE" glib:nick="opacity-node">
        <doc xml:space="preserve">A node that changes the opacity of its child</doc>
      </member>
      <member name="color_matrix_node" value="15" c:identifier="GSK_COLOR_MATRIX_NODE" glib:nick="color-matrix-node">
        <doc xml:space="preserve">A node that applies a color matrix to every pixel</doc>
      </member>
      <member name="repeat_node" value="16" c:identifier="GSK_REPEAT_NODE" glib:nick="repeat-node">
        <doc xml:space="preserve">A node that repeats the child's contents</doc>
      </member>
      <member name="clip_node" value="17" c:identifier="GSK_CLIP_NODE" glib:nick="clip-node">
        <doc xml:space="preserve">A node that clips its child to a rectangular area</doc>
      </member>
      <member name="rounded_clip_node" value="18" c:identifier="GSK_ROUNDED_CLIP_NODE" glib:nick="rounded-clip-node">
        <doc xml:space="preserve">A node that clips its child to a rounded rectangle</doc>
      </member>
      <member name="shadow_node" value="19" c:identifier="GSK_SHADOW_NODE" glib:nick="shadow-node">
        <doc xml:space="preserve">A node that draws a shadow below its child</doc>
      </member>
      <member name="blend_node" value="20" c:identifier="GSK_BLEND_NODE" glib:nick="blend-node">
        <doc xml:space="preserve">A node that blends two children together</doc>
      </member>
      <member name="cross_fade_node" value="21" c:identifier="GSK_CROSS_FADE_NODE" glib:nick="cross-fade-node">
        <doc xml:space="preserve">A node that cross-fades between two children</doc>
      </member>
      <member name="text_node" value="22" c:identifier="GSK_TEXT_NODE" glib:nick="text-node">
        <doc xml:space="preserve">A node containing a glyph string</doc>
      </member>
      <member name="blur_node" value="23" c:identifier="GSK_BLUR_NODE" glib:nick="blur-node">
        <doc xml:space="preserve">A node that applies a blur</doc>
      </member>
      <member name="debug_node" value="24" c:identifier="GSK_DEBUG_NODE" glib:nick="debug-node">
        <doc xml:space="preserve">Debug information that does not affect the rendering</doc>
      </member>
      <member name="gl_shader_node" value="25" c:identifier="GSK_GL_SHADER_NODE" glib:nick="gl-shader-node">
        <doc xml:space="preserve">A node that uses OpenGL fragment shaders to render</doc>
      </member>
    </enumeration>
    <class name="Renderer" c:symbol-prefix="renderer" c:type="GskRenderer" parent="GObject.Object" abstract="1" glib:type-name="GskRenderer" glib:get-type="gsk_renderer_get_type" glib:type-struct="RendererClass">
      <doc xml:space="preserve">Base type for the object managing the rendering pipeline
for a #GdkSurface.</doc>
      <constructor name="new_for_surface" c:identifier="gsk_renderer_new_for_surface">
        <doc xml:space="preserve">Creates an appropriate #GskRenderer instance for the given @surface.

If the `GSK_RENDERER` environment variable is set, GSK will
try that renderer first, before trying the backend-specific
default. The ultimate fallback is the cairo renderer.

The renderer will be realized before it is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GskRenderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
        <parameters>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkSurface</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_surface" c:identifier="gsk_renderer_get_surface">
        <doc xml:space="preserve">Retrieves the #GdkSurface set using gsk_renderer_realize(). If the renderer
has not been realized yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GdkSurface</doc>
          <type name="Gdk.Surface" c:type="GdkSurface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_realized" c:identifier="gsk_renderer_is_realized">
        <doc xml:space="preserve">Checks whether the @renderer is realized or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the #GskRenderer was realized, and %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="realize" c:identifier="gsk_renderer_realize" throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkSurface renderer will be used on</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="gsk_renderer_render">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
ensuring that the given @region gets redrawn.

Renderers must ensure that changes of the contents given by the @root
node as well as the area given by @region are redrawn. They are however
free to not redraw any pixel outside of @region if they can guarantee that
it didn't change.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="region" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #cairo_region_t that must be redrawn or %NULL
    for the whole window</doc>
            <type name="cairo.Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_texture" c:identifier="gsk_renderer_render_texture">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
to a #GdkTexture.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.

If you want to apply any transformations to @root, you should put it into a
transform node and pass that node instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GdkTexture with the rendered contents of @root.</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="viewport" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section to draw or %NULL to use @root's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unrealize" c:identifier="gsk_renderer_unrealize">
        <doc xml:space="preserve">Releases all the resources created by gsk_renderer_realize().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="realized" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="surface" transfer-ownership="none">
        <type name="Gdk.Surface"/>
      </property>
    </class>
    <record name="RendererClass" c:type="GskRendererClass" disguised="1" glib:is-gtype-struct-for="Renderer"/>
    <class name="RepeatNode" c:symbol-prefix="repeat_node" c:type="GskRepeatNode" parent="RenderNode" glib:type-name="GskRepeatNode" glib:get-type="gsk_repeat_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node repeating its single child node.</doc>
      <constructor name="new" c:identifier="gsk_repeat_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will repeat the drawing of @child across
the given @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RepeatNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">The bounds of the area to be painted</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to repeat</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="child_bounds" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The area of the child to repeat or %NULL to
    use the child's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_repeat_node_get_child">
        <doc xml:space="preserve">Retrieves the child of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat #GskRenderNode</doc>
            <type name="RepeatNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child_bounds" c:identifier="gsk_repeat_node_get_child_bounds">
        <doc xml:space="preserve">Retrieves the bounding rectangle of the child of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a bounding rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat #GskRenderNode</doc>
            <type name="RepeatNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="RepeatingLinearGradientNode" c:symbol-prefix="repeating_linear_gradient_node" c:type="GskRepeatingLinearGradientNode" parent="RenderNode" glib:type-name="GskRepeatingLinearGradientNode" glib:get-type="gsk_repeating_linear_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a repeating linear gradient.</doc>
      <constructor name="new" c:identifier="gsk_repeating_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will create a repeating linear gradient
from the given points and color stops, and render that into the area
given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RepeatingLinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient
  The offsets of all color steps must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="RepeatingRadialGradientNode" c:symbol-prefix="repeating_radial_gradient_node" c:type="GskRepeatingRadialGradientNode" parent="RenderNode" glib:type-name="GskRepeatingRadialGradientNode" glib:get-type="gsk_repeating_radial_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a repeating radial gradient.</doc>
      <constructor name="new" c:identifier="gsk_repeating_radial_gradient_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that draws a repeating radial gradient. The radial gradient
starts around @center. The size of the gradient is dictated by @hradius
in horizontal orientation and by @vradius in vertial orientation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RepeatingRadialGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="hradius" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="vradius" transfer-ownership="none">
            <doc xml:space="preserve">the vertical radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the start of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the end of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient
  The offsets of all color steps must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="7" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="RoundedClipNode" c:symbol-prefix="rounded_clip_node" c:type="GskRoundedClipNode" parent="RenderNode" glib:type-name="GskRoundedClipNode" glib:get-type="gsk_rounded_clip_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a rounded rectangle clip to its single child.</doc>
      <constructor name="new" c:identifier="gsk_rounded_clip_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RoundedClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_rounded_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip #GskRenderNode</doc>
            <type name="RoundedClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_clip" c:identifier="gsk_rounded_clip_node_get_clip">
        <doc xml:space="preserve">Retrievs the rounded rectangle used to clip the contents of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip #GskRenderNode</doc>
            <type name="RoundedClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="RoundedRect" c:type="GskRoundedRect">
      <doc xml:space="preserve">A rectangular region with rounded corners.

Application code should normalize rectangles using gsk_rounded_rect_normalize();
this function will ensure that the bounds of the rectangle are normalized
and ensure that the corner values are positive and the corners do not overlap.
All functions taking a #GskRoundedRect as an argument will internally operate on
a normalized copy; all functions returning a #GskRoundedRect will always return
a normalized one.</doc>
      <field name="bounds" writable="1">
        <doc xml:space="preserve">the bounds of the rectangle</doc>
        <type name="Graphene.Rect" c:type="graphene_rect_t"/>
      </field>
      <field name="corner" writable="1">
        <doc xml:space="preserve">the size of the 4 rounded corners</doc>
        <array zero-terminated="0" fixed-size="4">
          <type name="Graphene.Size" c:type="graphene_size_t"/>
        </array>
      </field>
      <method name="contains_point" c:identifier="gsk_rounded_rect_contains_point">
        <doc xml:space="preserve">Checks if the given @point is inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @point is inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to check</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect" c:identifier="gsk_rounded_rect_contains_rect">
        <doc xml:space="preserve">Checks if the given @rect is contained inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect is fully contained inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gsk_rounded_rect_init">
        <doc xml:space="preserve">Initializes the given #GskRoundedRect with the given values.

This function will implicitly normalize the #GskRoundedRect
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to initialize</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t describing the bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="top_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="top_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy" c:identifier="gsk_rounded_rect_init_copy">
        <doc xml:space="preserve">Initializes @self using the given @src rectangle.

This function will not normalize the #GskRoundedRect, so
make sure the source is normalized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect" c:identifier="gsk_rounded_rect_init_from_rect">
        <doc xml:space="preserve">Initializes @self to the given @bounds and sets the radius of all
four corners to @radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the border radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_rect" c:identifier="gsk_rounded_rect_intersects_rect">
        <doc xml:space="preserve">Checks if part of the given @rect is contained inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect intersects with the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_rectilinear" c:identifier="gsk_rounded_rect_is_rectilinear">
        <doc xml:space="preserve">Checks if all corners of @self are right angles and the
rectangle covers all of its bounds.

This information can be used to decide if gsk_clip_node_new()
or gsk_rounded_clip_node_new() should be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the rectangle is rectilinear</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GskRoundedRect to check</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gsk_rounded_rect_normalize">
        <doc xml:space="preserve">Normalizes the passed rectangle.

this function will ensure that the bounds of the rectangle are normalized
and ensure that the corner values are positive and the corners do not overlap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="gsk_rounded_rect_offset">
        <doc xml:space="preserve">Offsets the bound's origin by @dx and @dy.

The size and corners of the rectangle are unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="gsk_rounded_rect_shrink">
        <doc xml:space="preserve">Shrinks (or grows) the given rectangle by moving the 4 sides
according to the offsets given. The corner radii will be changed
in a way that tries to keep the center of the corner circle intact.
This emulates CSS behavior.

This function also works for growing rectangles if you pass
negative values for the @top, @right, @bottom or @left.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resized #GskRoundedRect</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to shrink or grow</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the top side downwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the right side to the left</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the bottom side upwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the left side to the right</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScalingFilter" glib:type-name="GskScalingFilter" glib:get-type="gsk_scaling_filter_get_type" c:type="GskScalingFilter">
      <doc xml:space="preserve">The filters used when scaling texture data.

The actual implementation of each filter is deferred to the
rendering pipeline.</doc>
      <member name="linear" value="0" c:identifier="GSK_SCALING_FILTER_LINEAR" glib:nick="linear">
        <doc xml:space="preserve">linear interpolation filter</doc>
      </member>
      <member name="nearest" value="1" c:identifier="GSK_SCALING_FILTER_NEAREST" glib:nick="nearest">
        <doc xml:space="preserve">nearest neighbor interpolation filter</doc>
      </member>
      <member name="trilinear" value="2" c:identifier="GSK_SCALING_FILTER_TRILINEAR" glib:nick="trilinear">
        <doc xml:space="preserve">linear interpolation along each axis,
  plus mipmap generation, with linear interpolation along the mipmap
  levels</doc>
      </member>
    </enumeration>
    <enumeration name="SerializationError" glib:type-name="GskSerializationError" glib:get-type="gsk_serialization_error_get_type" c:type="GskSerializationError" glib:error-domain="gsk-serialization-error-quark">
      <doc xml:space="preserve">Errors that can happen during (de)serialization.</doc>
      <member name="unsupported_format" value="0" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_FORMAT" glib:nick="unsupported-format">
        <doc xml:space="preserve">The format can not be
    identified</doc>
      </member>
      <member name="unsupported_version" value="1" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_VERSION" glib:nick="unsupported-version">
        <doc xml:space="preserve">The version of the data
    is not understood</doc>
      </member>
      <member name="invalid_data" value="2" c:identifier="GSK_SERIALIZATION_INVALID_DATA" glib:nick="invalid-data">
        <doc xml:space="preserve">The given data may not exist in
    a proper serialization</doc>
      </member>
      <function name="quark" c:identifier="gsk_serialization_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder" glib:type-name="GskShaderArgsBuilder" glib:get-type="gsk_shader_args_builder_get_type" c:symbol-prefix="shader_args_builder">
      <doc xml:space="preserve">An object to build the uniforms data for a #GskGLShader.</doc>
      <constructor name="new" c:identifier="gsk_shader_args_builder_new">
        <doc xml:space="preserve">Allocates a builder that can be used to construct a new uniform data
chunk.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly allocated builder, free with
    gsk_shader_args_builder_unref()</doc>
          <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
        </return-value>
        <parameters>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GskGLShader</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </parameter>
          <parameter name="initial_values" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #Bytes with initial values</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free_to_args" c:identifier="gsk_shader_args_builder_free_to_args" introspectable="0">
        <doc xml:space="preserve">Creates a new #GBytes args from the current state of the
given @builder, and frees the @builder instance. Any uniforms
of the shader that have not been explicitly set on the @builder
are zero-initialized.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #GBytes
  with all the args added to @builder</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_shader_args_builder_ref">
        <doc xml:space="preserve">Increases the reference count of a #GskShaderArgsBuilder by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #GskShaderArgsBuilder</doc>
          <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_bool" c:identifier="gsk_shader_args_builder_set_bool">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of bool type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_float" c:identifier="gsk_shader_args_builder_set_float">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of float type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="gsk_shader_args_builder_set_int">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of int type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint" c:identifier="gsk_shader_args_builder_set_uint">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of uint type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec2" c:identifier="gsk_shader_args_builder_set_vec2">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of vec2 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">A #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec3" c:identifier="gsk_shader_args_builder_set_vec3">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of vec3 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec4" c:identifier="gsk_shader_args_builder_set_vec4">
        <doc xml:space="preserve">Sets the value of the uniform @idx.
The uniform must be of vec4 type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_args" c:identifier="gsk_shader_args_builder_to_args">
        <doc xml:space="preserve">Creates a new #GBytes args from the current state of the
given @builder. Any uniforms of the shader that have not
been explicitly set on the @builder are zero-initialized.

The given #GskShaderArgsBuilder is reset once this function returns;
you cannot call this function multiple times on the same @builder instance.

This function is intended primarily for bindings. C code should use
gsk_shader_args_builder_free_to_args().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated builder, free with
    gsk_shader_args_builder_free()</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_shader_args_builder_unref">
        <doc xml:space="preserve">Decreases the reference count of a #GskShaderArgBuilder by one.
If the resulting reference count is zero, frees the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GskShaderArgsBuilder</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Shadow" c:type="GskShadow">
      <doc xml:space="preserve">The shadow parameters in a shadow node.</doc>
      <field name="color" writable="1">
        <doc xml:space="preserve">the color of the shadow</doc>
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
      <field name="dx" writable="1">
        <doc xml:space="preserve">the horizontal offset of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="dy" writable="1">
        <doc xml:space="preserve">the vertical offset of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="radius" writable="1">
        <doc xml:space="preserve">the radius of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <class name="ShadowNode" c:symbol-prefix="shadow_node" c:type="GskShadowNode" parent="RenderNode" glib:type-name="GskShadowNode" glib:get-type="gsk_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node drawing one or more shadows behind its single child node.</doc>
      <constructor name="new" c:identifier="gsk_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="ShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="shadows" transfer-ownership="none">
            <doc xml:space="preserve">The shadows to apply</doc>
            <array length="2" zero-terminated="0" c:type="const GskShadow*">
              <type name="Shadow" c:type="GskShadow"/>
            </array>
          </parameter>
          <parameter name="n_shadows" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in the @shadows array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_shadow_node_get_child">
        <doc xml:space="preserve">Retrieves the child #GskRenderNode of the shadow @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child render node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_shadows" c:identifier="gsk_shadow_node_get_n_shadows">
        <doc xml:space="preserve">Retrieves the number of shadows in the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of shadows.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shadow" c:identifier="gsk_shadow_node_get_shadow">
        <doc xml:space="preserve">Retrieves the shadow data at the given index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the shadow data</doc>
          <type name="Shadow" c:type="const GskShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow #GskRenderNode</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the given index</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="TextNode" c:symbol-prefix="text_node" c:type="GskTextNode" parent="RenderNode" glib:type-name="GskTextNode" glib:get-type="gsk_text_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node drawing a set of glyphs.</doc>
      <constructor name="new" c:identifier="gsk_text_node_new">
        <doc xml:space="preserve">Creates a render node that renders the given glyphs,
Note that @color may not be used if the font contains
color glyphs.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode</doc>
          <type name="TextNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="font" transfer-ownership="none">
            <doc xml:space="preserve">the #PangoFont containing the glyphs</doc>
            <type name="Pango.Font" c:type="PangoFont*"/>
          </parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve">the #PangoGlyphString to render</doc>
            <type name="Pango.GlyphString" c:type="PangoGlyphString*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the foreground color to render with</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset of the baseline</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color" c:identifier="gsk_text_node_get_color">
        <doc xml:space="preserve">Retrieves the color used by the text @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font" c:identifier="gsk_text_node_get_font">
        <doc xml:space="preserve">Returns the font used by the text @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font</doc>
          <type name="Pango.Font" c:type="PangoFont*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_glyphs" c:identifier="gsk_text_node_get_glyphs">
        <doc xml:space="preserve">Retrieves the glyph information in the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the glyph information</doc>
          <array length="0" zero-terminated="0" c:type="const PangoGlyphInfo*">
            <type name="Pango.GlyphInfo" c:type="PangoGlyphInfo"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_glyphs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of glyphs returned</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_glyphs" c:identifier="gsk_text_node_get_num_glyphs">
        <doc xml:space="preserve">Retrieves the number of glyphs in the text node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of glyphs</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="gsk_text_node_get_offset">
        <doc xml:space="preserve">Retrieves the offset applied to the text.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a point with the horizontal and vertical offsets</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_color_glyphs" c:identifier="gsk_text_node_has_color_glyphs">
        <doc xml:space="preserve">Checks whether the text @node has color glyphs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the text node has color glyphs</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text #GskRenderNode</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="TextureNode" c:symbol-prefix="texture_node" c:type="GskTextureNode" parent="RenderNode" glib:type-name="GskTextureNode" glib:get-type="gsk_texture_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a #GdkTexture.</doc>
      <constructor name="new" c:identifier="gsk_texture_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the given
@texture into the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="TextureNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkTexture</doc>
            <type name="Gdk.Texture" c:type="GdkTexture*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the texture into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_texture" c:identifier="gsk_texture_node_get_texture">
        <doc xml:space="preserve">Retrieves the #GdkTexture used when creating this #GskRenderNode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GdkTexture</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode of type %GSK_TEXTURE_NODE</doc>
            <type name="TextureNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="Transform" c:type="GskTransform" glib:type-name="GskTransform" glib:get-type="gsk_transform_get_type" c:symbol-prefix="transform">
      <doc xml:space="preserve">The `GskTransform` structure contains only private data.</doc>
      <constructor name="new" c:identifier="gsk_transform_new">
        <return-value transfer-ownership="full">
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="gsk_transform_equal">
        <doc xml:space="preserve">Checks two transforms for equality.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two transforms perform the same operation.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the first transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the second transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_category" c:identifier="gsk_transform_get_category">
        <doc xml:space="preserve">Returns the category this transform belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The category of the transform</doc>
          <type name="TransformCategory" c:type="GskTransformCategory"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="gsk_transform_invert">
        <doc xml:space="preserve">Inverts the given transform.

If @self is not invertible, %NULL is returned.
Note that inverting %NULL also returns %NULL, which is
the correct inverse of %NULL. If you need to differentiate
between those cases, you should check @self is not %NULL
before calling this function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The inverted transform or %NULL if the transform
    cannot be inverted.</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to invert</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matrix" c:identifier="gsk_transform_matrix">
        <doc xml:space="preserve">Multiplies @next with the given @matrix.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the matrix to multiply @next with</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="gsk_transform_perspective">
        <doc xml:space="preserve">Applies a perspective projection transform. This transform
scales points in X and Y based on their Z value, scaling
points with positive Z values away from the origin, and
those with negative Z values towards the origin. Points
on the z=0 plane are unchanged.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">distance of the z=0 plane. Lower values give a more
    flattened pyramid and therefore a more pronounced
    perspective effect.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="gsk_transform_print">
        <doc xml:space="preserve">Converts @self into a human-readable string representation suitable
for printing that can later be parsed with gsk_transform_parse().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">The string to print into</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_transform_ref">
        <doc xml:space="preserve">Acquires a reference on the given #GskTransform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GskTransform with an additional reference</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="gsk_transform_rotate">
        <doc xml:space="preserve">Rotates @next @angle degrees in 2D - or in 3Dspeak, around the z axis.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_3d" c:identifier="gsk_transform_rotate_3d">
        <doc xml:space="preserve">Rotates @next @angle degrees around @axis.

For a rotation in 2D space, use gsk_transform_rotate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">The rotation axis</doc>
            <type name="Graphene.Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="gsk_transform_scale">
        <doc xml:space="preserve">Scales @next in 2-dimensional space by the given factors.
Use gsk_transform_scale_3d() to scale in all 3 dimensions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale_3d" c:identifier="gsk_transform_scale_3d">
        <doc xml:space="preserve">Scales @next by the given factors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_z" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_2d" c:identifier="gsk_transform_to_2d">
        <doc xml:space="preserve">Converts a #GskTransform to a 2D transformation
matrix.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D to check.

The returned values have the following layout:

|[&lt;!-- language="plain" --&gt;
  | xx yx |   |  a  b  0 |
  | xy yy | = |  c  d  0 |
  | dx dy |   | tx ty  1 |
]|

This function can be used to convert between a #GskTransform
and a matrix type from other 2D drawing libraries, in particular
Cairo.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a 2D #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_xx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_xy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the x0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the y0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_affine" c:identifier="gsk_transform_to_affine">
        <doc xml:space="preserve">Converts a #GskTransform to 2D affine transformation
factors.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_scale_x" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
    factor in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_scale_y" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
    factor in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_matrix" c:identifier="gsk_transform_to_matrix">
        <doc xml:space="preserve">Computes the actual value of @self and stores it in @out_matrix.
The previous value of @out_matrix will be ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_matrix" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to set</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gsk_transform_to_string">
        <doc xml:space="preserve">Converts a matrix into a string that is suitable for
printing and can later be parsed with gsk_transform_parse().

This is a wrapper around gsk_transform_print(), see that function
for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new string for @self</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_translate" c:identifier="gsk_transform_to_translate">
        <doc xml:space="preserve">Converts a #GskTransform to a translation operation.
@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
    in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="gsk_transform_transform">
        <doc xml:space="preserve">Applies all the operations from @other to @next.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply @other to</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_bounds" c:identifier="gsk_transform_transform_bounds">
        <doc xml:space="preserve">Transforms a #graphene_rect_t using the given transform @self.
The result is the bounding box containing the coplanar quad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="out_rect" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed rectangle</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point" c:identifier="gsk_transform_transform_point">
        <doc xml:space="preserve">Transforms a #graphene_point_t using the given transform @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="out_point" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for
  the transformed point</doc>
            <type name="Graphene.Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="gsk_transform_translate">
        <doc xml:space="preserve">Translates @next in 2dimensional space by @point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate_3d" c:identifier="gsk_transform_translate_3d">
        <doc xml:space="preserve">Translates @next by @point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_transform_unref">
        <doc xml:space="preserve">Releases a reference on the given #GskTransform.

If the reference was the last, the resources associated to the @self are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GskTransform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="gsk_transform_parse">
        <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform. Strings printed via gsk_transform_to_string()
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The location to put the transform in</doc>
            <type name="Transform" c:type="GskTransform**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="TransformCategory" glib:type-name="GskTransformCategory" glib:get-type="gsk_transform_category_get_type" c:type="GskTransformCategory">
      <doc xml:space="preserve">The categories of matrices relevant for GSK and GTK. Note that any
category includes matrices of all later categories. So if you want
to for example check if a matrix is a 2D matrix,
`category &gt;= GSK_TRANSFORM_CATEGORY_2D` is the way to do this.

Also keep in mind that rounding errors may cause matrices to not
conform to their categories. Otherwise, matrix operations done via
mutliplication will not worsen categories. So for the matrix
multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`.</doc>
      <member name="unknown" value="0" c:identifier="GSK_TRANSFORM_CATEGORY_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">The category of the matrix has not been
    determined.</doc>
      </member>
      <member name="any" value="1" c:identifier="GSK_TRANSFORM_CATEGORY_ANY" glib:nick="any">
        <doc xml:space="preserve">Analyzing the matrix concluded that it does
    not fit in any other category.</doc>
      </member>
      <member name="3d" value="2" c:identifier="GSK_TRANSFORM_CATEGORY_3D" glib:nick="3d">
        <doc xml:space="preserve">The matrix is a 3D matrix. This means that
    the w column (the last column) has the values (0, 0, 0, 1).</doc>
      </member>
      <member name="2d" value="3" c:identifier="GSK_TRANSFORM_CATEGORY_2D" glib:nick="2d">
        <doc xml:space="preserve">The matrix is a 2D matrix. This is equivalent
    to graphene_matrix_is_2d() returning %TRUE. In particular, this
    means that Cairo can deal with the matrix.</doc>
      </member>
      <member name="2d_affine" value="4" c:identifier="GSK_TRANSFORM_CATEGORY_2D_AFFINE" glib:nick="2d-affine">
        <doc xml:space="preserve">The matrix is a combination of 2D scale
    and 2D translation operations. In particular, this means that any
    rectangle can be transformed exactly using this matrix.</doc>
      </member>
      <member name="2d_translate" value="5" c:identifier="GSK_TRANSFORM_CATEGORY_2D_TRANSLATE" glib:nick="2d-translate">
        <doc xml:space="preserve">The matrix is a 2D translation.</doc>
      </member>
      <member name="identity" value="6" c:identifier="GSK_TRANSFORM_CATEGORY_IDENTITY" glib:nick="identity">
        <doc xml:space="preserve">The matrix is the identity matrix.</doc>
      </member>
    </enumeration>
    <class name="TransformNode" c:symbol-prefix="transform_node" c:type="GskTransformNode" parent="RenderNode" glib:type-name="GskTransformNode" glib:get-type="gsk_transform_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a #GskTransform to its single child node.</doc>
      <constructor name="new" c:identifier="gsk_transform_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will transform the given @child
with the given @transform.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="TransformNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to transform</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none">
            <doc xml:space="preserve">The transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_transform_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting transformed by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting transformed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a transform</doc>
            <type name="TransformNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transform" c:identifier="gsk_transform_node_get_transform">
        <doc xml:space="preserve">Retrieves the #GskTransform used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskTransform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode for a transform</doc>
            <type name="TransformNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <function-macro name="VULKAN_RENDERER" c:identifier="GSK_VULKAN_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_CLASS" c:identifier="GSK_VULKAN_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_GET_CLASS" c:identifier="GSK_VULKAN_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="VulkanRenderer" c:symbol-prefix="vulkan_renderer" c:type="GskVulkanRenderer" parent="Renderer" glib:type-name="GskVulkanRenderer" glib:get-type="gsk_vulkan_renderer_get_type" glib:type-struct="VulkanRendererClass">
      <constructor name="new" c:identifier="gsk_vulkan_renderer_new">
        <return-value transfer-ownership="full">
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="VulkanRendererClass" c:type="GskVulkanRendererClass" disguised="1" glib:is-gtype-struct-for="VulkanRenderer"/>
    <function name="serialization_error_quark" c:identifier="gsk_serialization_error_quark" moved-to="SerializationError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="transform_parse" c:identifier="gsk_transform_parse" moved-to="Transform.parse">
      <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform. Strings printed via gsk_transform_to_string()
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to parse</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">The location to put the transform in</doc>
          <type name="Transform" c:type="GskTransform**"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
