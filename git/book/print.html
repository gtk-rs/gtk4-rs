<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Rust and GTK 4</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">2.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">3.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="gobject_concepts.html"><strong aria-hidden="true">4.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gobject_memory_management.html"><strong aria-hidden="true">4.1.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="gobject_subclassing.html"><strong aria-hidden="true">4.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="gobject_values.html"><strong aria-hidden="true">4.3.</strong> Generic Values</a></li><li class="chapter-item expanded "><a href="gobject_properties.html"><strong aria-hidden="true">4.4.</strong> Properties</a></li><li class="chapter-item expanded "><a href="gobject_signals.html"><strong aria-hidden="true">4.5.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">5.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">6.</strong> Settings</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">7.</strong> Saving Window State</a></li><li class="chapter-item expanded "><a href="lists.html"><strong aria-hidden="true">8.</strong> Lists</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building a Simple To-Do App</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Interface Builder</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> GtkBuilder</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Templates</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Resources</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Actions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Shortcuts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Media Support</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Images</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.2.</strong> Videos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> App with Persistent Image Selection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Accessibility</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Internationalization</div></li><li class="chapter-item expanded affix "><li class="part-title">Useful Libraries</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> GtkSourceView</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> GStreamer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Libadwaita</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Webkit2Gtk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Zbus and Ashpd</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gui-development-with-rust-and-gtk-4"><a class="header" href="#gui-development-with-rust-and-gtk-4">GUI development with Rust and GTK 4</a></h1>
<p><em>by Julian Hofer, with contributions from the community</em></p>
<p>GTK 4 is the newest version of a popular cross-platform widget toolkit written in C.
Thanks to GObject-Introspection, GTK's API can be easily targeted by various programming languages.
The API even describes the ownership of its parameters!</p>
<p>Managing ownership without giving up speed is one of Rust's greatest strengths, which makes it an excellent choice to develop GTK apps with.
With this combination you do not have to worry about hitting bottlenecks mid-project anymore.
Additionally, with Rust you will have nice things like:</p>
<ul>
<li>Thread safety</li>
<li>Memory safety</li>
<li>Sensible dependency management</li>
<li>Excellent third party libraries, which benefit from the same points as mentioned above</li>
</ul>
<p>The <code>gtk-rs</code> project provides bindings to many GTK-related libraries which we will be using throughout this book.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book assumes that you know your way around Rust code.
If this is not already the case, reading <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> is an enjoyable way to get you to that stage.
If you have experience with another low-level language such as C or C++ you
might find that reading <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half hour to learn Rust</a> gives you sufficient information as well.</p>
<p>Luckily, this — together with the wish to develop graphical applications — is all that is necessary to benefit from this book. </p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. However, if you are using it as a reference for a certain topic,
you might find it useful to just jump into it.</p>
<p>There are two kinds of chapters in this book: concept chapters and project
chapters.
In concept chapters, you will learn about an aspect of GTK development.
In project chapters, we will build small programs together, applying what you have learned so far.</p>
<p>The book strives to explain essential GTK concepts paired with practical examples.
However, if a concept can be better conveyed with a less practical example, we took this path most of the time.
If you are interested in contained and useful examples, we refer you to the corresponding <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/examples">section</a> of <code>gtk4-rs</code>' repository.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The book itself is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.
The only exception are the code snippets which are licensed under the <a href="https://gitlab.gnome.org/Hofer-Julian/gtk-rs-book/-/blob/main/LICENSE">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>There are a few recommended ways to set up your workstation in order to develop <code>gtk-rs</code> applications.
Let us go through them one by one.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a> is Rust's build system and package manager.
If following the book is all you care about, using only Cargo will work fine for you.</p>
<p>Let us begin by installing all necessary tools.
First follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.</p>
<p>Now create a new project by executing:</p>
<pre><code class="language-bash">cargo new my-gtk-app
</code></pre>
<p>Add the following lines to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies.gtk]
version = &quot;0.1&quot;
package = &quot;gtk4&quot;
</code></pre>
<p>Now you can run your application by executing:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="cargo--meson"><a class="header" href="#cargo--meson">Cargo + Meson</a></h2>
<p>Cargo is <em>almost</em> enough, but it is not well suited for handling resources such as icons or UI definition files.
That is why we recommend to use <a href="https://mesonbuild.com/">Meson</a> on top of it.
It is cross-platform and its syntax is very readable.
Meson takes care of</p>
<ul>
<li>translations</li>
<li>building and installing <a href="resources.html">resources</a></li>
<li>installing auxiliary files such as icons and <a href="settings.html">settings schemas</a></li>
</ul>
<p>Here as well, you first follow the instructions on the <a href="https://www.gtk.org/docs/installations/">GTK website</a> in order to install GTK 4.
Then install Rust with <a href="https://rustup.rs/">rustup</a>.
Finally, install Meson by following the instructions on the <a href="https://mesonbuild.com/Getting-meson.html">Meson website</a>.</p>
<p>You can download a ready-to-use gtk-rust-template <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">here</a>.
Follow the instructions in the README to initialize your own application.
Then configure your project.</p>
<pre><code class="language-bash">meson --prefix=/usr build
</code></pre>
<p>In order to compile and install it run the following commands.
You have to execute it every time you modify your application.</p>
<pre><code class="language-bash">ninja -C build &amp;&amp; ninja -C build install
</code></pre>
<p>Now the application should be in a folder included in your system path.
You can either start it with the application launcher of your choice or in the terminal.</p>
<h2 id="cargo--meson--flatpak"><a class="header" href="#cargo--meson--flatpak">Cargo + Meson + Flatpak</a></h2>
<p>If you develop on Linux, using Flatpak is the most convenient option.
With Flatpak your whole workflow is containerized and your users get the very same application you develop on (including all dependencies). 
First, assure that Flatpak is installed on your system, check this <a href="https://flatpak.org/setup/">website</a> to see if any steps are necessary on your distribution.
Then download the <a href="https://gitlab.gnome.org/bilelmoussaoui/gtk-rust-template">gtk-rust-template</a> and follow the instructions in its README.</p>
<p>Then either install:</p>
<ul>
<li><a href="https://flathub.org/apps/details/org.gnome.Builder">GNOME Builder</a> or</li>
<li><a href="https://flathub.org/apps/details/com.vscodium.codium">VSCodium</a> together with the <a href="https://open-vsx.org/extension/matklad/rust-analyzer">rust-analyzer</a> and <a href="https://open-vsx.org/extension/bilelmoussaoui/flatpak-vscode">flatpak</a> extensions.</li>
</ul>
<p>That is it.
The build dependencies can be downloaded by the IDE.
With GNOME Builder, you only have to press the run button for that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Now that we have got a working installation, let us get right into it!</p>
<p>At the very least, we need to create an <code>Application</code> instance, with an application id and the default application flags.
<a href="https://wiki.gnome.org/HowDoI/ChooseApplicationID">This guide</a> helps you find a suitable application id for your app.</p>
<p><span class="filename">Filename: listings/hello_world/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
use gtk::Application;

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());

    // Run the application
    app.run();
}
</code></pre></pre>
<p>It builds fine, but nothing appears on our screen.
GTK warns us, that it would have expected that something would be called in its <code>activate</code> step.
So let us create a window there.</p>
<p><span class="filename">Filename: listings/hello_world/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
use gtk::{Application, ApplicationWindow};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::new(app);

    // Set the window title
    window.set_title(Some(&quot;My GTK App&quot;));

    window.present();
}
</code></pre></pre>
<p>That is better!</p>
<div style="text-align:center"><img src="img/hello_world_empty.png" /></div>
<p>Normally we expect to be able to interact with the user interface.
Also, the name of the chapter suggests that the phrase &quot;Hello World!&quot; will be involved.</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::new(app);

    // Set the window title
    window.set_title(Some(&quot;My GTK App&quot;));

    // Create a button
    let button = Button::with_label(&quot;Press me!&quot;);

    // Set the button margins
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>There is now a button and if we click on it, its label becomes &quot;Hello World!&quot;.</p>
<div style="text-align:center"><img src="img/hello_world_button.png" /></div>
<p>Was not that hard to create our first <code>gtk-rs</code> app, right?
Let us now get a better understanding of what we did here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are the components that make up a GTK application.
GTK offers many-preexisting ones and if those do not fit, you can even create custom ones.
There are display widgets, buttons, containers and windows.
One kind of widget might be able to contain other widgets, it might present information and it might react to interaction.</p>
<p>The <a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> is useful to find out which widget fits your needs.
Let us say we want to add a button to our app.
We have quite a bit of choice here, but let us take the simplest one — a <code>Button</code>.</p>
<div style="text-align:center"><img src="img/widgets_button.png" /></div>
<p>GTK is an object-oriented framework, so all widgets are part of an inheritance tree with <code>GObject</code> at the top.
The inheritance tree of a <code>Button</code> looks like this:</p>
<pre><code class="language-console">GObject
╰── Widget
    ╰── Button
</code></pre>
<p>The <a href="https://docs.gtk.org/gtk4/class.Button.html">GTK documentation</a> also tells us that <code>Button</code> implements the interfaces <code>GtkAccessible</code>, <code>GtkActionable</code>, <code>GtkBuildable</code>, <code>GtkConstraintTarget</code>.</p>
<p>Now let us compare that with the corresponding <code>Button</code> struct in <code>gtk-rs</code>.
The <a href="../docs/gtk4/struct.Button.html#implements">gtk-rs documentation</a> tells us which methods and traits it implements.
We find that these traits either have a corresponding base class or interface in the GTK docs.
In the &quot;Hello World&quot; app we wanted to react to a button click.
This behavior is specific to a button, so we expect to find a suitable method in the <code>ButtonExt</code> trait.
And indeed, <code>ButtonExt</code> includes the method <a href="../docs/gtk4/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.</p>
<p><span class="filename">Filename: listings/widgets/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::new(app);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span>    // Create a button
    let button = Button::with_label(&quot;Press me!&quot;);

    // Set the button margins
    button.set_margin_top(18);
    button.set_margin_bottom(18);
    button.set_margin_start(18);
    button.set_margin_end(18);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Please note that Rust requires bringing traits into scope, before using one of its methods.
In our example we did that by adding the following line:</p>
<p><span class="filename">Filename: listings/widgets/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::prelude::*;
<span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::new(app);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::with_label(&quot;Press me!&quot;);
</span><span class="boring">
</span><span class="boring">    // Set the button margins
</span><span class="boring">    button.set_margin_top(18);
</span><span class="boring">    button.set_margin_bottom(18);
</span><span class="boring">    button.set_margin_start(18);
</span><span class="boring">    button.set_margin_end(18);
</span><span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>With it, we import all necessary traits for dealing with widgets.
You probably want to bring the prelude into scope in most of your source files.</p>
<p>This is also a good moment to mention that all <code>gtk-rs</code> widgets support <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">the builder pattern</a>.
This is especially nice for creating widgets where multiple widget characteristics are already known during its creation.
We can then make the construction of our button neater, by creating a <a href="../docs/gtk4/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a> with the <a href="../docs/gtk4/struct.Button.html#method.builder"><code>Button::builder</code></a> method.</p>
<p><span class="filename">Filename: listings/widgets/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create a button
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();
<span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gobject-concepts"><a class="header" href="#gobject-concepts">GObject Concepts</a></h1>
<p>GTK is an object-oriented framework.
It is written in C, which does not support object-orientation out of the box.
That is why, GTK relies on the GObject library to provide the object system.</p>
<p>We already learned, that <code>gtk-rs</code> maps GObject concepts like inheritance and interfaces to Rust traits.
In this chapter we will additionally find out:</p>
<ul>
<li>How to manage the memory of GObjects.</li>
<li>How to create our own GObjects via subclassing.</li>
<li>How to deal with generic values.</li>
<li>How to use properties.</li>
<li>How to emit and receive signals.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-of-gobjects"><a class="header" href="#memory-management-of-gobjects">Memory management of GObjects</a></h1>
<p>A GObject (or <code>glib::Object</code> in Rust terms) is a reference-counted, mutable object.
Let us see in a set of real life examples which consequences this has.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindow, Button, Orientation};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
    app.connect_activate(build_ui);
    
    // Run the application
    app.run();
}

fn build_ui(application: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::new(application);

    // Create two buttons
    let button_increase = Button::with_label(&quot;Increase&quot;);
    let button_decrease = Button::with_label(&quot;Decrease&quot;);

    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(|_| number += 1);
    button_decrease.connect_clicked(|_| number -= 1);

    // Add buttons
    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
    window.set_child(Some(&amp;gtk_box));
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
    window.present();
}
</code></pre></pre>
<p>Here we would like to create a simple app with two buttons.
If we click on one button, an integer number should be increased. If we press the other one, it should be decreased.
The Rust compiler refuses to compile it though.</p>
<p>For once the borrow checker kicked in:</p>
<pre><code class="language-console">error[E0499]: cannot borrow `number` as mutable more than once at a time
  --&gt; main.rs:27:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ------------------------------------------------
   |     |                               |   |
   |     |                               |   first borrow occurs due to use of `number` in closure
   |     |                               first mutable borrow occurs here
   |     argument requires that `number` is borrowed for `'static`
27 |     button_decrease.connect_clicked(|_| number -= 1);
   |                                     ^^^ ------ second borrow occurs due to use of `number` in closure
   |                                     |
   |                                     second mutable borrow occurs here
</code></pre>
<p>Also, the compiler tells us that our closures may outlive <code>number</code>:</p>
<pre><code class="language-console">
error[E0373]: closure may outlive the current function, but it borrows `number`, which is owned by the current function
  --&gt; main.rs:26:37
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |                                     ^^^ ------ `number` is borrowed here
   |                                     |
   |                                     may outlive borrowed value `number`
   |
note: function requires argument type to outlive `'static`
  --&gt; main.rs:26:5
   |
26 |     button_increase.connect_clicked(|_| number += 1);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `number` (and any other referenced variables), use the `move` keyword
   |
26 |     button_increase.connect_clicked(move |_| number += 1);
   |                                     ^^^^^^^^
</code></pre>
<p>Thinking about the second error message, it makes sense that the closure requires the lifetimes of references to be <code>'static</code>.
The compiler cannot know when the user presses a button, so references must live forever.
And our <code>number</code> gets immediately deallocated after it reaches the end of its scope.
The error message is also suggesting that we could take ownership of <code>number</code>.
But is there actually a way that both closures could take ownership of the same value?</p>
<p>Yes! That is exactly what the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> type is there for.
The <code>Rc</code> counts the number of strong references created via <code>Clone::clone</code> and released via <code>Drop::drop</code>, and only deallocates it when this number drops to zero.
We call every object containing a strong reference a shared owner of the value.
If we want to modify the content of our <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>,
we can use the <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> type.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p><span class="filename">Filename: listings/gobject_memory_management/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // … create a new window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Reference-counted object with inner-mutability
    let number = Rc::new(Cell::new(0));

    // Connect callbacks, when a button is clicked `number` will be changed
    let number_copy_1 = number.clone();
    button_increase.connect_clicked(move |_| number_copy_1.set(number_copy_1.get() + 1));
    button_decrease.connect_clicked(move |_| number.set(number.get() - 1));
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>It is not very nice though to fill the scope with temporary variables like <code>number_copy_1</code>.
We can improve that by using the <code>glib::clone!</code> macro.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` will be changed
</span>    button_increase.connect_clicked(clone!(@strong number =&gt; move |_| {
        number.set(number.get() + 1);
    }));
    button_decrease.connect_clicked(move |_| {
        number.set(number.get() - 1);
    });
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Just like <code>Rc&lt;Cell&lt;T&gt;&gt;</code>, GObjects are reference-counted and mutable.
Therefore, we can pass the buttons the same way to the closure as we did with <code>number</code>.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@strong number, @strong button_decrease =&gt;
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
    }));
    button_decrease.connect_clicked(clone!(@strong button_increase =&gt;
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
    }));
<span class="boring">
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we now click on one button, the other button's label gets changed.</p>
<p>But whoops!
Did we forget about one annoyance of reference-counted systems?
Yes we did: <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycles</a>.
<code>button_increase</code> holds a strong reference to <code>button_decrease</code> and vice-versa.
A strong reference keeps the referenced value from being deallocated.
If this chain leads to a circle, none of the values in this cycle ever get deallocated.
With weak references we can break this cycle, because they do not keep their value alive but instead provide a way to retrieve a strong reference if the value is still alive.
Since we want our apps to free unneeded memory, we should use weak references for the buttons instead<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
    }));
    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
    }));
<span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The reference cycle is broken.
Every time the button is clicked, <code>glib::clone</code> tries to upgrade the weak reference.
If we now for example click on one button and the other button is not there anymore, <code>upgrade</code> will return <code>None</code>.
Per default, it immediately returns from the closure with <code>()</code> as return value.
In case the closure expects a different return value or a panic is preferred <code>@default-return</code> or <code>@default-panic</code>.
For more information about <code>glib::clone</code>, please have a look at the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.clone.html">docs</a>.</p>
<p>Notice that we kept the <em>strong</em> reference to <code>number</code>.
If we had a <em>weak</em> reference, no one would have kept <code>number</code> alive and the closure would have never been called.
Thinking about this, <code>button_increase</code> and <code>button_decrease</code> are also dropped at the end of the scope of <code>build_ui</code>.
Who then keeps the buttons alive?</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span>    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
<span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>When we append the buttons to the <code>gtk_box</code>, <code>gtk_box</code> keeps a strong reference to them.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span>    window.set_child(Some(&amp;gtk_box));
<span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>When we set <code>gtk_box</code> as child of <code>window</code>, <code>window</code> keeps a strong reference to it.</p>
<p><span class="filename">Filename: listings/gobject_memory_management/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{cell::Cell, rc::Rc};
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, ApplicationWindow, Button, Orientation};
</span><span class="boring">use gtk::{glib, Application};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span>    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .build();
<span class="boring">
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label(&quot;Increase&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label(&quot;Decrease&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(@strong number, @weak button_decrease =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">    button_decrease.connect_clicked(clone!(@weak button_increase =&gt;
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">    }));
</span><span class="boring">
</span><span class="boring">    // Add buttons
</span><span class="boring">    let gtk_box = gtk::Box::new(Orientation::Vertical, 0);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>During the creation of our <code>window</code>, we pass <code>application</code> to it.
Because of that, <code>application</code> holds a strong reference to <code>window</code>.
<code>application</code> lives for the whole lifetime of our program, which explains why weak references within our closures are sufficient.</p>
<p>As long as you use weak references whenever possible you will find it perfectly doable to avoid memory cycles within your application.
Then, you can fully rely on GTK to properly manage the memory of GObjects you pass to it.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Please be aware that <code>Cell</code> is only a suitable type for <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a> types.
For other types, <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> is the way to go.
You can learn more about the two cell types in this <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/choosing-your-guarantees.html#cell-types">section</a> of an older edition of the Rust book.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In this simple example, GTK actually resolves the reference cycle on its own once you close the window.
However, the general point to avoid strong references whenever possible remains valid.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h1>
<p>GObjects rely heavily on inheritance.
Therefore, it makes sense that if we want to create a custom GObject, this is done via subclassing.
Let us see how this works by replacing the button in our &quot;Hello World!&quot; app with a custom one.</p>
<p>First, we need to create an implementation struct that holds the state and overrides the virtual methods.
It is advised to keep it in a private module, since its state and methods are only meant to be used by the GObject itself.
It therefore corresponds to the private section of objects in languages like Java and C++.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/custom_button/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gtk::glib;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {}
<span class="boring">}
</span></code></pre></pre>
<p>The description of the subclassing is in <code>ObjectSubclass</code>.</p>
<ul>
<li><code>NAME</code> should consist of crate-name, module-path and object-name in order to avoid name collisions. Use <a href="https://wiki.c2.com/?PascalCase">PascalCase</a> here.</li>
<li><code>Type</code> refers to the actual GObject that will be created afterwards.</li>
<li><code>ParentType</code> is the GObject we inherit of.</li>
</ul>
<p>After that, we would have the option to override the virtual methods of our ancestors.
Since we only want to have a plain button for now, we override nothing.
We still have to add the empty <code>impl</code> though.
Next, we describe our custom GObject.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/custom_button/mod.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">mod imp;

use glib::Object;
use gtk::glib;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        Object::new(&amp;[]).expect(&quot;Failed to create `CustomButton`&quot;)
    }

    pub fn with_label(label: &amp;str) -&gt; Self {
        Object::new(&amp;[(&quot;label&quot;, &amp;label)]).expect(&quot;Failed to create `CustomButton`&quot;)
    }
}

impl Default for CustomButton {
    fn default() -&gt; Self {
        Self::new()
    }
}

<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.glib_wrapper.html"><code>glib::wrapper!</code></a> does the most of the work of subclassing for us.
We only have to point to the implementation struct and which ancestor GObjects we extend.
Please note that the list of ancestor GObjects does not mention <code>glib::Object</code>.
This is because <code>glib::Object</code> is <em>always</em> the base class in the object hierarchy and therefore already implied.</p>
<p>After these steps, nothing is stopping us anymore from replacing <code>gtk::Button</code> with our <code>CustomButton</code>.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">mod custom_button;

use custom_button::CustomButton;
use gtk::prelude::*;
use gtk::{Application, ApplicationWindow};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = CustomButton::with_label(&quot;Press me!&quot;);
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>We are able to use <code>CustomButton</code> as a drop-in replacement for <code>gtk::Button</code>.
This is cool, but also not very tempting to do in a real application.
For the gain of zero benefits, it did involve quite a bit of boilerplate after all.</p>
<p>So let us make it a bit more interesting!
<code>gtk::Button</code> does not hold much state, but we can let <code>CustomButton</code> hold a number.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/2/custom_button/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use gtk::glib;
use gtk::prelude::*;
use gtk::subclass::prelude::*;
use std::cell::Cell;

// Object holding the state
#[derive(Default)]
pub struct CustomButton {
    number: Cell&lt;i32&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);
        obj.set_label(&amp;self.number.get().to_string());
    }
}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self, button: &amp;Self::Type) {
        self.number.set(self.number.get() + 1);
        button.set_label(&amp;self.number.get().to_string())
    }
}

<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We override <code>constructed</code> in <code>ObjectImpl</code> so that the label of the button initializes with <code>number</code>.
We also override <code>clicked</code> in <code>ButtonImpl</code> so that every click increases <code>number</code> and updates the label.</p>
<p><span class="filename">Filename: listings/gobject_subclassing/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = CustomButton::new();
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>In <code>build_ui</code> we stop calling <code>connect_clicked</code>, and that was it.
After a rebuild, the app now features our <code>CustomButton</code> with the label &quot;0&quot;.
Every time we click on the button, the number displayed by the label increases by 1.</p>
<div style="text-align:center"><img src="img/gobject_subclassing.png" /></div>
<p>So, when do we want to inherit from GObject?</p>
<ul>
<li>We want to use a certain widget, but with added state and overridden virtual functions.</li>
<li>We want to pass a Rust object to a function, but the function expects a GObject.</li>
<li>We want to add properties or signals to an object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-values"><a class="header" href="#generic-values">Generic Values</a></h1>
<p>Some GObject-related functions rely on generic values for their arguments or return parameters.
Enums in C are not as powerful as the one in Rust, which is why <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html"><code>glib::Value</code></a> is used for this.
Conceptually though, there are similar to a Rust enum defined like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Value &lt;T&gt; {
    bool(bool),
    i8(i8),
    i32(i32),
    u32(u32),
    i64(i64),
    u64(u64),
    f32(f32),
    f64(f64),
    // boxed types
    String(Option&lt;String&gt;),
    Object(Option&lt;T: impl IsA&lt;Object&gt;&gt;),
<span class="boring">}
</span></code></pre></pre>
<p>That means that a <code>glib::Value</code> can represent a set of types, but only one of them per instance.
For example, this is how you would use a <code>Value</code> representing an <code>i32</code>.</p>
<p><span class="filename">Filename: listings/gobject_values/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Value`
    let integer_value = 10.to_value();

    // Retrieve `i32` from `Value`
    let integer = integer_value
        .get::&lt;i32&gt;()
        .expect(&quot;The value needs to be of type `i32`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, &quot;Hello!&quot;.to_string());
</span><span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}
</span></code></pre></pre>
<p>Please note that boxed types such as <code>String</code> or <code>Object</code> are wrapped in an <code>Option</code>.
This comes from C, where boxed types can always be <code>None</code> (or null in C terms).
You can still access it the same way as with the <code>i32</code> above.
<code>get</code> will then not only return <code>Err</code> if you specified the wrong type, but also if the <code>Value</code> represents <code>None</code>.</p>
<p><span class="filename">Filename: listings/gobject_values/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    // Store string as `Value`
    let string_value = &quot;Hello!&quot;.to_value();

    // Retrieve `String` from `Value`
    let string = string_value
        .get::&lt;String&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(string, &quot;Hello!&quot;.to_string());
<span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}
</span></code></pre></pre>
<p>If you want to differentiate between specifying the wrong type and a <code>Value</code> representing <code>None</code>, just call <code>get::&lt;Option&lt;T&gt;&gt;</code> instead.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = &quot;Hello!&quot;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, &quot;Hello!&quot;.to_string());
</span><span class="boring">
</span>    // Store `Option&lt;String&gt;` as `Value`
    let string_some_value = &quot;Hello!&quot;.to_value();
    let string_none_value = None::&lt;String&gt;.to_value();

    // Retrieve `String` from `Value`
    let string_some = string_some_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);
    let string_none = string_none_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect(&quot;The value needs to be of type `String`.&quot;);

    // Check if the retrieved value is correct
    assert_eq!(string_some, Some(&quot;Hello!&quot;.to_string()));
    assert_eq!(string_none, None);
<span class="boring">}
</span></code></pre></pre>
<p>For now, all you need to know is how to convert a Rust type into a <code>glib::Value</code> and vice versa.
This knowledge will be useful in the next chapters where we discuss properties, signals and models.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<p>Properties provide a public API for accessing state of GObjects.</p>
<p>Let us see how this is done by experimenting with the <code>Switch</code> widget.
One of its properties is the <a href="https://docs.gtk.org/gtk4/property.Switch.state.html">state</a>.
According to the GTK docs, it can be read and be written to.
That is why <code>gtk-rs</code> provides corresponding <a href="../docs/gtk4/struct.Switch.html#method.state"><code>state</code></a> and <a href="../docs/gtk4/docs/gtk4/struct.Switch.html#method.set_state"><code>set_state</code></a> methods.</p>
<p><span class="filename">Filename: listings/gobject_properties/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Box, Orientation, Switch};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain state
    switch.set_state(true);
    let current_state = switch.state();

    // This prints: &quot;The current state is true&quot;
    println!(&quot;The current state is {}&quot;, current_state);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Alternatively, we can use the general <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.property"><code>property</code></a> and <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.set_property"><code>set_property</code></a> methods.
Because they can be used for properties of different types, they operate with <code>glib::Value</code>.</p>
<p><span class="filename">Filename: listings/gobject_properties/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Box, Orientation, Switch};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain state
    switch
        .set_property(&quot;state&quot;, &amp;true)
        .expect(&quot;Could not set property.&quot;);
    let current_state = switch
        .property(&quot;state&quot;)
        .expect(&quot;The property needs to exist and be readable.&quot;)
        .get::&lt;bool&gt;()
        .expect(&quot;The property needs to be of type `bool`.&quot;);

    // This prints: &quot;The current state is true&quot;
    println!(&quot;The current state is {}&quot;, current_state);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Dealing with a <code>glib::Value</code> is quite verbose.
This is why you only want to use the generic methods for accessing properties you have added to your custom GObjects.</p>
<p>Properties can not only be accessed via getters &amp; setters, they can also be bound to each other.
Let us see how that would look like for two <code>Switch</code> instances.</p>
<p><span class="filename">Filename: listings/gobject_properties/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the switches
    let switch_1 = Switch::new();
    let switch_2 = Switch::new();
<span class="boring">
</span><span class="boring">    switch_1
</span><span class="boring">        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>In our case, we want to bind the &quot;state&quot; property of <code>switch_1</code> to the &quot;state&quot; property of <code>switch_2</code>.
We also want the binding to be bidirectional, so we specify this with the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html"><code>BindingFlags</code></a>.</p>
<p><span class="filename">Filename: listings/gobject_properties/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation, Switch};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the switches
</span><span class="boring">    let switch_1 = Switch::new();
</span><span class="boring">    let switch_2 = Switch::new();
</span><span class="boring">
</span>    switch_1
        .bind_property(&quot;state&quot;, &amp;switch_2, &quot;state&quot;)
        .flags(BindingFlags::BIDIRECTIONAL)
        .build();
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Now when we click on one of the two switches, the other one is toggled as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_switches.png" /></div>
<p>We can also add properties to custom GObjects.
We can demonstrate that by binding the <code>number</code> of our <code>CustomButton</code> to a property.
For that we need to be able to <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily evaluate</a> expressions.
The crate <code>once_cell</code> provides the <code>Lazy</code> type which allows us to do that.
<code>once_cell</code> is already part of Rust nightly.
Until it hits stable, we will add it as external dependency.</p>
<p><span class="filename">Filename: listings/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
once_cell = &quot;1&quot;
</code></pre>
<p>Now we define the &quot;number&quot; property within the <code>ObjectImpl</code> implementation.
The <code>properties</code> method describes our set of properties.
When naming our property, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
Then we describe its type, range and default value.
We also declare that the property can be read and be written to.
<code>set_property</code> describes how the underlying values can be changed.
<code>property</code> takes care of returning the underlying value.
The formerly private <code>number</code> is now accessible via the <code>property</code> and <code>set_property</code> methods.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/custom_button/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn properties() -&gt; &amp;'static [ParamSpec] {
        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
            vec![ParamSpec::new_int(
                // Name
                &quot;number&quot;,
                // Nickname
                &quot;number&quot;,
                // Short description
                &quot;number&quot;,
                // Minimum value
                i32::MIN,
                // Maximum value
                i32::MAX,
                // Default value
                0,
                // The property can be read and written to
                ParamFlags::READWRITE,
            )]
        });
        PROPERTIES.as_ref()
    }

    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
        match pspec.name() {
            &quot;number&quot; =&gt; {
                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
                self.number.replace(input_number);
            }
            _ =&gt; unimplemented!(),
        }
    }

    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
        match pspec.name() {
            &quot;number&quot; =&gt; self.number.get().to_value(),
            _ =&gt; unimplemented!(),
        }
    }

    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);

        // Bind label to number
        // `SYNC_CREATE` ensures that the label will be immediately set
        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">        let incremented_number = self.number.get() + 1;
</span><span class="boring">        button
</span><span class="boring">            .set_property(&quot;number&quot;, &amp;incremented_number)
</span><span class="boring">            .expect(&quot;Could not set property.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span>
<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We can immediately take advantage of this new property by binding the &quot;label&quot; property to it.
It even converts the integer value of &quot;number&quot; to the string of &quot;label&quot;.
Now we do not have to adapt the label in the &quot;clicked&quot; callback anymore.</p>
<p>Let us see what we can do with this by creating two custom buttons.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create the buttons
    let button_1 = CustomButton::new();
    let button_2 = CustomButton::new();
<span class="boring">
</span><span class="boring">    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
</span><span class="boring">        .transform_to(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
</span><span class="boring">        .transform_from(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">        println!(&quot;The current number of `button_1` is {}.&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>We have already seen that bound properties do not necessarily have to be of the same type.
By leveraging <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_to"><code>transform_to</code></a> and <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_from"><code>transform_from</code></a>, we can assure that <code>button_2</code> always displays a number which is 1 higher than the number of <code>button_1</code>.</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span>    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
    button_1
        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
        .transform_to(|_, value| {
            let number = value
                .get::&lt;i32&gt;()
                .expect(&quot;The property needs to be of type `i32`.&quot;);
            let incremented_number = number + 1;
            Some(incremented_number.to_value())
        })
        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
        .transform_from(|_, value| {
            let number = value
                .get::&lt;i32&gt;()
                .expect(&quot;The property needs to be of type `i32`.&quot;);
            let decremented_number = number - 1;
            Some(decremented_number.to_value())
        })
        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
        .build();
<span class="boring">
</span><span class="boring">    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
</span><span class="boring">    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
</span><span class="boring">        let number = button
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">        println!(&quot;The current number of `button_1` is {}.&quot;, number);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Now if we click on one button, the &quot;number&quot; and &quot;label&quot; properties of the other button change as well.</p>
<div style="text-align:center"><img src="img/gobject_properties_buttons.png"/></div>
<p>The final nice feature of properties is, that you can connect a callback to the event when a property gets changed.
We can do this like this:</p>
<p><span class="filename">Filename: listings/gobject_properties/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::{glib, Align, Orientation};
</span><span class="boring">use gtk::{prelude::*, Box};
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    // Assure that &quot;number&quot; of `button_2` is always 1 higher than &quot;number&quot; of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property(&quot;number&quot;, &amp;button_2, &quot;number&quot;)
</span><span class="boring">        // How to transform &quot;number&quot; from `button_1` to &quot;number&quot; of `button_2`
</span><span class="boring">        .transform_to(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform &quot;number&quot; from `button_2` to &quot;number&quot; of `button_1`
</span><span class="boring">        .transform_from(|_, value| {
</span><span class="boring">            let number = value
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // The closure will be called whenever the property &quot;number&quot; of `button_1` gets changed
    button_1.connect_notify_local(Some(&quot;number&quot;), move |button, _| {
        let number = button
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);
        println!(&quot;The current number of `button_1` is {}.&quot;, number);
    });
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">    window.set_child(Some(&amp;gtk_box));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, whenever the &quot;number&quot; property gets changed, the closure gets executed and prints the current value of &quot;number&quot;.</p>
<p>Introducing properties to your custom GObjects is useful if you want to</p>
<ul>
<li>allow consumers to be able to access internal state</li>
<li>bind state of (different) GObjects</li>
<li>notify consumers whenever a property value changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>GObject signals are a system for registering callbacks for specific events.
For example, if we press on a button, the &quot;clicked&quot; signal will be emitted.
The signal then takes care that all the registered callbacks will be executed.</p>
<p><code>gtk-rs</code> provides convenience methods for registering callbacks.
In our &quot;Hello World&quot; example we <a href="../docs/gtk4/trait.ButtonExt.html#tymethod.connect_clicked">connected</a> the &quot;clicked&quot; signal to a closure which sets the label of the button to &quot;Hello World&quot; as soon as it gets called.</p>
<p><span class="filename">Filename: listings/gobject_signals/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::new(app);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If we wanted to, we could have 
connected to it with the generic <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect_local"><code>connect_local</code></a> method.</p>
<p><span class="filename">Filename: listings/gobject_signals/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::new(app);
</span><span class="boring">
</span><span class="boring">    // Set the window title
</span><span class="boring">    window.set_title(Some(&quot;My GTK App&quot;));
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button
        .connect_local(&quot;clicked&quot;, false, move |args| {
            // Get the button from the arguments
            let button = args[0]
                .get::&lt;Button&gt;()
                .expect(&quot;The value needs to be of type `Button`.&quot;);
            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
            button.set_label(&quot;Hello World!&quot;);
            None
        })
        .expect(&quot;Could not connect to signal.&quot;);
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Similar to the generic way of accessing properties, the advantage of <code>connect_local</code> is that it also works with custom signals<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Let us see how we can create our own signals.
Again we do that by extending our <code>CustomButton</code>.
First we override the necessary methods in <code>ObjectImpl</code>.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/custom_button/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn signals() -&gt; &amp;'static [Signal] {
        static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
            vec![Signal::builder(
                // Signal name
                &quot;max-number-reached&quot;,
                // Types of the values which will be sent to the signal handler
                &amp;[i32::static_type().into()],
                // Type of the value the signal handler sends back
                &lt;()&gt;::static_type().into(),
            )
            .build()]
        });
        SIGNALS.as_ref()
    }
<span class="boring">
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![ParamSpec::new_int(
</span><span class="boring">                // Name
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Nickname
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Short description
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Minimum value
</span><span class="boring">                i32::MIN,
</span><span class="boring">                // Maximum value
</span><span class="boring">                i32::MAX,
</span><span class="boring">                // Default value
</span><span class="boring">                0,
</span><span class="boring">                // The property can be read and written to
</span><span class="boring">                ParamFlags::READWRITE,
</span><span class="boring">            )]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; {
</span><span class="boring">                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">                self.number.replace(input_number);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; self.number.get().to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">static MAX_NUMBER: i32 = 8;
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self, button: &amp;Self::Type) {
</span><span class="boring">        let incremented_number = self.number.get() + 1;
</span><span class="boring">        // If `number` reached `MAX_NUMBER`,
</span><span class="boring">        // emit &quot;max-number-reached&quot; signal and set `number` back to 0
</span><span class="boring">        if incremented_number == MAX_NUMBER {
</span><span class="boring">            button
</span><span class="boring">                .emit_by_name(&quot;max-number-reached&quot;, &amp;[&amp;incremented_number])
</span><span class="boring">                .expect(&quot;Could not emit signal.&quot;);
</span><span class="boring">            button
</span><span class="boring">                .set_property(&quot;number&quot;, &amp;0)
</span><span class="boring">                .expect(&quot;Could not set property.&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            button
</span><span class="boring">                .set_property(&quot;number&quot;, &amp;incremented_number)
</span><span class="boring">                .expect(&quot;Could not set property.&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>signal</code> method is responsible for defining a set of signals.
In our case, we only create a single signal named &quot;max-number-reached&quot;.
When naming our signal, we make sure to do that in <a href="https://wiki.c2.com/?KebabCase">kebab-case</a>.
When emitted, it sends a single <code>i32</code> value and expects nothing in return.</p>
<p>We want the signal to be emitted, whenever <code>number</code> reaches <code>MAX_NUMBER</code>.
Together with the signal we send the value <code>number</code> currently holds.
After we did that, we set <code>number</code> back to 0.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/custom_button/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::{BindingFlags, ParamFlags, ParamSpec, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn signals() -&gt; &amp;'static [Signal] {
</span><span class="boring">        static SIGNALS: Lazy&lt;Vec&lt;Signal&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![Signal::builder(
</span><span class="boring">                // Signal name
</span><span class="boring">                &quot;max-number-reached&quot;,
</span><span class="boring">                // Types of the values which will be sent to the signal handler
</span><span class="boring">                &amp;[i32::static_type().into()],
</span><span class="boring">                // Type of the value the signal handler sends back
</span><span class="boring">                &lt;()&gt;::static_type().into(),
</span><span class="boring">            )
</span><span class="boring">            .build()]
</span><span class="boring">        });
</span><span class="boring">        SIGNALS.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![ParamSpec::new_int(
</span><span class="boring">                // Name
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Nickname
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Short description
</span><span class="boring">                &quot;number&quot;,
</span><span class="boring">                // Minimum value
</span><span class="boring">                i32::MIN,
</span><span class="boring">                // Maximum value
</span><span class="boring">                i32::MAX,
</span><span class="boring">                // Default value
</span><span class="boring">                0,
</span><span class="boring">                // The property can be read and written to
</span><span class="boring">                ParamFlags::READWRITE,
</span><span class="boring">            )]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; {
</span><span class="boring">                let input_number = value.get().expect(&quot;The value needs to be of type `i32`.&quot;);
</span><span class="boring">                self.number.replace(input_number);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;number&quot; =&gt; self.number.get().to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        obj.bind_property(&quot;number&quot;, obj, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>static MAX_NUMBER: i32 = 8;
// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self, button: &amp;Self::Type) {
        let incremented_number = self.number.get() + 1;
        // If `number` reached `MAX_NUMBER`,
        // emit &quot;max-number-reached&quot; signal and set `number` back to 0
        if incremented_number == MAX_NUMBER {
            button
                .emit_by_name(&quot;max-number-reached&quot;, &amp;[&amp;incremented_number])
                .expect(&quot;Could not emit signal.&quot;);
            button
                .set_property(&quot;number&quot;, &amp;0)
                .expect(&quot;Could not set property.&quot;);
        } else {
            button
                .set_property(&quot;number&quot;, &amp;incremented_number)
                .expect(&quot;Could not set property.&quot;);
        }
    }
}

<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>If we now press on the button, the number of its label increases until it reaches <code>MAX_NUMBER</code>.
Then it emits the &quot;max-number-reached&quot; signal which we can nicely connect to.
Whenever we now receive the &quot;max-number-reached&quot; signal, the accompanying number is printed to standard output.</p>
<p><span class="filename">Filename: listings/gobject_signals/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span>    button
        .connect_local(&quot;max-number-reached&quot;, false, move |args| {
            // Get the number from the arguments
            // args[0] would return the `CustomButton` instance
            let number = args[1]
                .get::&lt;i32&gt;()
                .expect(&quot;The value needs to be of type `i32`.&quot;);
            println!(&quot;The maximum number {} has been reached&quot;, number);
            None
        })
        .expect(&quot;Could not connect to signal.&quot;);
<span class="boring">
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>You now know how to connect to every kind of signal and how to create your own.
Custom signals are especially useful, if you want to notify consumers of your GObject that a certain event occurred.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>If you want to connect from a different thread than the main thread, make sure to use <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect"><code>connect</code></a> instead of <code>connect_local</code>. However, that also means that your connected closure has to implement <a href="https://doc.rust-lang.org/stable/core/marker/trait.Send.html"><code>Send</code></a> + <a href="https://doc.rust-lang.org/stable/core/marker/trait.Sync.html"><code>Sync</code></a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-main-event-loop"><a class="header" href="#the-main-event-loop">The main event loop</a></h1>
<p>We now got comfortable using callbacks, but how do they actually work?
All of this happens asynchronously, so there must be something managing the events and scheduling the responses.
Unsurprisingly, this is called the main event loop.</p>
<div style="text-align:center"><img src="img/main_event_loop.png" /></div>
<p>The main loop manages all kinds of events — from mouse clicks and keyboard presses to file events.
It does all of that within the same thread.
Quickly iterating between all tasks gives the illusion of parallelism.
That is why you can move the window at the same time as a progress bar is growing.</p>
<p>However, you surely saw GUIs that became unresponsive, at least for a few seconds.
That happens when a single task takes too long.
Let us look at one example.</p>
<p><span class="filename">Filename: listings/main_event_loop/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, Application, ApplicationWindow, Button};

fn main() {
    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .build();

    // Create a button
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect callback
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        std::thread::sleep(five_seconds);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}
</code></pre></pre>
<p>After we press the button, the GUI is completely frozen for five seconds.
We can't even move the window.
The <code>sleep</code> call is an artificial example,
but it is not unusual wanting to run a slightly longer operation in one go.
For that we just need to spawn a new thread and let the operation run there.</p>
<p><span class="filename">Filename: listings/main_event_loop/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>If you come from another language than Rust, you might be uncomfortable with the thought of spawning new threads before even looking at other options.
Luckily, Rust's safety guarantees allow you to stop worrying about the nasty bugs that concurrency tends to bring.</p>
<p>Normally we want to keep track of the work in the thread.
In our case, we don't want the user to spawn additional threads while an existing one is still running.
In order to achieve that we can create a channel.
The main loop allows us to send a message from multiple places to a single receiver at the main thread.
We want to send a <code>bool</code> to inform, whether we want the button to react to clicks or not.</p>
<p><span class="filename">Filename: listings/main_event_loop/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect callback
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            sender.send(false).expect(&quot;Could not send through channel&quot;);
            let ten_seconds = Duration::from_secs(10);
            thread::sleep(ten_seconds);
            // Activate the button again
            sender.send(true).expect(&quot;Could not send through channel&quot;);
        });
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Spawning threads is not the only way to run operations asynchronously.
You can also let the main loop take care of running <code>async</code> functions.
If you do that from the main thread use <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html#method.spawn_local"><code>spawn_local</code></a>, from other threads <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html#method.spawn"><code>spawn</code></a> has to be used.
The converted code looks and behaves very similar to the multi-threaded code.</p>
<p><span class="filename">Filename: listings/main_event_loop/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{clone, timeout_future_seconds, Continue, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = MainContext::channel(PRIORITY_DEFAULT);
    // Connect callback
    button.connect_clicked(move |_| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@strong sender =&gt; async move {
            // Deactivate the button until the operation is done
            sender.send(false).expect(&quot;Could not send through channel&quot;);
            timeout_future_seconds(5).await;
            // Activate the button again
            sender.send(true).expect(&quot;Could not send through channel&quot;);
        }));
    });

    // The main loop executes the closure as soon as it receives the message
    receiver.attach(
        None,
        clone!(@weak button =&gt; @default-return Continue(false),
                    move |enable_button| {
                        button.set_sensitive(enable_button);
                        Continue(true)
                    }
        ),
    );
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Since we are single-threaded again, we could even get rid of the channels while achieving the same result.</p>
<p><span class="filename">Filename: listings/main_event_loop/5/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use glib::{clone, timeout_future_seconds, MainContext};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect callback
    button.connect_clicked(move |button| {
        let main_context = MainContext::default();
        // The main loop executes the asynchronous block
        main_context.spawn_local(clone!(@weak button =&gt; async move {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            timeout_future_seconds(5).await;
            // Activate the button again
            button.set_sensitive(true);
        }));
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>But why did we not do the same thing with our multi-threaded example?</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE
    
    // Connect callback
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        thread::spawn(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Simply because we would get this error message:</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>After reference cycles we found the second disadvantage of GTK GObjects: They are not thread safe.</p>
<p>So when should you spawn an <code>async</code> block and when should you spawn a thread?</p>
<ul>
<li>If you have <code>async</code> functions for your IO-bound operations at your disposal, feel free to spawn them on the main loop.</li>
<li>If your operation is computation-bound or there is no <code>async</code> function available, you have to spawn threads.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>We have now learned multiple ways to handle states.
However, every time we close the application all of it is gone.
Let us learn how to use <code>GSettings</code> by storing the state of a <a href="../docs/gtk4/struct.Switch.html"><code>Switch</code></a> in it.</p>
<p>At the very beginning we have to create a <code>GSchema</code> xml file in order to describe the kind of data our application plans to store in the settings.</p>
<p><span class="filename">Filename: listings/settings/1/org.gtk.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk.example&quot; path=&quot;/org/gtk/example/&quot;&gt;
    &lt;key name=&quot;is-switch-enabled&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default switch state&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Let us get through it step by step.
The <code>id</code> is the same application id we used when we created our application.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
<span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>path</code> must start and end with a forward slash character ('/') and must not contain two sequential slash characters.
When creating a <code>path</code>, we advise to take the <code>id</code>, replace the '.' with '/' and add '/' at the front and end of it.</p>
<p>We only want to store a single key with the <code>name</code> &quot;is-switch-enabled&quot;.
This is a boolean value so its <code>type</code> is &quot;b&quot; (see <a href="https://developer.gnome.org/glib/stable/gvariant-format-strings.html">GVariant Format Strings</a> for the other options).
Finally, we define its default value and add a summary.</p>
<p>Now we have to install the <code>GSchema</code> by executing the following commands:</p>
<pre><code class="language-bash">$ sudo install -D org.gtk.example.gschema.xml /usr/share/glib-2.0/schemas/
$ sudo glib-compile-schemas /usr/share/glib-2.0/schemas/
</code></pre>
<p>This has to be repeated every time we change the <code>GSchema</code>.
That is why we probably want to use a build system like <a href="https://mesonbuild.com/">Meson</a> to do it for us.</p>
<p>We initialize the <code>Settings</code> object by specifying the application id.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Initialize settings
    let settings = Settings::new(&quot;org.gtk.example&quot;);
<span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Then we get the settings key and use it when we create our <code>Switch</code>.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span>    // Get the last switch state from the settings
    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);

    // Create a switch
    let switch = Switch::builder()
        .margin_top(48)
        .margin_bottom(48)
        .margin_start(48)
        .margin_end(48)
        .valign(Align::Center)
        .halign(Align::Center)
        .state(is_switch_enabled)
        .build();
<span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
</span><span class="boring">            .expect(&quot;Could not set setting.&quot;);
</span><span class="boring">        // Do not inhibit the the default handler
</span><span class="boring">        Inhibit(false)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Finally, we assure that the switch state is stored in the settings whenever we click on it.</p>
<p><span class="filename">Filename: listings/settings/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::{glib::signal::Inhibit, prelude::*};
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean(&quot;is-switch-enabled&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    switch.connect_state_set(move |_, is_enabled| {
        // Save changed switch state in the settings
        settings
            .set_boolean(&quot;is-switch-enabled&quot;, is_enabled)
            .expect(&quot;Could not set setting.&quot;);
        // Do not inhibit the the default handler
        Inhibit(false)
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>Switch</code> now retains its state even after closing the application.
But we can make this even better.
The <code>Switch</code> has a property &quot;state&quot; and <code>Settings</code> allows us to bind properties to a specific setting.
So let us do exactly that.</p>
<p>We can remove the <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/trait.SettingsExt.html#tymethod.boolean"><code>boolean</code></a> call before initializing the <code>Switch</code> as well as the <code>connect_state_set</code> call.
We then bind the setting to the property by specifying the key, object and name of the property.
Additionally, we specify <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.SettingsBindFlags.html"><code>SettingsBindFlags</code></a> to control the direction in which the binding works.</p>
<p><span class="filename">Filename: listings/settings/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::{Settings, SettingsBindFlags};
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(&quot;org.gtk.example&quot;);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    settings
        .bind(&quot;is-switch-enabled&quot;, &amp;switch, &quot;state&quot;)
        .flags(SettingsBindFlags::DEFAULT)
        .build();
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;switch));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>Whenever you have a property which nicely correspond to a setting, you probably want to bind it to it.
In other cases, interacting with the settings via the getter and setter methods tends to be the right choice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-window-state"><a class="header" href="#saving-window-state">Saving Window State</a></h1>
<p>Quite often, we want the window state to persist between sessions.
If the user resizes or maximizes the window, they might expect to find it in the same state the next time they open the app.
GTK does not provide this functionality out of the box, but luckily it is not too hard to manually implement it.
We basically want two integers (<code>height</code> &amp; <code>width</code>) and a boolean (<code>is_maximized</code>) to persist.
We already know how to do this by using <code>Settings</code>.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/org.gtk.example.gschema.xml</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;schemalist&gt;
  &lt;schema id=&quot;org.gtk.example&quot; path=&quot;/org/gtk/example/&quot;&gt;
    &lt;key name=&quot;window-width&quot; type=&quot;i&quot;&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window width&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name=&quot;window-height&quot; type=&quot;i&quot;&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window height&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name=&quot;is-maximized&quot; type=&quot;b&quot;&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default window maximized behaviour&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Since we do not care about intermediate state, we only load the window state when the window is constructed and save it when we close the window.
That can be done by creating a custom window.
First, we create one and add methods for getting and setting the window state.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/custom_window/mod.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct CustomWindow(ObjectSubclass&lt;imp::CustomWindow&gt;)
        @extends gtk::Widget, gtk::Window, gtk::ApplicationWindow,
        @implements gio::ActionMap, gio::ActionGroup;
}

impl CustomWindow {
    pub fn new(app: &amp;Application) -&gt; Self {
        let window: Self = Object::new(&amp;[]).expect(&quot;Failed to create CustomWindow&quot;);
        window.set_application(Some(app));
        window
    }

    pub fn save_window_size(&amp;self) -&gt; Result&lt;(), glib::BoolError&gt; {
        // Get `settings` from `imp::CustomWindow`
        let settings = &amp;imp::CustomWindow::from_instance(self).settings;

        // Get the size of the window
        let size = self.default_size();

        // Get the window state from `settings`
        settings.set_int(&quot;window-width&quot;, size.0)?;
        settings.set_int(&quot;window-height&quot;, size.1)?;
        settings.set_boolean(&quot;is-maximized&quot;, self.is_maximized())?;

        Ok(())
    }

    fn load_window_size(&amp;self) {
        // Get `settings` from `imp::CustomWindow`
        let settings = &amp;imp::CustomWindow::from_instance(self).settings;

        // Set the window state in `settings`
        let width = settings.int(&quot;window-width&quot;);
        let height = settings.int(&quot;window-height&quot;);
        let is_maximized = settings.boolean(&quot;is-maximized&quot;);

        // Set the size of the window
        self.set_default_size(width, height);

        // If the window was maximized when it was closed, maximize it again
        if is_maximized {
            self.maximize();
        }
    }
}

<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The implementation struct holds the <code>settings</code>.
We also overload the <code>constructed</code> and <code>close_request</code> methods, where we load or save the window state. </p>
<p><span class="filename">Filename: listings/saving_window_state/1/custom_window/imp.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{subclass::prelude::*, ApplicationWindow};
</span><span class="boring">
</span>pub struct CustomWindow {
    pub settings: Settings,
}

#[glib::object_subclass]
impl ObjectSubclass for CustomWindow {
    const NAME: &amp;'static str = &quot;CustomWindow&quot;;
    type Type = super::CustomWindow;
    type ParentType = ApplicationWindow;

    fn new() -&gt; Self {
        Self {
            settings: Settings::new(&quot;org.gtk.example&quot;),
        }
    }
}
impl ObjectImpl for CustomWindow {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        self.parent_constructed(obj);
        // Load latest window state
        obj.load_window_size();
    }
}
impl WidgetImpl for CustomWindow {}
impl WindowImpl for CustomWindow {
    // Save window state right before the window will be closed
    fn close_request(&amp;self, obj: &amp;Self::Type) -&gt; Inhibit {
        if let Err(err) = obj.save_window_size() {
            log::error!(&quot;Failed to save window state, {}&quot;, &amp;err);
        }
        // Do not inhibit the the default handler
        Inhibit(false)
    }
}
impl ApplicationWindowImpl for CustomWindow {}

<span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>That is it!
Now our window retains its state between app sessions.</p>
<p>Please note how we handle a failure in saving into the settings.
We do not want to panic for recoverable errors.
We might also not want to present all problems at the GUI.
In our case we could not even do this, because the window will be immediately closed after the error occurs.
Logging is the standard way of handling a situation like this.
For that, we need to add the <code>log</code> crate and one of its front-ends, such as <code>pretty_env_logger</code>, to our dependencies.</p>
<p><span class="filename">Filename: listings/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;
pretty_env_logger = &quot;0.4&quot;
</code></pre>
<p>We then have to initialize <code>pretty_env_logger</code> by calling <code>init</code> in <code>main</code>.</p>
<p><span class="filename">Filename: listings/saving_window_state/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod custom_window;
</span><span class="boring">
</span><span class="boring">use custom_window::CustomWindow;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, Button};
</span><span class="boring">
</span>fn main() {
    // Initialize logger
    pretty_env_logger::init();

    // Create a new application
    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = CustomWindow::new(app);
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label(&quot;Press me!&quot;)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect callback
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}
</span></code></pre></pre>
<p>We can now modify the log level by setting the <code>RUST_LOG</code> environment variable as can be seen <a href="https://docs.rs/env_logger/latest/env_logger/">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>Sometimes you want to display a list of elements in a certain arrangement.
<a href="../docs/gtk4/struct.ListBox.html"><code>ListBox</code></a> and <a href="../docs/gtk4/struct.FlowBox.html"><code>FlowBox</code></a> are two container widgets which allow you to do this.
<code>ListBox</code> describes a vertical list and <code>FlowBox</code> describes a grid.</p>
<p>Let us explore this concept by adding labels to a <code>ListBox</code>.
Each label will display an integer starting from 0 and ranging up to 100.</p>
<p><span class="filename">Filename: listings/lists/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&amp;number.to_string()));
        list_box.append(&amp;label);
    }
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>We cannot display so many widgets at once.
Therefore, we add <code>ListBox</code> to a <a href="../docs/gtk/struct.ScrolledWindow.html"><code>ScrolledWindow</code></a>.
Now we can scroll through our elements.</p>
<p><span class="filename">Filename: listings/lists/1/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a `ListBox` and add labels with integers from 0 to 100
</span><span class="boring">    let list_box = ListBox::new();
</span><span class="boring">    for number in 0..=100 {
</span><span class="boring">        let label = Label::new(Some(&amp;number.to_string()));
</span><span class="boring">        list_box.append(&amp;label);
</span><span class="boring">    }
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_box)
        .build();
    window.set_child(Some(&amp;scrolled_window));
    window.show();
<span class="boring">}
</span></code></pre></pre>
<div style="text-align:center"><img src="img/lists_list_box.png"/></div>
<p>That was easy enough.
However, we currently create one widget per element.
Since each widget takes up a bit of resources, many of them can lead to slow and unresponsive user interfaces.
Depending on the widget type even thousands of elements might not be a problem.
But how could we possibly deal with the infinite amount of posts in a social media timeline?</p>
<p>We use scalable lists instead!</p>
<ul>
<li>The <strong>model</strong> holds our data, filters it and describes its order.</li>
<li>The <strong>list item factory</strong> defines how the data transforms into widgets.</li>
<li>The <strong>view</strong> specifies how the widgets are then arranged.</li>
</ul>
<p>What makes this concept scalable is that GTK only has to create slightly more widgets than we can currently look at.
As we scroll through our elements, the widgets which become invisible will be reused.
The following figure demonstrates how this works in practice.</p>
<div style="text-align:center"><img src="img/scalable_lists_concept.png"/></div>
<p>100 000 elements is something <code>ListBox</code> will struggle with, so let us use this to demonstrate scalable lists.</p>
<p>We start by defining and filling up our model.
The model is an instance of <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
The main limitation here is that <code>gio::ListStore</code> only accepts GObjects.
What we would need is a GObject which holds an integer and exposes it as property.
To get that we just have to adapt the <code>CustomButton</code> we created in the subclassing <a href="gobject_subclassing.html">chapter</a>.
We only need to let it inherit from GObject instead of <code>Button</code> and let the <code>new</code> method accept an integer as parameter.</p>
<p><span class="filename">Filename: listings/lists/2/integer_object/mod.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
}

impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::new(&amp;[(&quot;number&quot;, &amp;number)]).expect(&quot;Could not create `IntegerObject`.&quot;)
    }
}
<span class="boring">
</span><span class="boring">// Please ignore this line
</span><span class="boring">// It is only there to make mdbook happy
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We now fill the model with integers from 0 to 100 000.
Please note that the models only takes care of the data.
Neither <code>Label</code> nor any other widget is mentioned here.</p>
<p><span class="filename">Filename: listings/lists/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let model = gio::ListStore::new(IntegerObject::static_type());
    for number in 0..=100_000 {
        let integer_object = IntegerObject::new(number);
        model.append(&amp;integer_object);
    }
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>ListItemFactory</code> takes care of the widgets as well as their relationship to the model.
Here, we use the <a href="../docs/gtk4/struct.SignalListItemFactory.html"><code>SignalListItemFactory</code></a> which emits a signal for every relevant step in the life of a <a href="../docs/gtk4/struct.ListItem.html"><code>ListItem</code></a>.
The &quot;setup&quot; signal will be emitted when new widgets have to be created.
We connect to it to create a <code>Label</code> for every requested widget.</p>
<p><span class="filename">Filename: listings/lists/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span>    let factory = SignalListItemFactory::new();
    factory.connect_setup(move |_, list_item| {
        let label = Label::new(None);
        list_item.set_child(Some(&amp;label));
    });
<span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>In the &quot;bind&quot; step we bind the data in our model to the individual list items.</p>
<p><span class="filename">Filename: listings/lists/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .item()
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Get `i32` from `IntegerObject`
        let number = integer_object
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);

        // Get `Label` from `ListItem`
        let label = list_item
            .child()
            .expect(&quot;The child has to exist.&quot;)
            .downcast::&lt;Label&gt;()
            .expect(&quot;The child has to be a `Label`.&quot;);

        // Set &quot;label&quot; to &quot;number&quot;
        label.set_label(&amp;number.to_string());
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>We only want single items to be selectable, so we choose <a href="../docs/gtk4/struct.SingleSelection.html"><code>SingleSelection</code></a>.
The other options would have been <a href="../docs/gtk4/struct.MultiSelection.html"><code>MultiSelection</code></a> or <a href="../docs/gtk4/struct.NoSelection.html"><code>NoSelection</code></a>.
Then we pass the model and the factory to the <a href="../docs/gtk4/struct.ListView.html"><code>ListView</code></a>.</p>
<p><span class="filename">Filename: listings/lists/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span>    let selection_model = SingleSelection::new(Some(&amp;model));
    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>Every <code>ListView</code> has to be a direct child of a <code>ScrolledWindow</code>, so we are adding it to one.</p>
<p><span class="filename">Filename: listings/lists/2/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `i32` from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Set &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        label.set_label(&amp;number.to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_view)
        .build();
    window.set_child(Some(&amp;scrolled_window));
    window.show();
<span class="boring">}
</span></code></pre></pre>
<p>We can now easily scroll through our long list of integers.</p>
<div style="text-align:center"><img src="img/lists_list_view_1.png"/></div>
<p>Let us see what else we can do.
We might want to increase the number every time we activate its row.
For that we first add the method <code>increase_number</code> to our <code>IntegerObject</code>.</p>
<p><span class="filename">Filename: listings/lists/3/integer_object/mod.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::new(&amp;[(&quot;number&quot;, &amp;number)]).expect(&quot;Could not create `IntegerObject`.&quot;)
    }

    pub fn increase_number(self) {
        let old_number = self
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);

        self.set_property(&quot;number&quot;, old_number + 1)
            .expect(&quot;Could not set property.&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In order to interact with our <code>ListView</code>, we connect to its &quot;activate&quot; signal.</p>
<p><span class="filename">Filename: listings/lists/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .item()
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .child()
</span><span class="boring">            .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;Label&gt;()
</span><span class="boring">            .expect(&quot;The child has to be a `Label`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Bind &quot;label&quot; to &quot;number&quot;
</span><span class="boring">        integer_object
</span><span class="boring">            .bind_property(&quot;number&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
        let integer_object = model
            .item(position)
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Increase &quot;number&quot; of `IntegerObject`
        integer_object.increase_number();
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>Now every time we activate an element, for example by double-clicking on it,
the corresponding &quot;number&quot; property of the <code>IntegerObject</code> in the model will be increased by 1.
However, just because the <code>IntegerObject</code> has been modified the corresponding <code>Label</code> does not immediately change.
One naive approach would be to bind the properties in the &quot;bind&quot; step of the <code>SignalListItemFactory</code>.</p>
<p><span class="filename">Filename: listings/lists/3/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use glib::BindingFlags;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .item()
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Get `Label` from `ListItem`
        let label = list_item
            .child()
            .expect(&quot;The child has to exist.&quot;)
            .downcast::&lt;Label&gt;()
            .expect(&quot;The child has to be a `Label`.&quot;);

        // Bind &quot;label&quot; to &quot;number&quot;
        integer_object
            .bind_property(&quot;number&quot;, &amp;label, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>At first glance, that seems to work.
However, as you scroll around and activate a few list elements,
you will notice that sometimes multiple numbers change even though you only activated a single one.
This relates to how the view works internally.
Not every model item belongs to a single widget, but the widgets get recycled instead as you scroll through the view.
That also means that in our case, multiple numbers will be bound to the same widget.</p>
<p>Situations like these are so common that GTK offers an alternative to property binding: <a href="../docs/gtk4/struct.Expression.html">expressions</a>.
As a first step it allows us to remove the &quot;bind&quot; step.
Let us see how the &quot;setup&quot; step now works.</p>
<p><span class="filename">Filename: listings/lists/4/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, ConstantExpression, Label, ListView, PolicyType,
</span><span class="boring">    PropertyExpression, ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        list_item.set_child(Some(&amp;label));

        // Create expression describing `list_item-&gt;item-&gt;number`
        let list_item_expression = ConstantExpression::new(list_item);
        let integer_object_expression = PropertyExpression::new(
            gtk::ListItem::static_type(),
            Some(&amp;list_item_expression),
            &quot;item&quot;,
        );
        let number_expression = PropertyExpression::new(
            IntegerObject::static_type(),
            Some(&amp;integer_object_expression),
            &quot;number&quot;,
        );

        // Bind &quot;number&quot; to &quot;label&quot;
        number_expression.bind(&amp;label, &quot;label&quot;, Some(&amp;label));
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>An expression describes a reference to a value.
So when we create a <a href="../docs/gtk4/struct.ConstantExpression.html"><code>ConstantExpression</code></a> of <code>list_item</code>, we create a reference to a <code>ListItem</code>.
We then create a <a href="../docs/gtk4/struct.PropertyExpression.html"><code>PropertyExpression</code></a> to get a reference to the &quot;item&quot; property of <code>list_item</code>.
With another <code>PropertyExpression</code> we get a reference to the &quot;number&quot; property of the &quot;item&quot; property of <code>list_item</code>.
That already makes the first power of expressions obvious: It allows nested relationships.
Finally, we bind &quot;number&quot; to &quot;label&quot;.
In pseudo code that would be <code>label-&gt;label = list_item-&gt;item-&gt;number</code>.</p>
<p>It is worth noting that at the &quot;setup&quot; stage there is no way of knowing which list item belongs to which label, simply because this changes as we scroll through the list.
This is the power of expressions!
We do not have to define a fixed relationship, the object and properties might not even exist yet.
We just had to tell it to change the label whenever the number that belongs to it changes.
That way, we also do not face the problem that multiple labels are bound to the same number.
When we now activate a label, only the corresponding number visibly changes.</p>
<p>That is still not everything we can do.
We can, for example, filter our model to only allow even numbers.</p>
<p><span class="filename">Filename: listings/lists/5/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, ConstantExpression, CustomSorter, FilterChange, Label,
</span><span class="boring">    ListView, PolicyType, PropertyExpression, ScrolledWindow, SignalListItemFactory,
</span><span class="boring">    SingleSelection, SortListModel, SorterChange,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Create expression describing `list_item-&gt;item-&gt;number`
</span><span class="boring">        let list_item_expression = ConstantExpression::new(list_item);
</span><span class="boring">        let integer_object_expression = PropertyExpression::new(
</span><span class="boring">            gtk::ListItem::static_type(),
</span><span class="boring">            Some(&amp;list_item_expression),
</span><span class="boring">            &quot;item&quot;,
</span><span class="boring">        );
</span><span class="boring">        let number_expression = PropertyExpression::new(
</span><span class="boring">            IntegerObject::static_type(),
</span><span class="boring">            Some(&amp;integer_object_expression),
</span><span class="boring">            &quot;number&quot;,
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Bind &quot;number&quot; to &quot;label&quot;
</span><span class="boring">        number_expression.bind(&amp;label, &quot;label&quot;, Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    let filter = gtk::CustomFilter::new(move |obj| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object = obj
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);

        // Get property &quot;number&quot; from `IntegerObject`
        let number = integer_object
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);

        // Only allow even numbers
        number % 2 == 0
    });
    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
<span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">        let number_2 = integer_object_2
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter has been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>Additionally, we can reverse the order of our model.</p>
<p><span class="filename">Filename: listings/lists/5/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, ConstantExpression, CustomSorter, FilterChange, Label,
</span><span class="boring">    ListView, PolicyType, PropertyExpression, ScrolledWindow, SignalListItemFactory,
</span><span class="boring">    SingleSelection, SortListModel, SorterChange,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Create expression describing `list_item-&gt;item-&gt;number`
</span><span class="boring">        let list_item_expression = ConstantExpression::new(list_item);
</span><span class="boring">        let integer_object_expression = PropertyExpression::new(
</span><span class="boring">            gtk::ListItem::static_type(),
</span><span class="boring">            Some(&amp;list_item_expression),
</span><span class="boring">            &quot;item&quot;,
</span><span class="boring">        );
</span><span class="boring">        let number_expression = PropertyExpression::new(
</span><span class="boring">            IntegerObject::static_type(),
</span><span class="boring">            Some(&amp;integer_object_expression),
</span><span class="boring">            &quot;number&quot;,
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Bind &quot;number&quot; to &quot;label&quot;
</span><span class="boring">        number_expression.bind(&amp;label, &quot;label&quot;, Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = gtk::CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        number % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
</span><span class="boring">
</span>    let sorter = CustomSorter::new(move |obj1, obj2| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object_1 = obj1
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
        let integer_object_2 = obj2
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);

        // Get property &quot;number&quot; from `IntegerObject`
        let number_1 = integer_object_1
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);
        let number_2 = integer_object_2
            .property(&quot;number&quot;)
            .expect(&quot;The property needs to exist and be readable.&quot;)
            .get::&lt;i32&gt;()
            .expect(&quot;The property needs to be of type `i32`.&quot;);

        // Reverse sorting order -&gt; large numbers come first
        number_2.cmp(&amp;number_1).into()
    });
    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">            .downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The item has to be an `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Increase &quot;number&quot; of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter has been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>To ensure that our filter and sorter get updated when we modify the numbers, we call the <code>changed</code> method on them.</p>
<p><span class="filename">Filename: listings/lists/5/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::gio;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, ConstantExpression, CustomSorter, FilterChange, Label,
</span><span class="boring">    ListView, PolicyType, PropertyExpression, ScrolledWindow, SignalListItemFactory,
</span><span class="boring">    SingleSelection, SortListModel, SorterChange,
</span><span class="boring">};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::new(Some(&quot;org.gtk.example&quot;), Default::default());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title(&quot;My GTK App&quot;)
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let model = gio::ListStore::new(IntegerObject::static_type());
</span><span class="boring">    for number in 0..=100_000 {
</span><span class="boring">        let integer_object = IntegerObject::new(number);
</span><span class="boring">        model.append(&amp;integer_object);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Create expression describing `list_item-&gt;item-&gt;number`
</span><span class="boring">        let list_item_expression = ConstantExpression::new(list_item);
</span><span class="boring">        let integer_object_expression = PropertyExpression::new(
</span><span class="boring">            gtk::ListItem::static_type(),
</span><span class="boring">            Some(&amp;list_item_expression),
</span><span class="boring">            &quot;item&quot;,
</span><span class="boring">        );
</span><span class="boring">        let number_expression = PropertyExpression::new(
</span><span class="boring">            IntegerObject::static_type(),
</span><span class="boring">            Some(&amp;integer_object_expression),
</span><span class="boring">            &quot;number&quot;,
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Bind &quot;number&quot; to &quot;label&quot;
</span><span class="boring">        number_expression.bind(&amp;label, &quot;label&quot;, Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = gtk::CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number = integer_object
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        number % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = gtk::FilterListModel::new(Some(&amp;model), Some(&amp;filter));
</span><span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect(&quot;The object needs to be of type `IntegerObject`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Get property &quot;number&quot; from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">        let number_2 = integer_object_2
</span><span class="boring">            .property(&quot;number&quot;)
</span><span class="boring">            .expect(&quot;The property needs to exist and be readable.&quot;)
</span><span class="boring">            .get::&lt;i32&gt;()
</span><span class="boring">            .expect(&quot;The property needs to be of type `i32`.&quot;);
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(&amp;filter_model), Some(&amp;sorter));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(&amp;sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(&amp;selection_model), Some(&amp;factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect(&quot;The model has to exist.&quot;);
        let integer_object = model
            .item(position)
            .expect(&quot;The item has to exist.&quot;)
            .downcast::&lt;IntegerObject&gt;()
            .expect(&quot;The item has to be an `IntegerObject`.&quot;);

        // Increase &quot;number&quot; of `IntegerObject`
        integer_object.increase_number();

        // Notify that the filter and sorter has been changed
        filter.changed(FilterChange::Different);
        sorter.changed(SorterChange::Different);
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">    window.set_child(Some(&amp;scrolled_window));
</span><span class="boring">    window.show();
</span><span class="boring">}
</span></code></pre></pre>
<p>After our changes, the application looks like this:</p>
<div style="text-align:center"><img src="img/lists_list_view_2.png"/></div>
<p>We now know how to display a list of data.
Small amount of elements can be handled by <code>ListBox</code> or <code>FlowBox</code>.
These widgets are easy to use and allow, if necessary, to be bound to a model such as <a href="http://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a>.
Their data can then be modified, sorted and filtered more easily.
However, if we need the widgets to be scalable we still need to use <a href="../docs/gtk4/struct.ListView.html"><code>ListView</code></a>, <a href="../docs/gtk4/struct.ColumnView.html"><code>ColumnView</code></a> or <a href="../docs/gtk4/struct.GridView.html"><code>GridView</code></a> instead.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
