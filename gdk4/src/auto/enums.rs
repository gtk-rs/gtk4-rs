// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ffi;
use glib::error::ErrorDomain;
use glib::gobject_ffi;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AxisUse {
    Ignore,
    X,
    Y,
    DeltaX,
    DeltaY,
    Pressure,
    Xtilt,
    Ytilt,
    Wheel,
    Distance,
    Rotation,
    Slider,
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AxisUse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AxisUse::{}",
            match *self {
                AxisUse::Ignore => "Ignore",
                AxisUse::X => "X",
                AxisUse::Y => "Y",
                AxisUse::DeltaX => "DeltaX",
                AxisUse::DeltaY => "DeltaY",
                AxisUse::Pressure => "Pressure",
                AxisUse::Xtilt => "Xtilt",
                AxisUse::Ytilt => "Ytilt",
                AxisUse::Wheel => "Wheel",
                AxisUse::Distance => "Distance",
                AxisUse::Rotation => "Rotation",
                AxisUse::Slider => "Slider",
                AxisUse::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AxisUse {
    type GlibType = ffi::GdkAxisUse;

    fn to_glib(&self) -> ffi::GdkAxisUse {
        match *self {
            AxisUse::Ignore => ffi::GDK_AXIS_IGNORE,
            AxisUse::X => ffi::GDK_AXIS_X,
            AxisUse::Y => ffi::GDK_AXIS_Y,
            AxisUse::DeltaX => ffi::GDK_AXIS_DELTA_X,
            AxisUse::DeltaY => ffi::GDK_AXIS_DELTA_Y,
            AxisUse::Pressure => ffi::GDK_AXIS_PRESSURE,
            AxisUse::Xtilt => ffi::GDK_AXIS_XTILT,
            AxisUse::Ytilt => ffi::GDK_AXIS_YTILT,
            AxisUse::Wheel => ffi::GDK_AXIS_WHEEL,
            AxisUse::Distance => ffi::GDK_AXIS_DISTANCE,
            AxisUse::Rotation => ffi::GDK_AXIS_ROTATION,
            AxisUse::Slider => ffi::GDK_AXIS_SLIDER,
            AxisUse::Last => ffi::GDK_AXIS_LAST,
            AxisUse::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkAxisUse> for AxisUse {
    fn from_glib(value: ffi::GdkAxisUse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AxisUse::Ignore,
            1 => AxisUse::X,
            2 => AxisUse::Y,
            3 => AxisUse::DeltaX,
            4 => AxisUse::DeltaY,
            5 => AxisUse::Pressure,
            6 => AxisUse::Xtilt,
            7 => AxisUse::Ytilt,
            8 => AxisUse::Wheel,
            9 => AxisUse::Distance,
            10 => AxisUse::Rotation,
            11 => AxisUse::Slider,
            12 => AxisUse::Last,
            value => AxisUse::__Unknown(value),
        }
    }
}

impl StaticType for AxisUse {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_axis_use_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AxisUse {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AxisUse {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AxisUse {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CrossingMode {
    Normal,
    Grab,
    Ungrab,
    GtkGrab,
    GtkUngrab,
    StateChanged,
    TouchBegin,
    TouchEnd,
    DeviceSwitch,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CrossingMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CrossingMode::{}",
            match *self {
                CrossingMode::Normal => "Normal",
                CrossingMode::Grab => "Grab",
                CrossingMode::Ungrab => "Ungrab",
                CrossingMode::GtkGrab => "GtkGrab",
                CrossingMode::GtkUngrab => "GtkUngrab",
                CrossingMode::StateChanged => "StateChanged",
                CrossingMode::TouchBegin => "TouchBegin",
                CrossingMode::TouchEnd => "TouchEnd",
                CrossingMode::DeviceSwitch => "DeviceSwitch",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CrossingMode {
    type GlibType = ffi::GdkCrossingMode;

    fn to_glib(&self) -> ffi::GdkCrossingMode {
        match *self {
            CrossingMode::Normal => ffi::GDK_CROSSING_NORMAL,
            CrossingMode::Grab => ffi::GDK_CROSSING_GRAB,
            CrossingMode::Ungrab => ffi::GDK_CROSSING_UNGRAB,
            CrossingMode::GtkGrab => ffi::GDK_CROSSING_GTK_GRAB,
            CrossingMode::GtkUngrab => ffi::GDK_CROSSING_GTK_UNGRAB,
            CrossingMode::StateChanged => ffi::GDK_CROSSING_STATE_CHANGED,
            CrossingMode::TouchBegin => ffi::GDK_CROSSING_TOUCH_BEGIN,
            CrossingMode::TouchEnd => ffi::GDK_CROSSING_TOUCH_END,
            CrossingMode::DeviceSwitch => ffi::GDK_CROSSING_DEVICE_SWITCH,
            CrossingMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkCrossingMode> for CrossingMode {
    fn from_glib(value: ffi::GdkCrossingMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CrossingMode::Normal,
            1 => CrossingMode::Grab,
            2 => CrossingMode::Ungrab,
            3 => CrossingMode::GtkGrab,
            4 => CrossingMode::GtkUngrab,
            5 => CrossingMode::StateChanged,
            6 => CrossingMode::TouchBegin,
            7 => CrossingMode::TouchEnd,
            8 => CrossingMode::DeviceSwitch,
            value => CrossingMode::__Unknown(value),
        }
    }
}

impl StaticType for CrossingMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_crossing_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CrossingMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CrossingMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CrossingMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DevicePadFeature {
    Button,
    Ring,
    Strip,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DevicePadFeature {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DevicePadFeature::{}",
            match *self {
                DevicePadFeature::Button => "Button",
                DevicePadFeature::Ring => "Ring",
                DevicePadFeature::Strip => "Strip",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DevicePadFeature {
    type GlibType = ffi::GdkDevicePadFeature;

    fn to_glib(&self) -> ffi::GdkDevicePadFeature {
        match *self {
            DevicePadFeature::Button => ffi::GDK_DEVICE_PAD_FEATURE_BUTTON,
            DevicePadFeature::Ring => ffi::GDK_DEVICE_PAD_FEATURE_RING,
            DevicePadFeature::Strip => ffi::GDK_DEVICE_PAD_FEATURE_STRIP,
            DevicePadFeature::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDevicePadFeature> for DevicePadFeature {
    fn from_glib(value: ffi::GdkDevicePadFeature) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DevicePadFeature::Button,
            1 => DevicePadFeature::Ring,
            2 => DevicePadFeature::Strip,
            value => DevicePadFeature::__Unknown(value),
        }
    }
}

impl StaticType for DevicePadFeature {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_device_pad_feature_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DevicePadFeature {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DevicePadFeature {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DevicePadFeature {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceToolType {
    Unknown,
    Pen,
    Eraser,
    Brush,
    Pencil,
    Airbrush,
    Mouse,
    Lens,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceToolType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceToolType::{}",
            match *self {
                DeviceToolType::Unknown => "Unknown",
                DeviceToolType::Pen => "Pen",
                DeviceToolType::Eraser => "Eraser",
                DeviceToolType::Brush => "Brush",
                DeviceToolType::Pencil => "Pencil",
                DeviceToolType::Airbrush => "Airbrush",
                DeviceToolType::Mouse => "Mouse",
                DeviceToolType::Lens => "Lens",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeviceToolType {
    type GlibType = ffi::GdkDeviceToolType;

    fn to_glib(&self) -> ffi::GdkDeviceToolType {
        match *self {
            DeviceToolType::Unknown => ffi::GDK_DEVICE_TOOL_TYPE_UNKNOWN,
            DeviceToolType::Pen => ffi::GDK_DEVICE_TOOL_TYPE_PEN,
            DeviceToolType::Eraser => ffi::GDK_DEVICE_TOOL_TYPE_ERASER,
            DeviceToolType::Brush => ffi::GDK_DEVICE_TOOL_TYPE_BRUSH,
            DeviceToolType::Pencil => ffi::GDK_DEVICE_TOOL_TYPE_PENCIL,
            DeviceToolType::Airbrush => ffi::GDK_DEVICE_TOOL_TYPE_AIRBRUSH,
            DeviceToolType::Mouse => ffi::GDK_DEVICE_TOOL_TYPE_MOUSE,
            DeviceToolType::Lens => ffi::GDK_DEVICE_TOOL_TYPE_LENS,
            DeviceToolType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDeviceToolType> for DeviceToolType {
    fn from_glib(value: ffi::GdkDeviceToolType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DeviceToolType::Unknown,
            1 => DeviceToolType::Pen,
            2 => DeviceToolType::Eraser,
            3 => DeviceToolType::Brush,
            4 => DeviceToolType::Pencil,
            5 => DeviceToolType::Airbrush,
            6 => DeviceToolType::Mouse,
            7 => DeviceToolType::Lens,
            value => DeviceToolType::__Unknown(value),
        }
    }
}

impl StaticType for DeviceToolType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_device_tool_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceToolType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceToolType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceToolType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DragCancelReason {
    NoTarget,
    UserCancelled,
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DragCancelReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DragCancelReason::{}",
            match *self {
                DragCancelReason::NoTarget => "NoTarget",
                DragCancelReason::UserCancelled => "UserCancelled",
                DragCancelReason::Error => "Error",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DragCancelReason {
    type GlibType = ffi::GdkDragCancelReason;

    fn to_glib(&self) -> ffi::GdkDragCancelReason {
        match *self {
            DragCancelReason::NoTarget => ffi::GDK_DRAG_CANCEL_NO_TARGET,
            DragCancelReason::UserCancelled => ffi::GDK_DRAG_CANCEL_USER_CANCELLED,
            DragCancelReason::Error => ffi::GDK_DRAG_CANCEL_ERROR,
            DragCancelReason::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDragCancelReason> for DragCancelReason {
    fn from_glib(value: ffi::GdkDragCancelReason) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DragCancelReason::NoTarget,
            1 => DragCancelReason::UserCancelled,
            2 => DragCancelReason::Error,
            value => DragCancelReason::__Unknown(value),
        }
    }
}

impl StaticType for DragCancelReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_drag_cancel_reason_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DragCancelReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DragCancelReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DragCancelReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EventType {
    Delete,
    MotionNotify,
    ButtonPress,
    ButtonRelease,
    KeyPress,
    KeyRelease,
    EnterNotify,
    LeaveNotify,
    FocusChange,
    Configure,
    ProximityIn,
    ProximityOut,
    DragEnter,
    DragLeave,
    DragMotion,
    DropStart,
    Scroll,
    GrabBroken,
    TouchBegin,
    TouchUpdate,
    TouchEnd,
    TouchCancel,
    TouchpadSwipe,
    TouchpadPinch,
    PadButtonPress,
    PadButtonRelease,
    PadRing,
    PadStrip,
    PadGroupMode,
    EventLast,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EventType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EventType::{}",
            match *self {
                EventType::Delete => "Delete",
                EventType::MotionNotify => "MotionNotify",
                EventType::ButtonPress => "ButtonPress",
                EventType::ButtonRelease => "ButtonRelease",
                EventType::KeyPress => "KeyPress",
                EventType::KeyRelease => "KeyRelease",
                EventType::EnterNotify => "EnterNotify",
                EventType::LeaveNotify => "LeaveNotify",
                EventType::FocusChange => "FocusChange",
                EventType::Configure => "Configure",
                EventType::ProximityIn => "ProximityIn",
                EventType::ProximityOut => "ProximityOut",
                EventType::DragEnter => "DragEnter",
                EventType::DragLeave => "DragLeave",
                EventType::DragMotion => "DragMotion",
                EventType::DropStart => "DropStart",
                EventType::Scroll => "Scroll",
                EventType::GrabBroken => "GrabBroken",
                EventType::TouchBegin => "TouchBegin",
                EventType::TouchUpdate => "TouchUpdate",
                EventType::TouchEnd => "TouchEnd",
                EventType::TouchCancel => "TouchCancel",
                EventType::TouchpadSwipe => "TouchpadSwipe",
                EventType::TouchpadPinch => "TouchpadPinch",
                EventType::PadButtonPress => "PadButtonPress",
                EventType::PadButtonRelease => "PadButtonRelease",
                EventType::PadRing => "PadRing",
                EventType::PadStrip => "PadStrip",
                EventType::PadGroupMode => "PadGroupMode",
                EventType::EventLast => "EventLast",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EventType {
    type GlibType = ffi::GdkEventType;

    fn to_glib(&self) -> ffi::GdkEventType {
        match *self {
            EventType::Delete => ffi::GDK_DELETE,
            EventType::MotionNotify => ffi::GDK_MOTION_NOTIFY,
            EventType::ButtonPress => ffi::GDK_BUTTON_PRESS,
            EventType::ButtonRelease => ffi::GDK_BUTTON_RELEASE,
            EventType::KeyPress => ffi::GDK_KEY_PRESS,
            EventType::KeyRelease => ffi::GDK_KEY_RELEASE,
            EventType::EnterNotify => ffi::GDK_ENTER_NOTIFY,
            EventType::LeaveNotify => ffi::GDK_LEAVE_NOTIFY,
            EventType::FocusChange => ffi::GDK_FOCUS_CHANGE,
            EventType::Configure => ffi::GDK_CONFIGURE,
            EventType::ProximityIn => ffi::GDK_PROXIMITY_IN,
            EventType::ProximityOut => ffi::GDK_PROXIMITY_OUT,
            EventType::DragEnter => ffi::GDK_DRAG_ENTER,
            EventType::DragLeave => ffi::GDK_DRAG_LEAVE,
            EventType::DragMotion => ffi::GDK_DRAG_MOTION,
            EventType::DropStart => ffi::GDK_DROP_START,
            EventType::Scroll => ffi::GDK_SCROLL,
            EventType::GrabBroken => ffi::GDK_GRAB_BROKEN,
            EventType::TouchBegin => ffi::GDK_TOUCH_BEGIN,
            EventType::TouchUpdate => ffi::GDK_TOUCH_UPDATE,
            EventType::TouchEnd => ffi::GDK_TOUCH_END,
            EventType::TouchCancel => ffi::GDK_TOUCH_CANCEL,
            EventType::TouchpadSwipe => ffi::GDK_TOUCHPAD_SWIPE,
            EventType::TouchpadPinch => ffi::GDK_TOUCHPAD_PINCH,
            EventType::PadButtonPress => ffi::GDK_PAD_BUTTON_PRESS,
            EventType::PadButtonRelease => ffi::GDK_PAD_BUTTON_RELEASE,
            EventType::PadRing => ffi::GDK_PAD_RING,
            EventType::PadStrip => ffi::GDK_PAD_STRIP,
            EventType::PadGroupMode => ffi::GDK_PAD_GROUP_MODE,
            EventType::EventLast => ffi::GDK_EVENT_LAST,
            EventType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkEventType> for EventType {
    fn from_glib(value: ffi::GdkEventType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EventType::Delete,
            1 => EventType::MotionNotify,
            2 => EventType::ButtonPress,
            3 => EventType::ButtonRelease,
            4 => EventType::KeyPress,
            5 => EventType::KeyRelease,
            6 => EventType::EnterNotify,
            7 => EventType::LeaveNotify,
            8 => EventType::FocusChange,
            9 => EventType::Configure,
            10 => EventType::ProximityIn,
            11 => EventType::ProximityOut,
            12 => EventType::DragEnter,
            13 => EventType::DragLeave,
            14 => EventType::DragMotion,
            15 => EventType::DropStart,
            16 => EventType::Scroll,
            17 => EventType::GrabBroken,
            18 => EventType::TouchBegin,
            19 => EventType::TouchUpdate,
            20 => EventType::TouchEnd,
            21 => EventType::TouchCancel,
            22 => EventType::TouchpadSwipe,
            23 => EventType::TouchpadPinch,
            24 => EventType::PadButtonPress,
            25 => EventType::PadButtonRelease,
            26 => EventType::PadRing,
            27 => EventType::PadStrip,
            28 => EventType::PadGroupMode,
            29 => EventType::EventLast,
            value => EventType::__Unknown(value),
        }
    }
}

impl StaticType for EventType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_event_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EventType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EventType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EventType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FullscreenMode {
    CurrentMonitor,
    AllMonitors,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FullscreenMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FullscreenMode::{}",
            match *self {
                FullscreenMode::CurrentMonitor => "CurrentMonitor",
                FullscreenMode::AllMonitors => "AllMonitors",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FullscreenMode {
    type GlibType = ffi::GdkFullscreenMode;

    fn to_glib(&self) -> ffi::GdkFullscreenMode {
        match *self {
            FullscreenMode::CurrentMonitor => ffi::GDK_FULLSCREEN_ON_CURRENT_MONITOR,
            FullscreenMode::AllMonitors => ffi::GDK_FULLSCREEN_ON_ALL_MONITORS,
            FullscreenMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkFullscreenMode> for FullscreenMode {
    fn from_glib(value: ffi::GdkFullscreenMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FullscreenMode::CurrentMonitor,
            1 => FullscreenMode::AllMonitors,
            value => FullscreenMode::__Unknown(value),
        }
    }
}

impl StaticType for FullscreenMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_fullscreen_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FullscreenMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FullscreenMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FullscreenMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLError {
    NotAvailable,
    UnsupportedFormat,
    UnsupportedProfile,
    CompilationFailed,
    LinkFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for GLError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "GLError::{}",
            match *self {
                GLError::NotAvailable => "NotAvailable",
                GLError::UnsupportedFormat => "UnsupportedFormat",
                GLError::UnsupportedProfile => "UnsupportedProfile",
                GLError::CompilationFailed => "CompilationFailed",
                GLError::LinkFailed => "LinkFailed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for GLError {
    type GlibType = ffi::GdkGLError;

    fn to_glib(&self) -> ffi::GdkGLError {
        match *self {
            GLError::NotAvailable => ffi::GDK_GL_ERROR_NOT_AVAILABLE,
            GLError::UnsupportedFormat => ffi::GDK_GL_ERROR_UNSUPPORTED_FORMAT,
            GLError::UnsupportedProfile => ffi::GDK_GL_ERROR_UNSUPPORTED_PROFILE,
            GLError::CompilationFailed => ffi::GDK_GL_ERROR_COMPILATION_FAILED,
            GLError::LinkFailed => ffi::GDK_GL_ERROR_LINK_FAILED,
            GLError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkGLError> for GLError {
    fn from_glib(value: ffi::GdkGLError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLError::NotAvailable,
            1 => GLError::UnsupportedFormat,
            2 => GLError::UnsupportedProfile,
            3 => GLError::CompilationFailed,
            4 => GLError::LinkFailed,
            value => GLError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gdk_gl_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLError::NotAvailable),
            1 => Some(GLError::UnsupportedFormat),
            2 => Some(GLError::UnsupportedProfile),
            3 => Some(GLError::CompilationFailed),
            4 => Some(GLError::LinkFailed),
            value => Some(GLError::__Unknown(value)),
        }
    }
}

impl StaticType for GLError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_gl_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Gravity {
    NorthWest,
    North,
    NorthEast,
    West,
    Center,
    East,
    SouthWest,
    South,
    SouthEast,
    Static,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Gravity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Gravity::{}",
            match *self {
                Gravity::NorthWest => "NorthWest",
                Gravity::North => "North",
                Gravity::NorthEast => "NorthEast",
                Gravity::West => "West",
                Gravity::Center => "Center",
                Gravity::East => "East",
                Gravity::SouthWest => "SouthWest",
                Gravity::South => "South",
                Gravity::SouthEast => "SouthEast",
                Gravity::Static => "Static",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Gravity {
    type GlibType = ffi::GdkGravity;

    fn to_glib(&self) -> ffi::GdkGravity {
        match *self {
            Gravity::NorthWest => ffi::GDK_GRAVITY_NORTH_WEST,
            Gravity::North => ffi::GDK_GRAVITY_NORTH,
            Gravity::NorthEast => ffi::GDK_GRAVITY_NORTH_EAST,
            Gravity::West => ffi::GDK_GRAVITY_WEST,
            Gravity::Center => ffi::GDK_GRAVITY_CENTER,
            Gravity::East => ffi::GDK_GRAVITY_EAST,
            Gravity::SouthWest => ffi::GDK_GRAVITY_SOUTH_WEST,
            Gravity::South => ffi::GDK_GRAVITY_SOUTH,
            Gravity::SouthEast => ffi::GDK_GRAVITY_SOUTH_EAST,
            Gravity::Static => ffi::GDK_GRAVITY_STATIC,
            Gravity::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkGravity> for Gravity {
    fn from_glib(value: ffi::GdkGravity) -> Self {
        skip_assert_initialized!();
        match value {
            1 => Gravity::NorthWest,
            2 => Gravity::North,
            3 => Gravity::NorthEast,
            4 => Gravity::West,
            5 => Gravity::Center,
            6 => Gravity::East,
            7 => Gravity::SouthWest,
            8 => Gravity::South,
            9 => Gravity::SouthEast,
            10 => Gravity::Static,
            value => Gravity::__Unknown(value),
        }
    }
}

impl StaticType for Gravity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_gravity_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Gravity {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Gravity {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Gravity {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum InputSource {
    Mouse,
    Pen,
    Keyboard,
    Touchscreen,
    Touchpad,
    Trackpoint,
    TabletPad,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputSource {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputSource::{}",
            match *self {
                InputSource::Mouse => "Mouse",
                InputSource::Pen => "Pen",
                InputSource::Keyboard => "Keyboard",
                InputSource::Touchscreen => "Touchscreen",
                InputSource::Touchpad => "Touchpad",
                InputSource::Trackpoint => "Trackpoint",
                InputSource::TabletPad => "TabletPad",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputSource {
    type GlibType = ffi::GdkInputSource;

    fn to_glib(&self) -> ffi::GdkInputSource {
        match *self {
            InputSource::Mouse => ffi::GDK_SOURCE_MOUSE,
            InputSource::Pen => ffi::GDK_SOURCE_PEN,
            InputSource::Keyboard => ffi::GDK_SOURCE_KEYBOARD,
            InputSource::Touchscreen => ffi::GDK_SOURCE_TOUCHSCREEN,
            InputSource::Touchpad => ffi::GDK_SOURCE_TOUCHPAD,
            InputSource::Trackpoint => ffi::GDK_SOURCE_TRACKPOINT,
            InputSource::TabletPad => ffi::GDK_SOURCE_TABLET_PAD,
            InputSource::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkInputSource> for InputSource {
    fn from_glib(value: ffi::GdkInputSource) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputSource::Mouse,
            1 => InputSource::Pen,
            2 => InputSource::Keyboard,
            3 => InputSource::Touchscreen,
            4 => InputSource::Touchpad,
            5 => InputSource::Trackpoint,
            6 => InputSource::TabletPad,
            value => InputSource::__Unknown(value),
        }
    }
}

impl StaticType for InputSource {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_input_source_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputSource {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputSource {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputSource {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum KeyMatch {
    None,
    Partial,
    Exact,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for KeyMatch {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "KeyMatch::{}",
            match *self {
                KeyMatch::None => "None",
                KeyMatch::Partial => "Partial",
                KeyMatch::Exact => "Exact",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for KeyMatch {
    type GlibType = ffi::GdkKeyMatch;

    fn to_glib(&self) -> ffi::GdkKeyMatch {
        match *self {
            KeyMatch::None => ffi::GDK_KEY_MATCH_NONE,
            KeyMatch::Partial => ffi::GDK_KEY_MATCH_PARTIAL,
            KeyMatch::Exact => ffi::GDK_KEY_MATCH_EXACT,
            KeyMatch::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkKeyMatch> for KeyMatch {
    fn from_glib(value: ffi::GdkKeyMatch) -> Self {
        skip_assert_initialized!();
        match value {
            0 => KeyMatch::None,
            1 => KeyMatch::Partial,
            2 => KeyMatch::Exact,
            value => KeyMatch::__Unknown(value),
        }
    }
}

impl StaticType for KeyMatch {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_key_match_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for KeyMatch {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for KeyMatch {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for KeyMatch {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MemoryFormat {
    B8g8r8a8Premultiplied,
    A8r8g8b8Premultiplied,
    R8g8b8a8Premultiplied,
    B8g8r8a8,
    A8r8g8b8,
    R8g8b8a8,
    A8b8g8r8,
    R8g8b8,
    B8g8r8,
    NFormats,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MemoryFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MemoryFormat::{}",
            match *self {
                MemoryFormat::B8g8r8a8Premultiplied => "B8g8r8a8Premultiplied",
                MemoryFormat::A8r8g8b8Premultiplied => "A8r8g8b8Premultiplied",
                MemoryFormat::R8g8b8a8Premultiplied => "R8g8b8a8Premultiplied",
                MemoryFormat::B8g8r8a8 => "B8g8r8a8",
                MemoryFormat::A8r8g8b8 => "A8r8g8b8",
                MemoryFormat::R8g8b8a8 => "R8g8b8a8",
                MemoryFormat::A8b8g8r8 => "A8b8g8r8",
                MemoryFormat::R8g8b8 => "R8g8b8",
                MemoryFormat::B8g8r8 => "B8g8r8",
                MemoryFormat::NFormats => "NFormats",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MemoryFormat {
    type GlibType = ffi::GdkMemoryFormat;

    fn to_glib(&self) -> ffi::GdkMemoryFormat {
        match *self {
            MemoryFormat::B8g8r8a8Premultiplied => ffi::GDK_MEMORY_B8G8R8A8_PREMULTIPLIED,
            MemoryFormat::A8r8g8b8Premultiplied => ffi::GDK_MEMORY_A8R8G8B8_PREMULTIPLIED,
            MemoryFormat::R8g8b8a8Premultiplied => ffi::GDK_MEMORY_R8G8B8A8_PREMULTIPLIED,
            MemoryFormat::B8g8r8a8 => ffi::GDK_MEMORY_B8G8R8A8,
            MemoryFormat::A8r8g8b8 => ffi::GDK_MEMORY_A8R8G8B8,
            MemoryFormat::R8g8b8a8 => ffi::GDK_MEMORY_R8G8B8A8,
            MemoryFormat::A8b8g8r8 => ffi::GDK_MEMORY_A8B8G8R8,
            MemoryFormat::R8g8b8 => ffi::GDK_MEMORY_R8G8B8,
            MemoryFormat::B8g8r8 => ffi::GDK_MEMORY_B8G8R8,
            MemoryFormat::NFormats => ffi::GDK_MEMORY_N_FORMATS,
            MemoryFormat::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkMemoryFormat> for MemoryFormat {
    fn from_glib(value: ffi::GdkMemoryFormat) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MemoryFormat::B8g8r8a8Premultiplied,
            1 => MemoryFormat::A8r8g8b8Premultiplied,
            2 => MemoryFormat::R8g8b8a8Premultiplied,
            3 => MemoryFormat::B8g8r8a8,
            4 => MemoryFormat::A8r8g8b8,
            5 => MemoryFormat::R8g8b8a8,
            6 => MemoryFormat::A8b8g8r8,
            7 => MemoryFormat::R8g8b8,
            8 => MemoryFormat::B8g8r8,
            9 => MemoryFormat::NFormats,
            value => MemoryFormat::__Unknown(value),
        }
    }
}

impl StaticType for MemoryFormat {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_memory_format_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MemoryFormat {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MemoryFormat {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MemoryFormat {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum NotifyType {
    Ancestor,
    Virtual,
    Inferior,
    Nonlinear,
    NonlinearVirtual,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NotifyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NotifyType::{}",
            match *self {
                NotifyType::Ancestor => "Ancestor",
                NotifyType::Virtual => "Virtual",
                NotifyType::Inferior => "Inferior",
                NotifyType::Nonlinear => "Nonlinear",
                NotifyType::NonlinearVirtual => "NonlinearVirtual",
                NotifyType::Unknown => "Unknown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NotifyType {
    type GlibType = ffi::GdkNotifyType;

    fn to_glib(&self) -> ffi::GdkNotifyType {
        match *self {
            NotifyType::Ancestor => ffi::GDK_NOTIFY_ANCESTOR,
            NotifyType::Virtual => ffi::GDK_NOTIFY_VIRTUAL,
            NotifyType::Inferior => ffi::GDK_NOTIFY_INFERIOR,
            NotifyType::Nonlinear => ffi::GDK_NOTIFY_NONLINEAR,
            NotifyType::NonlinearVirtual => ffi::GDK_NOTIFY_NONLINEAR_VIRTUAL,
            NotifyType::Unknown => ffi::GDK_NOTIFY_UNKNOWN,
            NotifyType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkNotifyType> for NotifyType {
    fn from_glib(value: ffi::GdkNotifyType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NotifyType::Ancestor,
            1 => NotifyType::Virtual,
            2 => NotifyType::Inferior,
            3 => NotifyType::Nonlinear,
            4 => NotifyType::NonlinearVirtual,
            5 => NotifyType::Unknown,
            value => NotifyType::__Unknown(value),
        }
    }
}

impl StaticType for NotifyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_notify_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NotifyType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NotifyType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NotifyType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScrollDirection {
    Up,
    Down,
    Left,
    Right,
    Smooth,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollDirection::{}",
            match *self {
                ScrollDirection::Up => "Up",
                ScrollDirection::Down => "Down",
                ScrollDirection::Left => "Left",
                ScrollDirection::Right => "Right",
                ScrollDirection::Smooth => "Smooth",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollDirection {
    type GlibType = ffi::GdkScrollDirection;

    fn to_glib(&self) -> ffi::GdkScrollDirection {
        match *self {
            ScrollDirection::Up => ffi::GDK_SCROLL_UP,
            ScrollDirection::Down => ffi::GDK_SCROLL_DOWN,
            ScrollDirection::Left => ffi::GDK_SCROLL_LEFT,
            ScrollDirection::Right => ffi::GDK_SCROLL_RIGHT,
            ScrollDirection::Smooth => ffi::GDK_SCROLL_SMOOTH,
            ScrollDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkScrollDirection> for ScrollDirection {
    fn from_glib(value: ffi::GdkScrollDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollDirection::Up,
            1 => ScrollDirection::Down,
            2 => ScrollDirection::Left,
            3 => ScrollDirection::Right,
            4 => ScrollDirection::Smooth,
            value => ScrollDirection::__Unknown(value),
        }
    }
}

impl StaticType for ScrollDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_scroll_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SubpixelLayout {
    Unknown,
    None,
    HorizontalRgb,
    HorizontalBgr,
    VerticalRgb,
    VerticalBgr,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SubpixelLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SubpixelLayout::{}",
            match *self {
                SubpixelLayout::Unknown => "Unknown",
                SubpixelLayout::None => "None",
                SubpixelLayout::HorizontalRgb => "HorizontalRgb",
                SubpixelLayout::HorizontalBgr => "HorizontalBgr",
                SubpixelLayout::VerticalRgb => "VerticalRgb",
                SubpixelLayout::VerticalBgr => "VerticalBgr",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SubpixelLayout {
    type GlibType = ffi::GdkSubpixelLayout;

    fn to_glib(&self) -> ffi::GdkSubpixelLayout {
        match *self {
            SubpixelLayout::Unknown => ffi::GDK_SUBPIXEL_LAYOUT_UNKNOWN,
            SubpixelLayout::None => ffi::GDK_SUBPIXEL_LAYOUT_NONE,
            SubpixelLayout::HorizontalRgb => ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB,
            SubpixelLayout::HorizontalBgr => ffi::GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR,
            SubpixelLayout::VerticalRgb => ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB,
            SubpixelLayout::VerticalBgr => ffi::GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR,
            SubpixelLayout::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkSubpixelLayout> for SubpixelLayout {
    fn from_glib(value: ffi::GdkSubpixelLayout) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SubpixelLayout::Unknown,
            1 => SubpixelLayout::None,
            2 => SubpixelLayout::HorizontalRgb,
            3 => SubpixelLayout::HorizontalBgr,
            4 => SubpixelLayout::VerticalRgb,
            5 => SubpixelLayout::VerticalBgr,
            value => SubpixelLayout::__Unknown(value),
        }
    }
}

impl StaticType for SubpixelLayout {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_subpixel_layout_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SubpixelLayout {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SubpixelLayout {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SubpixelLayout {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SurfaceEdge {
    NorthWest,
    North,
    NorthEast,
    West,
    East,
    SouthWest,
    South,
    SouthEast,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SurfaceEdge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SurfaceEdge::{}",
            match *self {
                SurfaceEdge::NorthWest => "NorthWest",
                SurfaceEdge::North => "North",
                SurfaceEdge::NorthEast => "NorthEast",
                SurfaceEdge::West => "West",
                SurfaceEdge::East => "East",
                SurfaceEdge::SouthWest => "SouthWest",
                SurfaceEdge::South => "South",
                SurfaceEdge::SouthEast => "SouthEast",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SurfaceEdge {
    type GlibType = ffi::GdkSurfaceEdge;

    fn to_glib(&self) -> ffi::GdkSurfaceEdge {
        match *self {
            SurfaceEdge::NorthWest => ffi::GDK_SURFACE_EDGE_NORTH_WEST,
            SurfaceEdge::North => ffi::GDK_SURFACE_EDGE_NORTH,
            SurfaceEdge::NorthEast => ffi::GDK_SURFACE_EDGE_NORTH_EAST,
            SurfaceEdge::West => ffi::GDK_SURFACE_EDGE_WEST,
            SurfaceEdge::East => ffi::GDK_SURFACE_EDGE_EAST,
            SurfaceEdge::SouthWest => ffi::GDK_SURFACE_EDGE_SOUTH_WEST,
            SurfaceEdge::South => ffi::GDK_SURFACE_EDGE_SOUTH,
            SurfaceEdge::SouthEast => ffi::GDK_SURFACE_EDGE_SOUTH_EAST,
            SurfaceEdge::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkSurfaceEdge> for SurfaceEdge {
    fn from_glib(value: ffi::GdkSurfaceEdge) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SurfaceEdge::NorthWest,
            1 => SurfaceEdge::North,
            2 => SurfaceEdge::NorthEast,
            3 => SurfaceEdge::West,
            4 => SurfaceEdge::East,
            5 => SurfaceEdge::SouthWest,
            6 => SurfaceEdge::South,
            7 => SurfaceEdge::SouthEast,
            value => SurfaceEdge::__Unknown(value),
        }
    }
}

impl StaticType for SurfaceEdge {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_surface_edge_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SurfaceEdge {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SurfaceEdge {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SurfaceEdge {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TouchpadGesturePhase {
    Begin,
    Update,
    End,
    Cancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TouchpadGesturePhase {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TouchpadGesturePhase::{}",
            match *self {
                TouchpadGesturePhase::Begin => "Begin",
                TouchpadGesturePhase::Update => "Update",
                TouchpadGesturePhase::End => "End",
                TouchpadGesturePhase::Cancel => "Cancel",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TouchpadGesturePhase {
    type GlibType = ffi::GdkTouchpadGesturePhase;

    fn to_glib(&self) -> ffi::GdkTouchpadGesturePhase {
        match *self {
            TouchpadGesturePhase::Begin => ffi::GDK_TOUCHPAD_GESTURE_PHASE_BEGIN,
            TouchpadGesturePhase::Update => ffi::GDK_TOUCHPAD_GESTURE_PHASE_UPDATE,
            TouchpadGesturePhase::End => ffi::GDK_TOUCHPAD_GESTURE_PHASE_END,
            TouchpadGesturePhase::Cancel => ffi::GDK_TOUCHPAD_GESTURE_PHASE_CANCEL,
            TouchpadGesturePhase::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkTouchpadGesturePhase> for TouchpadGesturePhase {
    fn from_glib(value: ffi::GdkTouchpadGesturePhase) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TouchpadGesturePhase::Begin,
            1 => TouchpadGesturePhase::Update,
            2 => TouchpadGesturePhase::End,
            3 => TouchpadGesturePhase::Cancel,
            value => TouchpadGesturePhase::__Unknown(value),
        }
    }
}

impl StaticType for TouchpadGesturePhase {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_touchpad_gesture_phase_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TouchpadGesturePhase {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TouchpadGesturePhase {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TouchpadGesturePhase {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VulkanError {
    Unsupported,
    NotAvailable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VulkanError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VulkanError::{}",
            match *self {
                VulkanError::Unsupported => "Unsupported",
                VulkanError::NotAvailable => "NotAvailable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VulkanError {
    type GlibType = ffi::GdkVulkanError;

    fn to_glib(&self) -> ffi::GdkVulkanError {
        match *self {
            VulkanError::Unsupported => ffi::GDK_VULKAN_ERROR_UNSUPPORTED,
            VulkanError::NotAvailable => ffi::GDK_VULKAN_ERROR_NOT_AVAILABLE,
            VulkanError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkVulkanError> for VulkanError {
    fn from_glib(value: ffi::GdkVulkanError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => VulkanError::Unsupported,
            1 => VulkanError::NotAvailable,
            value => VulkanError::__Unknown(value),
        }
    }
}

impl ErrorDomain for VulkanError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gdk_vulkan_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(VulkanError::Unsupported),
            1 => Some(VulkanError::NotAvailable),
            value => Some(VulkanError::__Unknown(value)),
        }
    }
}

impl StaticType for VulkanError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_vulkan_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VulkanError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VulkanError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VulkanError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
