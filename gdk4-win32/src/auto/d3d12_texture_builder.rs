// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ffi;
use glib::{
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    #[doc(alias = "GdkD3D12TextureBuilder")]
    pub struct D3D12TextureBuilder(Object<ffi::GdkD3D12TextureBuilder, ffi::GdkD3D12TextureBuilderClass>);

    match fn {
        type_ => || ffi::gdk_d3d12_texture_builder_get_type(),
    }
}

impl D3D12TextureBuilder {
    #[doc(alias = "gdk_d3d12_texture_builder_new")]
    pub fn new() -> D3D12TextureBuilder {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::gdk_d3d12_texture_builder_new()) }
    }

    //#[doc(alias = "gdk_d3d12_texture_builder_build")]
    //pub fn build(&self, data: /*Unimplemented*/Option<Basic: Pointer>) -> Result<Option<gdk::Texture>, glib::Error> {
    //    unsafe { TODO: call ffi:gdk_d3d12_texture_builder_build() }
    //}

    #[doc(alias = "gdk_d3d12_texture_builder_get_color_state")]
    #[doc(alias = "get_color_state")]
    #[doc(alias = "color-state")]
    pub fn color_state(&self) -> Option<gdk::ColorState> {
        unsafe {
            from_glib_none(ffi::gdk_d3d12_texture_builder_get_color_state(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "gdk_d3d12_texture_builder_get_fence")]
    //#[doc(alias = "get_fence")]
    //pub fn fence(&self) -> /*Unimplemented*/Option<Basic: Pointer> {
    //    unsafe { TODO: call ffi:gdk_d3d12_texture_builder_get_fence() }
    //}

    #[doc(alias = "gdk_d3d12_texture_builder_get_fence_wait")]
    #[doc(alias = "get_fence_wait")]
    #[doc(alias = "fence-wait")]
    pub fn fence_wait(&self) -> u64 {
        unsafe { ffi::gdk_d3d12_texture_builder_get_fence_wait(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_d3d12_texture_builder_get_premultiplied")]
    #[doc(alias = "get_premultiplied")]
    #[doc(alias = "premultiplied")]
    pub fn is_premultiplied(&self) -> bool {
        unsafe {
            from_glib(ffi::gdk_d3d12_texture_builder_get_premultiplied(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "gdk_d3d12_texture_builder_get_resource")]
    //#[doc(alias = "get_resource")]
    //pub fn resource(&self) -> /*Unimplemented*/Option<Basic: Pointer> {
    //    unsafe { TODO: call ffi:gdk_d3d12_texture_builder_get_resource() }
    //}

    #[doc(alias = "gdk_d3d12_texture_builder_get_update_region")]
    #[doc(alias = "get_update_region")]
    #[doc(alias = "update-region")]
    pub fn update_region(&self) -> Option<cairo::Region> {
        unsafe {
            from_glib_none(ffi::gdk_d3d12_texture_builder_get_update_region(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gdk_d3d12_texture_builder_get_update_texture")]
    #[doc(alias = "get_update_texture")]
    #[doc(alias = "update-texture")]
    pub fn update_texture(&self) -> Option<gdk::Texture> {
        unsafe {
            from_glib_none(ffi::gdk_d3d12_texture_builder_get_update_texture(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gdk_d3d12_texture_builder_set_color_state")]
    #[doc(alias = "color-state")]
    pub fn set_color_state(&self, color_state: Option<&gdk::ColorState>) {
        unsafe {
            ffi::gdk_d3d12_texture_builder_set_color_state(
                self.to_glib_none().0,
                color_state.to_glib_none().0,
            );
        }
    }

    //#[doc(alias = "gdk_d3d12_texture_builder_set_fence")]
    //#[doc(alias = "fence")]
    //pub fn set_fence(&self, fence: /*Unimplemented*/Basic: Pointer) {
    //    unsafe { TODO: call ffi:gdk_d3d12_texture_builder_set_fence() }
    //}

    #[doc(alias = "gdk_d3d12_texture_builder_set_fence_wait")]
    #[doc(alias = "fence-wait")]
    pub fn set_fence_wait(&self, fence_wait: u64) {
        unsafe {
            ffi::gdk_d3d12_texture_builder_set_fence_wait(self.to_glib_none().0, fence_wait);
        }
    }

    #[doc(alias = "gdk_d3d12_texture_builder_set_premultiplied")]
    #[doc(alias = "premultiplied")]
    pub fn set_premultiplied(&self, premultiplied: bool) {
        unsafe {
            ffi::gdk_d3d12_texture_builder_set_premultiplied(
                self.to_glib_none().0,
                premultiplied.into_glib(),
            );
        }
    }

    //#[doc(alias = "gdk_d3d12_texture_builder_set_resource")]
    //#[doc(alias = "resource")]
    //pub fn set_resource(&self, resource: /*Unimplemented*/Basic: Pointer) {
    //    unsafe { TODO: call ffi:gdk_d3d12_texture_builder_set_resource() }
    //}

    #[doc(alias = "gdk_d3d12_texture_builder_set_update_region")]
    #[doc(alias = "update-region")]
    pub fn set_update_region(&self, region: Option<&cairo::Region>) {
        unsafe {
            ffi::gdk_d3d12_texture_builder_set_update_region(
                self.to_glib_none().0,
                mut_override(region.to_glib_none().0),
            );
        }
    }

    #[doc(alias = "gdk_d3d12_texture_builder_set_update_texture")]
    #[doc(alias = "update-texture")]
    pub fn set_update_texture(&self, texture: Option<&impl IsA<gdk::Texture>>) {
        unsafe {
            ffi::gdk_d3d12_texture_builder_set_update_texture(
                self.to_glib_none().0,
                texture.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "color-state")]
    pub fn connect_color_state_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_color_state_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::color-state".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_color_state_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "fence")]
    pub fn connect_fence_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_fence_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::fence".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_fence_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "fence-wait")]
    pub fn connect_fence_wait_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_fence_wait_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::fence-wait".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_fence_wait_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "premultiplied")]
    pub fn connect_premultiplied_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_premultiplied_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::premultiplied".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_premultiplied_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "resource")]
    pub fn connect_resource_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_resource_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::resource".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_resource_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "update-region")]
    pub fn connect_update_region_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_update_region_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::update-region".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_update_region_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v4_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
    #[doc(alias = "update-texture")]
    pub fn connect_update_texture_notify<F: Fn(&Self) + Send + Sync + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_update_texture_trampoline<
            F: Fn(&D3D12TextureBuilder) + Send + Sync + 'static,
        >(
            this: *mut ffi::GdkD3D12TextureBuilder,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::update-texture".as_ptr(),
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_update_texture_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

#[cfg(feature = "v4_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_20")))]
impl Default for D3D12TextureBuilder {
    fn default() -> Self {
        Self::new()
    }
}

unsafe impl Send for D3D12TextureBuilder {}
unsafe impl Sync for D3D12TextureBuilder {}
