// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use bitflags::bitflags;
use glib::{translate::*, value::FromValue, value::ToValue, StaticType, Type};
use std::fmt;

bitflags! {
    #[doc(alias = "GtkApplicationInhibitFlags")]
    pub struct ApplicationInhibitFlags: u32 {
        #[doc(alias = "GTK_APPLICATION_INHIBIT_LOGOUT")]
        const LOGOUT = ffi::GTK_APPLICATION_INHIBIT_LOGOUT as _;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_SWITCH")]
        const SWITCH = ffi::GTK_APPLICATION_INHIBIT_SWITCH as _;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_SUSPEND")]
        const SUSPEND = ffi::GTK_APPLICATION_INHIBIT_SUSPEND as _;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_IDLE")]
        const IDLE = ffi::GTK_APPLICATION_INHIBIT_IDLE as _;
    }
}

impl fmt::Display for ApplicationInhibitFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ApplicationInhibitFlags {
    type GlibType = ffi::GtkApplicationInhibitFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkApplicationInhibitFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkApplicationInhibitFlags> for ApplicationInhibitFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkApplicationInhibitFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ApplicationInhibitFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_application_inhibit_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ApplicationInhibitFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for ApplicationInhibitFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ApplicationInhibitFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ApplicationInhibitFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ApplicationInhibitFlags> for glib::Value {
    #[inline]
    fn from(v: ApplicationInhibitFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkBuilderClosureFlags")]
    pub struct BuilderClosureFlags: u32 {
        #[doc(alias = "GTK_BUILDER_CLOSURE_SWAPPED")]
        const SWAPPED = ffi::GTK_BUILDER_CLOSURE_SWAPPED as _;
    }
}

impl fmt::Display for BuilderClosureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for BuilderClosureFlags {
    type GlibType = ffi::GtkBuilderClosureFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkBuilderClosureFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderClosureFlags> for BuilderClosureFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkBuilderClosureFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BuilderClosureFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_builder_closure_flags_get_type()) }
    }
}

impl glib::HasParamSpec for BuilderClosureFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for BuilderClosureFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BuilderClosureFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BuilderClosureFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BuilderClosureFlags> for glib::Value {
    #[inline]
    fn from(v: BuilderClosureFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkCellRendererState")]
    pub struct CellRendererState: u32 {
        #[doc(alias = "GTK_CELL_RENDERER_SELECTED")]
        const SELECTED = ffi::GTK_CELL_RENDERER_SELECTED as _;
        #[doc(alias = "GTK_CELL_RENDERER_PRELIT")]
        const PRELIT = ffi::GTK_CELL_RENDERER_PRELIT as _;
        #[doc(alias = "GTK_CELL_RENDERER_INSENSITIVE")]
        const INSENSITIVE = ffi::GTK_CELL_RENDERER_INSENSITIVE as _;
        #[doc(alias = "GTK_CELL_RENDERER_SORTED")]
        const SORTED = ffi::GTK_CELL_RENDERER_SORTED as _;
        #[doc(alias = "GTK_CELL_RENDERER_FOCUSED")]
        const FOCUSED = ffi::GTK_CELL_RENDERER_FOCUSED as _;
        #[doc(alias = "GTK_CELL_RENDERER_EXPANDABLE")]
        const EXPANDABLE = ffi::GTK_CELL_RENDERER_EXPANDABLE as _;
        #[doc(alias = "GTK_CELL_RENDERER_EXPANDED")]
        const EXPANDED = ffi::GTK_CELL_RENDERER_EXPANDED as _;
    }
}

impl fmt::Display for CellRendererState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for CellRendererState {
    type GlibType = ffi::GtkCellRendererState;

    #[inline]
    fn into_glib(self) -> ffi::GtkCellRendererState {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererState> for CellRendererState {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCellRendererState) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for CellRendererState {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_state_get_type()) }
    }
}

impl glib::HasParamSpec for CellRendererState {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for CellRendererState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CellRendererState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for CellRendererState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CellRendererState> for glib::Value {
    #[inline]
    fn from(v: CellRendererState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkDebugFlags")]
    pub struct DebugFlags: u32 {
        #[doc(alias = "GTK_DEBUG_TEXT")]
        const TEXT = ffi::GTK_DEBUG_TEXT as _;
        #[doc(alias = "GTK_DEBUG_TREE")]
        const TREE = ffi::GTK_DEBUG_TREE as _;
        #[doc(alias = "GTK_DEBUG_KEYBINDINGS")]
        const KEYBINDINGS = ffi::GTK_DEBUG_KEYBINDINGS as _;
        #[doc(alias = "GTK_DEBUG_MODULES")]
        const MODULES = ffi::GTK_DEBUG_MODULES as _;
        #[doc(alias = "GTK_DEBUG_GEOMETRY")]
        const GEOMETRY = ffi::GTK_DEBUG_GEOMETRY as _;
        #[doc(alias = "GTK_DEBUG_ICONTHEME")]
        const ICONTHEME = ffi::GTK_DEBUG_ICONTHEME as _;
        #[doc(alias = "GTK_DEBUG_PRINTING")]
        const PRINTING = ffi::GTK_DEBUG_PRINTING as _;
        #[doc(alias = "GTK_DEBUG_BUILDER")]
        const BUILDER = ffi::GTK_DEBUG_BUILDER as _;
        #[doc(alias = "GTK_DEBUG_SIZE_REQUEST")]
        const SIZE_REQUEST = ffi::GTK_DEBUG_SIZE_REQUEST as _;
        #[doc(alias = "GTK_DEBUG_NO_CSS_CACHE")]
        const NO_CSS_CACHE = ffi::GTK_DEBUG_NO_CSS_CACHE as _;
        #[doc(alias = "GTK_DEBUG_INTERACTIVE")]
        const INTERACTIVE = ffi::GTK_DEBUG_INTERACTIVE as _;
        #[doc(alias = "GTK_DEBUG_TOUCHSCREEN")]
        const TOUCHSCREEN = ffi::GTK_DEBUG_TOUCHSCREEN as _;
        #[doc(alias = "GTK_DEBUG_ACTIONS")]
        const ACTIONS = ffi::GTK_DEBUG_ACTIONS as _;
        #[doc(alias = "GTK_DEBUG_LAYOUT")]
        const LAYOUT = ffi::GTK_DEBUG_LAYOUT as _;
        #[doc(alias = "GTK_DEBUG_SNAPSHOT")]
        const SNAPSHOT = ffi::GTK_DEBUG_SNAPSHOT as _;
        #[doc(alias = "GTK_DEBUG_CONSTRAINTS")]
        const CONSTRAINTS = ffi::GTK_DEBUG_CONSTRAINTS as _;
        #[doc(alias = "GTK_DEBUG_BUILDER_OBJECTS")]
        const BUILDER_OBJECTS = ffi::GTK_DEBUG_BUILDER_OBJECTS as _;
        #[doc(alias = "GTK_DEBUG_A11Y")]
        const A11Y = ffi::GTK_DEBUG_A11Y as _;
        #[doc(alias = "GTK_DEBUG_ICONFALLBACK")]
        const ICONFALLBACK = ffi::GTK_DEBUG_ICONFALLBACK as _;
        #[cfg(any(feature = "v4_8", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v4_8")))]
        #[doc(alias = "GTK_DEBUG_INVERT_TEXT_DIR")]
        const INVERT_TEXT_DIR = ffi::GTK_DEBUG_INVERT_TEXT_DIR as _;
    }
}

impl fmt::Display for DebugFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DebugFlags {
    type GlibType = ffi::GtkDebugFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkDebugFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDebugFlags> for DebugFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkDebugFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DebugFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_debug_flags_get_type()) }
    }
}

impl glib::HasParamSpec for DebugFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for DebugFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DebugFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DebugFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DebugFlags> for glib::Value {
    #[inline]
    fn from(v: DebugFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkDialogFlags")]
    pub struct DialogFlags: u32 {
        #[doc(alias = "GTK_DIALOG_MODAL")]
        const MODAL = ffi::GTK_DIALOG_MODAL as _;
        #[doc(alias = "GTK_DIALOG_DESTROY_WITH_PARENT")]
        const DESTROY_WITH_PARENT = ffi::GTK_DIALOG_DESTROY_WITH_PARENT as _;
        #[doc(alias = "GTK_DIALOG_USE_HEADER_BAR")]
        const USE_HEADER_BAR = ffi::GTK_DIALOG_USE_HEADER_BAR as _;
    }
}

impl fmt::Display for DialogFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DialogFlags {
    type GlibType = ffi::GtkDialogFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkDialogFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDialogFlags> for DialogFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkDialogFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DialogFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_dialog_flags_get_type()) }
    }
}

impl glib::HasParamSpec for DialogFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for DialogFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DialogFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DialogFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DialogFlags> for glib::Value {
    #[inline]
    fn from(v: DialogFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkEventControllerScrollFlags")]
    pub struct EventControllerScrollFlags: u32 {
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_NONE")]
        const NONE = ffi::GTK_EVENT_CONTROLLER_SCROLL_NONE as _;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_VERTICAL")]
        const VERTICAL = ffi::GTK_EVENT_CONTROLLER_SCROLL_VERTICAL as _;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL")]
        const HORIZONTAL = ffi::GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL as _;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_DISCRETE")]
        const DISCRETE = ffi::GTK_EVENT_CONTROLLER_SCROLL_DISCRETE as _;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_KINETIC")]
        const KINETIC = ffi::GTK_EVENT_CONTROLLER_SCROLL_KINETIC as _;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES")]
        const BOTH_AXES = ffi::GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES as _;
    }
}

impl fmt::Display for EventControllerScrollFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for EventControllerScrollFlags {
    type GlibType = ffi::GtkEventControllerScrollFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkEventControllerScrollFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEventControllerScrollFlags> for EventControllerScrollFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkEventControllerScrollFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for EventControllerScrollFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_event_controller_scroll_flags_get_type()) }
    }
}

impl glib::HasParamSpec for EventControllerScrollFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for EventControllerScrollFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for EventControllerScrollFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for EventControllerScrollFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EventControllerScrollFlags> for glib::Value {
    #[inline]
    fn from(v: EventControllerScrollFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkFontChooserLevel")]
    pub struct FontChooserLevel: u32 {
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_FAMILY")]
        const FAMILY = ffi::GTK_FONT_CHOOSER_LEVEL_FAMILY as _;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_STYLE")]
        const STYLE = ffi::GTK_FONT_CHOOSER_LEVEL_STYLE as _;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_SIZE")]
        const SIZE = ffi::GTK_FONT_CHOOSER_LEVEL_SIZE as _;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_VARIATIONS")]
        const VARIATIONS = ffi::GTK_FONT_CHOOSER_LEVEL_VARIATIONS as _;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_FEATURES")]
        const FEATURES = ffi::GTK_FONT_CHOOSER_LEVEL_FEATURES as _;
    }
}

impl fmt::Display for FontChooserLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FontChooserLevel {
    type GlibType = ffi::GtkFontChooserLevel;

    #[inline]
    fn into_glib(self) -> ffi::GtkFontChooserLevel {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFontChooserLevel> for FontChooserLevel {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFontChooserLevel) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for FontChooserLevel {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_font_chooser_level_get_type()) }
    }
}

impl glib::HasParamSpec for FontChooserLevel {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for FontChooserLevel {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FontChooserLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for FontChooserLevel {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FontChooserLevel> for glib::Value {
    #[inline]
    fn from(v: FontChooserLevel) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkIconLookupFlags")]
    pub struct IconLookupFlags: u32 {
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_REGULAR")]
        const FORCE_REGULAR = ffi::GTK_ICON_LOOKUP_FORCE_REGULAR as _;
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_SYMBOLIC")]
        const FORCE_SYMBOLIC = ffi::GTK_ICON_LOOKUP_FORCE_SYMBOLIC as _;
        #[doc(alias = "GTK_ICON_LOOKUP_PRELOAD")]
        const PRELOAD = ffi::GTK_ICON_LOOKUP_PRELOAD as _;
    }
}

impl fmt::Display for IconLookupFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for IconLookupFlags {
    type GlibType = ffi::GtkIconLookupFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkIconLookupFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconLookupFlags> for IconLookupFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkIconLookupFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for IconLookupFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_lookup_flags_get_type()) }
    }
}

impl glib::HasParamSpec for IconLookupFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for IconLookupFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for IconLookupFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for IconLookupFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<IconLookupFlags> for glib::Value {
    #[inline]
    fn from(v: IconLookupFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkInputHints")]
    pub struct InputHints: u32 {
        #[doc(alias = "GTK_INPUT_HINT_NONE")]
        const NONE = ffi::GTK_INPUT_HINT_NONE as _;
        #[doc(alias = "GTK_INPUT_HINT_SPELLCHECK")]
        const SPELLCHECK = ffi::GTK_INPUT_HINT_SPELLCHECK as _;
        #[doc(alias = "GTK_INPUT_HINT_NO_SPELLCHECK")]
        const NO_SPELLCHECK = ffi::GTK_INPUT_HINT_NO_SPELLCHECK as _;
        #[doc(alias = "GTK_INPUT_HINT_WORD_COMPLETION")]
        const WORD_COMPLETION = ffi::GTK_INPUT_HINT_WORD_COMPLETION as _;
        #[doc(alias = "GTK_INPUT_HINT_LOWERCASE")]
        const LOWERCASE = ffi::GTK_INPUT_HINT_LOWERCASE as _;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_CHARS")]
        const UPPERCASE_CHARS = ffi::GTK_INPUT_HINT_UPPERCASE_CHARS as _;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_WORDS")]
        const UPPERCASE_WORDS = ffi::GTK_INPUT_HINT_UPPERCASE_WORDS as _;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_SENTENCES")]
        const UPPERCASE_SENTENCES = ffi::GTK_INPUT_HINT_UPPERCASE_SENTENCES as _;
        #[doc(alias = "GTK_INPUT_HINT_INHIBIT_OSK")]
        const INHIBIT_OSK = ffi::GTK_INPUT_HINT_INHIBIT_OSK as _;
        #[doc(alias = "GTK_INPUT_HINT_VERTICAL_WRITING")]
        const VERTICAL_WRITING = ffi::GTK_INPUT_HINT_VERTICAL_WRITING as _;
        #[doc(alias = "GTK_INPUT_HINT_EMOJI")]
        const EMOJI = ffi::GTK_INPUT_HINT_EMOJI as _;
        #[doc(alias = "GTK_INPUT_HINT_NO_EMOJI")]
        const NO_EMOJI = ffi::GTK_INPUT_HINT_NO_EMOJI as _;
        #[doc(alias = "GTK_INPUT_HINT_PRIVATE")]
        const PRIVATE = ffi::GTK_INPUT_HINT_PRIVATE as _;
    }
}

impl fmt::Display for InputHints {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for InputHints {
    type GlibType = ffi::GtkInputHints;

    #[inline]
    fn into_glib(self) -> ffi::GtkInputHints {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkInputHints> for InputHints {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkInputHints) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for InputHints {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_input_hints_get_type()) }
    }
}

impl glib::HasParamSpec for InputHints {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for InputHints {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for InputHints {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for InputHints {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<InputHints> for glib::Value {
    #[inline]
    fn from(v: InputHints) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkPickFlags")]
    pub struct PickFlags: u32 {
        #[doc(alias = "GTK_PICK_DEFAULT")]
        const DEFAULT = ffi::GTK_PICK_DEFAULT as _;
        #[doc(alias = "GTK_PICK_INSENSITIVE")]
        const INSENSITIVE = ffi::GTK_PICK_INSENSITIVE as _;
        #[doc(alias = "GTK_PICK_NON_TARGETABLE")]
        const NON_TARGETABLE = ffi::GTK_PICK_NON_TARGETABLE as _;
    }
}

impl fmt::Display for PickFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PickFlags {
    type GlibType = ffi::GtkPickFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkPickFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPickFlags> for PickFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPickFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PickFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pick_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PickFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for PickFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PickFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PickFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PickFlags> for glib::Value {
    #[inline]
    fn from(v: PickFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkPopoverMenuFlags")]
    pub struct PopoverMenuFlags: u32 {
        #[doc(alias = "GTK_POPOVER_MENU_NESTED")]
        const NESTED = ffi::GTK_POPOVER_MENU_NESTED as _;
    }
}

impl fmt::Display for PopoverMenuFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PopoverMenuFlags {
    type GlibType = ffi::GtkPopoverMenuFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkPopoverMenuFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPopoverMenuFlags> for PopoverMenuFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPopoverMenuFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PopoverMenuFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_popover_menu_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PopoverMenuFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for PopoverMenuFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PopoverMenuFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PopoverMenuFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PopoverMenuFlags> for glib::Value {
    #[inline]
    fn from(v: PopoverMenuFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(target_os = "linux")))]
    #[doc(alias = "GtkPrintCapabilities")]
    pub struct PrintCapabilities: u32 {
        #[doc(alias = "GTK_PRINT_CAPABILITY_PAGE_SET")]
        const PAGE_SET = ffi::GTK_PRINT_CAPABILITY_PAGE_SET as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_COPIES")]
        const COPIES = ffi::GTK_PRINT_CAPABILITY_COPIES as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_COLLATE")]
        const COLLATE = ffi::GTK_PRINT_CAPABILITY_COLLATE as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_REVERSE")]
        const REVERSE = ffi::GTK_PRINT_CAPABILITY_REVERSE as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_SCALE")]
        const SCALE = ffi::GTK_PRINT_CAPABILITY_SCALE as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_GENERATE_PDF")]
        const GENERATE_PDF = ffi::GTK_PRINT_CAPABILITY_GENERATE_PDF as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_GENERATE_PS")]
        const GENERATE_PS = ffi::GTK_PRINT_CAPABILITY_GENERATE_PS as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_PREVIEW")]
        const PREVIEW = ffi::GTK_PRINT_CAPABILITY_PREVIEW as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_NUMBER_UP")]
        const NUMBER_UP = ffi::GTK_PRINT_CAPABILITY_NUMBER_UP as _;
        #[doc(alias = "GTK_PRINT_CAPABILITY_NUMBER_UP_LAYOUT")]
        const NUMBER_UP_LAYOUT = ffi::GTK_PRINT_CAPABILITY_NUMBER_UP_LAYOUT as _;
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl fmt::Display for PrintCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
#[doc(hidden)]
impl IntoGlib for PrintCapabilities {
    type GlibType = ffi::GtkPrintCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintCapabilities {
        self.bits()
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::GtkPrintCapabilities> for PrintCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl StaticType for PrintCapabilities {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_capabilities_get_type()) }
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl glib::HasParamSpec for PrintCapabilities {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl glib::value::ValueType for PrintCapabilities {
    type Type = Self;
}

#[cfg(any(target_os = "linux", feature = "dox"))]
unsafe impl<'a> FromValue<'a> for PrintCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl ToValue for PrintCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(target_os = "linux", feature = "dox"))]
impl From<PrintCapabilities> for glib::Value {
    #[inline]
    fn from(v: PrintCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkShortcutActionFlags")]
    pub struct ShortcutActionFlags: u32 {
        #[doc(alias = "GTK_SHORTCUT_ACTION_EXCLUSIVE")]
        const EXCLUSIVE = ffi::GTK_SHORTCUT_ACTION_EXCLUSIVE as _;
    }
}

impl fmt::Display for ShortcutActionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ShortcutActionFlags {
    type GlibType = ffi::GtkShortcutActionFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkShortcutActionFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutActionFlags> for ShortcutActionFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkShortcutActionFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ShortcutActionFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_shortcut_action_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ShortcutActionFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for ShortcutActionFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ShortcutActionFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ShortcutActionFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ShortcutActionFlags> for glib::Value {
    #[inline]
    fn from(v: ShortcutActionFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkStateFlags")]
    pub struct StateFlags: u32 {
        #[doc(alias = "GTK_STATE_FLAG_NORMAL")]
        const NORMAL = ffi::GTK_STATE_FLAG_NORMAL as _;
        #[doc(alias = "GTK_STATE_FLAG_ACTIVE")]
        const ACTIVE = ffi::GTK_STATE_FLAG_ACTIVE as _;
        #[doc(alias = "GTK_STATE_FLAG_PRELIGHT")]
        const PRELIGHT = ffi::GTK_STATE_FLAG_PRELIGHT as _;
        #[doc(alias = "GTK_STATE_FLAG_SELECTED")]
        const SELECTED = ffi::GTK_STATE_FLAG_SELECTED as _;
        #[doc(alias = "GTK_STATE_FLAG_INSENSITIVE")]
        const INSENSITIVE = ffi::GTK_STATE_FLAG_INSENSITIVE as _;
        #[doc(alias = "GTK_STATE_FLAG_INCONSISTENT")]
        const INCONSISTENT = ffi::GTK_STATE_FLAG_INCONSISTENT as _;
        #[doc(alias = "GTK_STATE_FLAG_FOCUSED")]
        const FOCUSED = ffi::GTK_STATE_FLAG_FOCUSED as _;
        #[doc(alias = "GTK_STATE_FLAG_BACKDROP")]
        const BACKDROP = ffi::GTK_STATE_FLAG_BACKDROP as _;
        #[doc(alias = "GTK_STATE_FLAG_DIR_LTR")]
        const DIR_LTR = ffi::GTK_STATE_FLAG_DIR_LTR as _;
        #[doc(alias = "GTK_STATE_FLAG_DIR_RTL")]
        const DIR_RTL = ffi::GTK_STATE_FLAG_DIR_RTL as _;
        #[doc(alias = "GTK_STATE_FLAG_LINK")]
        const LINK = ffi::GTK_STATE_FLAG_LINK as _;
        #[doc(alias = "GTK_STATE_FLAG_VISITED")]
        const VISITED = ffi::GTK_STATE_FLAG_VISITED as _;
        #[doc(alias = "GTK_STATE_FLAG_CHECKED")]
        const CHECKED = ffi::GTK_STATE_FLAG_CHECKED as _;
        #[doc(alias = "GTK_STATE_FLAG_DROP_ACTIVE")]
        const DROP_ACTIVE = ffi::GTK_STATE_FLAG_DROP_ACTIVE as _;
        #[doc(alias = "GTK_STATE_FLAG_FOCUS_VISIBLE")]
        const FOCUS_VISIBLE = ffi::GTK_STATE_FLAG_FOCUS_VISIBLE as _;
        #[doc(alias = "GTK_STATE_FLAG_FOCUS_WITHIN")]
        const FOCUS_WITHIN = ffi::GTK_STATE_FLAG_FOCUS_WITHIN as _;
    }
}

impl fmt::Display for StateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for StateFlags {
    type GlibType = ffi::GtkStateFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkStateFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStateFlags> for StateFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkStateFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StateFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_state_flags_get_type()) }
    }
}

impl glib::HasParamSpec for StateFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for StateFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for StateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StateFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StateFlags> for glib::Value {
    #[inline]
    fn from(v: StateFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkStyleContextPrintFlags")]
    pub struct StyleContextPrintFlags: u32 {
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_NONE")]
        const NONE = ffi::GTK_STYLE_CONTEXT_PRINT_NONE as _;
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_RECURSE")]
        const RECURSE = ffi::GTK_STYLE_CONTEXT_PRINT_RECURSE as _;
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE")]
        const SHOW_STYLE = ffi::GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE as _;
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_SHOW_CHANGE")]
        const SHOW_CHANGE = ffi::GTK_STYLE_CONTEXT_PRINT_SHOW_CHANGE as _;
    }
}

impl fmt::Display for StyleContextPrintFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for StyleContextPrintFlags {
    type GlibType = ffi::GtkStyleContextPrintFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkStyleContextPrintFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStyleContextPrintFlags> for StyleContextPrintFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkStyleContextPrintFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StyleContextPrintFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_style_context_print_flags_get_type()) }
    }
}

impl glib::HasParamSpec for StyleContextPrintFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for StyleContextPrintFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for StyleContextPrintFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StyleContextPrintFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StyleContextPrintFlags> for glib::Value {
    #[inline]
    fn from(v: StyleContextPrintFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkTextSearchFlags")]
    pub struct TextSearchFlags: u32 {
        #[doc(alias = "GTK_TEXT_SEARCH_VISIBLE_ONLY")]
        const VISIBLE_ONLY = ffi::GTK_TEXT_SEARCH_VISIBLE_ONLY as _;
        #[doc(alias = "GTK_TEXT_SEARCH_TEXT_ONLY")]
        const TEXT_ONLY = ffi::GTK_TEXT_SEARCH_TEXT_ONLY as _;
        #[doc(alias = "GTK_TEXT_SEARCH_CASE_INSENSITIVE")]
        const CASE_INSENSITIVE = ffi::GTK_TEXT_SEARCH_CASE_INSENSITIVE as _;
    }
}

impl fmt::Display for TextSearchFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TextSearchFlags {
    type GlibType = ffi::GtkTextSearchFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkTextSearchFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextSearchFlags> for TextSearchFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTextSearchFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TextSearchFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_search_flags_get_type()) }
    }
}

impl glib::HasParamSpec for TextSearchFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for TextSearchFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TextSearchFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TextSearchFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextSearchFlags> for glib::Value {
    #[inline]
    fn from(v: TextSearchFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "GtkTreeModelFlags")]
    pub struct TreeModelFlags: u32 {
        #[doc(alias = "GTK_TREE_MODEL_ITERS_PERSIST")]
        const ITERS_PERSIST = ffi::GTK_TREE_MODEL_ITERS_PERSIST as _;
        #[doc(alias = "GTK_TREE_MODEL_LIST_ONLY")]
        const LIST_ONLY = ffi::GTK_TREE_MODEL_LIST_ONLY as _;
    }
}

impl fmt::Display for TreeModelFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TreeModelFlags {
    type GlibType = ffi::GtkTreeModelFlags;

    #[inline]
    fn into_glib(self) -> ffi::GtkTreeModelFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeModelFlags> for TreeModelFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTreeModelFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TreeModelFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_model_flags_get_type()) }
    }
}

impl glib::HasParamSpec for TreeModelFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for TreeModelFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TreeModelFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TreeModelFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TreeModelFlags> for glib::Value {
    #[inline]
    fn from(v: TreeModelFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
