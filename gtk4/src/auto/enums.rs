// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleAutocomplete {
    None,
    Inline,
    List,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleAutocomplete {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleAutocomplete::{}",
            match *self {
                AccessibleAutocomplete::None => "None",
                AccessibleAutocomplete::Inline => "Inline",
                AccessibleAutocomplete::List => "List",
                AccessibleAutocomplete::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleAutocomplete {
    type GlibType = ffi::GtkAccessibleAutocomplete;

    fn to_glib(&self) -> ffi::GtkAccessibleAutocomplete {
        match *self {
            AccessibleAutocomplete::None => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_NONE,
            AccessibleAutocomplete::Inline => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_INLINE,
            AccessibleAutocomplete::List => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_LIST,
            AccessibleAutocomplete::Both => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_BOTH,
            AccessibleAutocomplete::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleAutocomplete> for AccessibleAutocomplete {
    fn from_glib(value: ffi::GtkAccessibleAutocomplete) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleAutocomplete::None,
            1 => AccessibleAutocomplete::Inline,
            2 => AccessibleAutocomplete::List,
            3 => AccessibleAutocomplete::Both,
            value => AccessibleAutocomplete::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleAutocomplete {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_autocomplete_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleAutocomplete {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleAutocomplete {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleAutocomplete {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleInvalidState {
    False,
    True,
    Grammar,
    Spelling,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleInvalidState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleInvalidState::{}",
            match *self {
                AccessibleInvalidState::False => "False",
                AccessibleInvalidState::True => "True",
                AccessibleInvalidState::Grammar => "Grammar",
                AccessibleInvalidState::Spelling => "Spelling",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleInvalidState {
    type GlibType = ffi::GtkAccessibleInvalidState;

    fn to_glib(&self) -> ffi::GtkAccessibleInvalidState {
        match *self {
            AccessibleInvalidState::False => ffi::GTK_ACCESSIBLE_INVALID_FALSE,
            AccessibleInvalidState::True => ffi::GTK_ACCESSIBLE_INVALID_TRUE,
            AccessibleInvalidState::Grammar => ffi::GTK_ACCESSIBLE_INVALID_GRAMMAR,
            AccessibleInvalidState::Spelling => ffi::GTK_ACCESSIBLE_INVALID_SPELLING,
            AccessibleInvalidState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleInvalidState> for AccessibleInvalidState {
    fn from_glib(value: ffi::GtkAccessibleInvalidState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleInvalidState::False,
            1 => AccessibleInvalidState::True,
            2 => AccessibleInvalidState::Grammar,
            3 => AccessibleInvalidState::Spelling,
            value => AccessibleInvalidState::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleInvalidState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_invalid_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleInvalidState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleInvalidState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleInvalidState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleProperty {
    Autocomplete,
    Description,
    HasPopup,
    KeyShortcuts,
    Label,
    Level,
    Modal,
    MultiLine,
    MultiSelectable,
    Orientation,
    Placeholder,
    ReadOnly,
    Required,
    RoleDescription,
    Sort,
    ValueMax,
    ValueMin,
    ValueNow,
    ValueText,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleProperty {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleProperty::{}",
            match *self {
                AccessibleProperty::Autocomplete => "Autocomplete",
                AccessibleProperty::Description => "Description",
                AccessibleProperty::HasPopup => "HasPopup",
                AccessibleProperty::KeyShortcuts => "KeyShortcuts",
                AccessibleProperty::Label => "Label",
                AccessibleProperty::Level => "Level",
                AccessibleProperty::Modal => "Modal",
                AccessibleProperty::MultiLine => "MultiLine",
                AccessibleProperty::MultiSelectable => "MultiSelectable",
                AccessibleProperty::Orientation => "Orientation",
                AccessibleProperty::Placeholder => "Placeholder",
                AccessibleProperty::ReadOnly => "ReadOnly",
                AccessibleProperty::Required => "Required",
                AccessibleProperty::RoleDescription => "RoleDescription",
                AccessibleProperty::Sort => "Sort",
                AccessibleProperty::ValueMax => "ValueMax",
                AccessibleProperty::ValueMin => "ValueMin",
                AccessibleProperty::ValueNow => "ValueNow",
                AccessibleProperty::ValueText => "ValueText",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleProperty {
    type GlibType = ffi::GtkAccessibleProperty;

    fn to_glib(&self) -> ffi::GtkAccessibleProperty {
        match *self {
            AccessibleProperty::Autocomplete => ffi::GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE,
            AccessibleProperty::Description => ffi::GTK_ACCESSIBLE_PROPERTY_DESCRIPTION,
            AccessibleProperty::HasPopup => ffi::GTK_ACCESSIBLE_PROPERTY_HAS_POPUP,
            AccessibleProperty::KeyShortcuts => ffi::GTK_ACCESSIBLE_PROPERTY_KEY_SHORTCUTS,
            AccessibleProperty::Label => ffi::GTK_ACCESSIBLE_PROPERTY_LABEL,
            AccessibleProperty::Level => ffi::GTK_ACCESSIBLE_PROPERTY_LEVEL,
            AccessibleProperty::Modal => ffi::GTK_ACCESSIBLE_PROPERTY_MODAL,
            AccessibleProperty::MultiLine => ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_LINE,
            AccessibleProperty::MultiSelectable => ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_SELECTABLE,
            AccessibleProperty::Orientation => ffi::GTK_ACCESSIBLE_PROPERTY_ORIENTATION,
            AccessibleProperty::Placeholder => ffi::GTK_ACCESSIBLE_PROPERTY_PLACEHOLDER,
            AccessibleProperty::ReadOnly => ffi::GTK_ACCESSIBLE_PROPERTY_READ_ONLY,
            AccessibleProperty::Required => ffi::GTK_ACCESSIBLE_PROPERTY_REQUIRED,
            AccessibleProperty::RoleDescription => ffi::GTK_ACCESSIBLE_PROPERTY_ROLE_DESCRIPTION,
            AccessibleProperty::Sort => ffi::GTK_ACCESSIBLE_PROPERTY_SORT,
            AccessibleProperty::ValueMax => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MAX,
            AccessibleProperty::ValueMin => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MIN,
            AccessibleProperty::ValueNow => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_NOW,
            AccessibleProperty::ValueText => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_TEXT,
            AccessibleProperty::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleProperty> for AccessibleProperty {
    fn from_glib(value: ffi::GtkAccessibleProperty) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleProperty::Autocomplete,
            1 => AccessibleProperty::Description,
            2 => AccessibleProperty::HasPopup,
            3 => AccessibleProperty::KeyShortcuts,
            4 => AccessibleProperty::Label,
            5 => AccessibleProperty::Level,
            6 => AccessibleProperty::Modal,
            7 => AccessibleProperty::MultiLine,
            8 => AccessibleProperty::MultiSelectable,
            9 => AccessibleProperty::Orientation,
            10 => AccessibleProperty::Placeholder,
            11 => AccessibleProperty::ReadOnly,
            12 => AccessibleProperty::Required,
            13 => AccessibleProperty::RoleDescription,
            14 => AccessibleProperty::Sort,
            15 => AccessibleProperty::ValueMax,
            16 => AccessibleProperty::ValueMin,
            17 => AccessibleProperty::ValueNow,
            18 => AccessibleProperty::ValueText,
            value => AccessibleProperty::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleProperty {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_property_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleProperty {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleProperty {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleProperty {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleRelation {
    ActiveDescendant,
    ColCount,
    ColIndex,
    ColIndexText,
    ColSpan,
    Controls,
    DescribedBy,
    Details,
    ErrorMessage,
    FlowTo,
    LabelledBy,
    Owns,
    PosInSet,
    RowCount,
    RowIndex,
    RowIndexText,
    RowSpan,
    SetSize,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleRelation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleRelation::{}",
            match *self {
                AccessibleRelation::ActiveDescendant => "ActiveDescendant",
                AccessibleRelation::ColCount => "ColCount",
                AccessibleRelation::ColIndex => "ColIndex",
                AccessibleRelation::ColIndexText => "ColIndexText",
                AccessibleRelation::ColSpan => "ColSpan",
                AccessibleRelation::Controls => "Controls",
                AccessibleRelation::DescribedBy => "DescribedBy",
                AccessibleRelation::Details => "Details",
                AccessibleRelation::ErrorMessage => "ErrorMessage",
                AccessibleRelation::FlowTo => "FlowTo",
                AccessibleRelation::LabelledBy => "LabelledBy",
                AccessibleRelation::Owns => "Owns",
                AccessibleRelation::PosInSet => "PosInSet",
                AccessibleRelation::RowCount => "RowCount",
                AccessibleRelation::RowIndex => "RowIndex",
                AccessibleRelation::RowIndexText => "RowIndexText",
                AccessibleRelation::RowSpan => "RowSpan",
                AccessibleRelation::SetSize => "SetSize",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleRelation {
    type GlibType = ffi::GtkAccessibleRelation;

    fn to_glib(&self) -> ffi::GtkAccessibleRelation {
        match *self {
            AccessibleRelation::ActiveDescendant => ffi::GTK_ACCESSIBLE_RELATION_ACTIVE_DESCENDANT,
            AccessibleRelation::ColCount => ffi::GTK_ACCESSIBLE_RELATION_COL_COUNT,
            AccessibleRelation::ColIndex => ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX,
            AccessibleRelation::ColIndexText => ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX_TEXT,
            AccessibleRelation::ColSpan => ffi::GTK_ACCESSIBLE_RELATION_COL_SPAN,
            AccessibleRelation::Controls => ffi::GTK_ACCESSIBLE_RELATION_CONTROLS,
            AccessibleRelation::DescribedBy => ffi::GTK_ACCESSIBLE_RELATION_DESCRIBED_BY,
            AccessibleRelation::Details => ffi::GTK_ACCESSIBLE_RELATION_DETAILS,
            AccessibleRelation::ErrorMessage => ffi::GTK_ACCESSIBLE_RELATION_ERROR_MESSAGE,
            AccessibleRelation::FlowTo => ffi::GTK_ACCESSIBLE_RELATION_FLOW_TO,
            AccessibleRelation::LabelledBy => ffi::GTK_ACCESSIBLE_RELATION_LABELLED_BY,
            AccessibleRelation::Owns => ffi::GTK_ACCESSIBLE_RELATION_OWNS,
            AccessibleRelation::PosInSet => ffi::GTK_ACCESSIBLE_RELATION_POS_IN_SET,
            AccessibleRelation::RowCount => ffi::GTK_ACCESSIBLE_RELATION_ROW_COUNT,
            AccessibleRelation::RowIndex => ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX,
            AccessibleRelation::RowIndexText => ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX_TEXT,
            AccessibleRelation::RowSpan => ffi::GTK_ACCESSIBLE_RELATION_ROW_SPAN,
            AccessibleRelation::SetSize => ffi::GTK_ACCESSIBLE_RELATION_SET_SIZE,
            AccessibleRelation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleRelation> for AccessibleRelation {
    fn from_glib(value: ffi::GtkAccessibleRelation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleRelation::ActiveDescendant,
            1 => AccessibleRelation::ColCount,
            2 => AccessibleRelation::ColIndex,
            3 => AccessibleRelation::ColIndexText,
            4 => AccessibleRelation::ColSpan,
            5 => AccessibleRelation::Controls,
            6 => AccessibleRelation::DescribedBy,
            7 => AccessibleRelation::Details,
            8 => AccessibleRelation::ErrorMessage,
            9 => AccessibleRelation::FlowTo,
            10 => AccessibleRelation::LabelledBy,
            11 => AccessibleRelation::Owns,
            12 => AccessibleRelation::PosInSet,
            13 => AccessibleRelation::RowCount,
            14 => AccessibleRelation::RowIndex,
            15 => AccessibleRelation::RowIndexText,
            16 => AccessibleRelation::RowSpan,
            17 => AccessibleRelation::SetSize,
            value => AccessibleRelation::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleRelation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_relation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleRelation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleRelation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleRelation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleRole {
    Alert,
    AlertDialog,
    Banner,
    Button,
    Caption,
    Cell,
    Checkbox,
    ColumnHeader,
    ComboBox,
    Command,
    Composite,
    Dialog,
    Document,
    Feed,
    Form,
    Generic,
    Grid,
    GridCell,
    Group,
    Heading,
    Img,
    Input,
    Label,
    Landmark,
    Legend,
    Link,
    List,
    ListBox,
    ListItem,
    Log,
    Main,
    Marquee,
    Math,
    Meter,
    Menu,
    MenuBar,
    MenuItem,
    MenuItemCheckbox,
    MenuItemRadio,
    Navigation,
    None,
    Note,
    Option,
    Presentation,
    ProgressBar,
    Radio,
    RadioGroup,
    Range,
    Region,
    Row,
    RowGroup,
    RowHeader,
    Scrollbar,
    Search,
    SearchBox,
    Section,
    SectionHead,
    Select,
    Separator,
    Slider,
    SpinButton,
    Status,
    Structure,
    Switch,
    Tab,
    Table,
    TabList,
    TabPanel,
    TextBox,
    Time,
    Timer,
    Toolbar,
    Tooltip,
    Tree,
    TreeGrid,
    TreeItem,
    Widget,
    Window,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleRole {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleRole::{}",
            match *self {
                AccessibleRole::Alert => "Alert",
                AccessibleRole::AlertDialog => "AlertDialog",
                AccessibleRole::Banner => "Banner",
                AccessibleRole::Button => "Button",
                AccessibleRole::Caption => "Caption",
                AccessibleRole::Cell => "Cell",
                AccessibleRole::Checkbox => "Checkbox",
                AccessibleRole::ColumnHeader => "ColumnHeader",
                AccessibleRole::ComboBox => "ComboBox",
                AccessibleRole::Command => "Command",
                AccessibleRole::Composite => "Composite",
                AccessibleRole::Dialog => "Dialog",
                AccessibleRole::Document => "Document",
                AccessibleRole::Feed => "Feed",
                AccessibleRole::Form => "Form",
                AccessibleRole::Generic => "Generic",
                AccessibleRole::Grid => "Grid",
                AccessibleRole::GridCell => "GridCell",
                AccessibleRole::Group => "Group",
                AccessibleRole::Heading => "Heading",
                AccessibleRole::Img => "Img",
                AccessibleRole::Input => "Input",
                AccessibleRole::Label => "Label",
                AccessibleRole::Landmark => "Landmark",
                AccessibleRole::Legend => "Legend",
                AccessibleRole::Link => "Link",
                AccessibleRole::List => "List",
                AccessibleRole::ListBox => "ListBox",
                AccessibleRole::ListItem => "ListItem",
                AccessibleRole::Log => "Log",
                AccessibleRole::Main => "Main",
                AccessibleRole::Marquee => "Marquee",
                AccessibleRole::Math => "Math",
                AccessibleRole::Meter => "Meter",
                AccessibleRole::Menu => "Menu",
                AccessibleRole::MenuBar => "MenuBar",
                AccessibleRole::MenuItem => "MenuItem",
                AccessibleRole::MenuItemCheckbox => "MenuItemCheckbox",
                AccessibleRole::MenuItemRadio => "MenuItemRadio",
                AccessibleRole::Navigation => "Navigation",
                AccessibleRole::None => "None",
                AccessibleRole::Note => "Note",
                AccessibleRole::Option => "Option",
                AccessibleRole::Presentation => "Presentation",
                AccessibleRole::ProgressBar => "ProgressBar",
                AccessibleRole::Radio => "Radio",
                AccessibleRole::RadioGroup => "RadioGroup",
                AccessibleRole::Range => "Range",
                AccessibleRole::Region => "Region",
                AccessibleRole::Row => "Row",
                AccessibleRole::RowGroup => "RowGroup",
                AccessibleRole::RowHeader => "RowHeader",
                AccessibleRole::Scrollbar => "Scrollbar",
                AccessibleRole::Search => "Search",
                AccessibleRole::SearchBox => "SearchBox",
                AccessibleRole::Section => "Section",
                AccessibleRole::SectionHead => "SectionHead",
                AccessibleRole::Select => "Select",
                AccessibleRole::Separator => "Separator",
                AccessibleRole::Slider => "Slider",
                AccessibleRole::SpinButton => "SpinButton",
                AccessibleRole::Status => "Status",
                AccessibleRole::Structure => "Structure",
                AccessibleRole::Switch => "Switch",
                AccessibleRole::Tab => "Tab",
                AccessibleRole::Table => "Table",
                AccessibleRole::TabList => "TabList",
                AccessibleRole::TabPanel => "TabPanel",
                AccessibleRole::TextBox => "TextBox",
                AccessibleRole::Time => "Time",
                AccessibleRole::Timer => "Timer",
                AccessibleRole::Toolbar => "Toolbar",
                AccessibleRole::Tooltip => "Tooltip",
                AccessibleRole::Tree => "Tree",
                AccessibleRole::TreeGrid => "TreeGrid",
                AccessibleRole::TreeItem => "TreeItem",
                AccessibleRole::Widget => "Widget",
                AccessibleRole::Window => "Window",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleRole {
    type GlibType = ffi::GtkAccessibleRole;

    fn to_glib(&self) -> ffi::GtkAccessibleRole {
        match *self {
            AccessibleRole::Alert => ffi::GTK_ACCESSIBLE_ROLE_ALERT,
            AccessibleRole::AlertDialog => ffi::GTK_ACCESSIBLE_ROLE_ALERT_DIALOG,
            AccessibleRole::Banner => ffi::GTK_ACCESSIBLE_ROLE_BANNER,
            AccessibleRole::Button => ffi::GTK_ACCESSIBLE_ROLE_BUTTON,
            AccessibleRole::Caption => ffi::GTK_ACCESSIBLE_ROLE_CAPTION,
            AccessibleRole::Cell => ffi::GTK_ACCESSIBLE_ROLE_CELL,
            AccessibleRole::Checkbox => ffi::GTK_ACCESSIBLE_ROLE_CHECKBOX,
            AccessibleRole::ColumnHeader => ffi::GTK_ACCESSIBLE_ROLE_COLUMN_HEADER,
            AccessibleRole::ComboBox => ffi::GTK_ACCESSIBLE_ROLE_COMBO_BOX,
            AccessibleRole::Command => ffi::GTK_ACCESSIBLE_ROLE_COMMAND,
            AccessibleRole::Composite => ffi::GTK_ACCESSIBLE_ROLE_COMPOSITE,
            AccessibleRole::Dialog => ffi::GTK_ACCESSIBLE_ROLE_DIALOG,
            AccessibleRole::Document => ffi::GTK_ACCESSIBLE_ROLE_DOCUMENT,
            AccessibleRole::Feed => ffi::GTK_ACCESSIBLE_ROLE_FEED,
            AccessibleRole::Form => ffi::GTK_ACCESSIBLE_ROLE_FORM,
            AccessibleRole::Generic => ffi::GTK_ACCESSIBLE_ROLE_GENERIC,
            AccessibleRole::Grid => ffi::GTK_ACCESSIBLE_ROLE_GRID,
            AccessibleRole::GridCell => ffi::GTK_ACCESSIBLE_ROLE_GRID_CELL,
            AccessibleRole::Group => ffi::GTK_ACCESSIBLE_ROLE_GROUP,
            AccessibleRole::Heading => ffi::GTK_ACCESSIBLE_ROLE_HEADING,
            AccessibleRole::Img => ffi::GTK_ACCESSIBLE_ROLE_IMG,
            AccessibleRole::Input => ffi::GTK_ACCESSIBLE_ROLE_INPUT,
            AccessibleRole::Label => ffi::GTK_ACCESSIBLE_ROLE_LABEL,
            AccessibleRole::Landmark => ffi::GTK_ACCESSIBLE_ROLE_LANDMARK,
            AccessibleRole::Legend => ffi::GTK_ACCESSIBLE_ROLE_LEGEND,
            AccessibleRole::Link => ffi::GTK_ACCESSIBLE_ROLE_LINK,
            AccessibleRole::List => ffi::GTK_ACCESSIBLE_ROLE_LIST,
            AccessibleRole::ListBox => ffi::GTK_ACCESSIBLE_ROLE_LIST_BOX,
            AccessibleRole::ListItem => ffi::GTK_ACCESSIBLE_ROLE_LIST_ITEM,
            AccessibleRole::Log => ffi::GTK_ACCESSIBLE_ROLE_LOG,
            AccessibleRole::Main => ffi::GTK_ACCESSIBLE_ROLE_MAIN,
            AccessibleRole::Marquee => ffi::GTK_ACCESSIBLE_ROLE_MARQUEE,
            AccessibleRole::Math => ffi::GTK_ACCESSIBLE_ROLE_MATH,
            AccessibleRole::Meter => ffi::GTK_ACCESSIBLE_ROLE_METER,
            AccessibleRole::Menu => ffi::GTK_ACCESSIBLE_ROLE_MENU,
            AccessibleRole::MenuBar => ffi::GTK_ACCESSIBLE_ROLE_MENU_BAR,
            AccessibleRole::MenuItem => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM,
            AccessibleRole::MenuItemCheckbox => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX,
            AccessibleRole::MenuItemRadio => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO,
            AccessibleRole::Navigation => ffi::GTK_ACCESSIBLE_ROLE_NAVIGATION,
            AccessibleRole::None => ffi::GTK_ACCESSIBLE_ROLE_NONE,
            AccessibleRole::Note => ffi::GTK_ACCESSIBLE_ROLE_NOTE,
            AccessibleRole::Option => ffi::GTK_ACCESSIBLE_ROLE_OPTION,
            AccessibleRole::Presentation => ffi::GTK_ACCESSIBLE_ROLE_PRESENTATION,
            AccessibleRole::ProgressBar => ffi::GTK_ACCESSIBLE_ROLE_PROGRESS_BAR,
            AccessibleRole::Radio => ffi::GTK_ACCESSIBLE_ROLE_RADIO,
            AccessibleRole::RadioGroup => ffi::GTK_ACCESSIBLE_ROLE_RADIO_GROUP,
            AccessibleRole::Range => ffi::GTK_ACCESSIBLE_ROLE_RANGE,
            AccessibleRole::Region => ffi::GTK_ACCESSIBLE_ROLE_REGION,
            AccessibleRole::Row => ffi::GTK_ACCESSIBLE_ROLE_ROW,
            AccessibleRole::RowGroup => ffi::GTK_ACCESSIBLE_ROLE_ROW_GROUP,
            AccessibleRole::RowHeader => ffi::GTK_ACCESSIBLE_ROLE_ROW_HEADER,
            AccessibleRole::Scrollbar => ffi::GTK_ACCESSIBLE_ROLE_SCROLLBAR,
            AccessibleRole::Search => ffi::GTK_ACCESSIBLE_ROLE_SEARCH,
            AccessibleRole::SearchBox => ffi::GTK_ACCESSIBLE_ROLE_SEARCH_BOX,
            AccessibleRole::Section => ffi::GTK_ACCESSIBLE_ROLE_SECTION,
            AccessibleRole::SectionHead => ffi::GTK_ACCESSIBLE_ROLE_SECTION_HEAD,
            AccessibleRole::Select => ffi::GTK_ACCESSIBLE_ROLE_SELECT,
            AccessibleRole::Separator => ffi::GTK_ACCESSIBLE_ROLE_SEPARATOR,
            AccessibleRole::Slider => ffi::GTK_ACCESSIBLE_ROLE_SLIDER,
            AccessibleRole::SpinButton => ffi::GTK_ACCESSIBLE_ROLE_SPIN_BUTTON,
            AccessibleRole::Status => ffi::GTK_ACCESSIBLE_ROLE_STATUS,
            AccessibleRole::Structure => ffi::GTK_ACCESSIBLE_ROLE_STRUCTURE,
            AccessibleRole::Switch => ffi::GTK_ACCESSIBLE_ROLE_SWITCH,
            AccessibleRole::Tab => ffi::GTK_ACCESSIBLE_ROLE_TAB,
            AccessibleRole::Table => ffi::GTK_ACCESSIBLE_ROLE_TABLE,
            AccessibleRole::TabList => ffi::GTK_ACCESSIBLE_ROLE_TAB_LIST,
            AccessibleRole::TabPanel => ffi::GTK_ACCESSIBLE_ROLE_TAB_PANEL,
            AccessibleRole::TextBox => ffi::GTK_ACCESSIBLE_ROLE_TEXT_BOX,
            AccessibleRole::Time => ffi::GTK_ACCESSIBLE_ROLE_TIME,
            AccessibleRole::Timer => ffi::GTK_ACCESSIBLE_ROLE_TIMER,
            AccessibleRole::Toolbar => ffi::GTK_ACCESSIBLE_ROLE_TOOLBAR,
            AccessibleRole::Tooltip => ffi::GTK_ACCESSIBLE_ROLE_TOOLTIP,
            AccessibleRole::Tree => ffi::GTK_ACCESSIBLE_ROLE_TREE,
            AccessibleRole::TreeGrid => ffi::GTK_ACCESSIBLE_ROLE_TREE_GRID,
            AccessibleRole::TreeItem => ffi::GTK_ACCESSIBLE_ROLE_TREE_ITEM,
            AccessibleRole::Widget => ffi::GTK_ACCESSIBLE_ROLE_WIDGET,
            AccessibleRole::Window => ffi::GTK_ACCESSIBLE_ROLE_WINDOW,
            AccessibleRole::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleRole> for AccessibleRole {
    fn from_glib(value: ffi::GtkAccessibleRole) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleRole::Alert,
            1 => AccessibleRole::AlertDialog,
            2 => AccessibleRole::Banner,
            3 => AccessibleRole::Button,
            4 => AccessibleRole::Caption,
            5 => AccessibleRole::Cell,
            6 => AccessibleRole::Checkbox,
            7 => AccessibleRole::ColumnHeader,
            8 => AccessibleRole::ComboBox,
            9 => AccessibleRole::Command,
            10 => AccessibleRole::Composite,
            11 => AccessibleRole::Dialog,
            12 => AccessibleRole::Document,
            13 => AccessibleRole::Feed,
            14 => AccessibleRole::Form,
            15 => AccessibleRole::Generic,
            16 => AccessibleRole::Grid,
            17 => AccessibleRole::GridCell,
            18 => AccessibleRole::Group,
            19 => AccessibleRole::Heading,
            20 => AccessibleRole::Img,
            21 => AccessibleRole::Input,
            22 => AccessibleRole::Label,
            23 => AccessibleRole::Landmark,
            24 => AccessibleRole::Legend,
            25 => AccessibleRole::Link,
            26 => AccessibleRole::List,
            27 => AccessibleRole::ListBox,
            28 => AccessibleRole::ListItem,
            29 => AccessibleRole::Log,
            30 => AccessibleRole::Main,
            31 => AccessibleRole::Marquee,
            32 => AccessibleRole::Math,
            33 => AccessibleRole::Meter,
            34 => AccessibleRole::Menu,
            35 => AccessibleRole::MenuBar,
            36 => AccessibleRole::MenuItem,
            37 => AccessibleRole::MenuItemCheckbox,
            38 => AccessibleRole::MenuItemRadio,
            39 => AccessibleRole::Navigation,
            40 => AccessibleRole::None,
            41 => AccessibleRole::Note,
            42 => AccessibleRole::Option,
            43 => AccessibleRole::Presentation,
            44 => AccessibleRole::ProgressBar,
            45 => AccessibleRole::Radio,
            46 => AccessibleRole::RadioGroup,
            47 => AccessibleRole::Range,
            48 => AccessibleRole::Region,
            49 => AccessibleRole::Row,
            50 => AccessibleRole::RowGroup,
            51 => AccessibleRole::RowHeader,
            52 => AccessibleRole::Scrollbar,
            53 => AccessibleRole::Search,
            54 => AccessibleRole::SearchBox,
            55 => AccessibleRole::Section,
            56 => AccessibleRole::SectionHead,
            57 => AccessibleRole::Select,
            58 => AccessibleRole::Separator,
            59 => AccessibleRole::Slider,
            60 => AccessibleRole::SpinButton,
            61 => AccessibleRole::Status,
            62 => AccessibleRole::Structure,
            63 => AccessibleRole::Switch,
            64 => AccessibleRole::Tab,
            65 => AccessibleRole::Table,
            66 => AccessibleRole::TabList,
            67 => AccessibleRole::TabPanel,
            68 => AccessibleRole::TextBox,
            69 => AccessibleRole::Time,
            70 => AccessibleRole::Timer,
            71 => AccessibleRole::Toolbar,
            72 => AccessibleRole::Tooltip,
            73 => AccessibleRole::Tree,
            74 => AccessibleRole::TreeGrid,
            75 => AccessibleRole::TreeItem,
            76 => AccessibleRole::Widget,
            77 => AccessibleRole::Window,
            value => AccessibleRole::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleRole {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_role_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleRole {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleRole {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleRole {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleSort {
    None,
    Ascending,
    Descending,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleSort {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleSort::{}",
            match *self {
                AccessibleSort::None => "None",
                AccessibleSort::Ascending => "Ascending",
                AccessibleSort::Descending => "Descending",
                AccessibleSort::Other => "Other",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleSort {
    type GlibType = ffi::GtkAccessibleSort;

    fn to_glib(&self) -> ffi::GtkAccessibleSort {
        match *self {
            AccessibleSort::None => ffi::GTK_ACCESSIBLE_SORT_NONE,
            AccessibleSort::Ascending => ffi::GTK_ACCESSIBLE_SORT_ASCENDING,
            AccessibleSort::Descending => ffi::GTK_ACCESSIBLE_SORT_DESCENDING,
            AccessibleSort::Other => ffi::GTK_ACCESSIBLE_SORT_OTHER,
            AccessibleSort::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleSort> for AccessibleSort {
    fn from_glib(value: ffi::GtkAccessibleSort) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleSort::None,
            1 => AccessibleSort::Ascending,
            2 => AccessibleSort::Descending,
            3 => AccessibleSort::Other,
            value => AccessibleSort::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleSort {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_sort_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleSort {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleSort {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleSort {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleState {
    Busy,
    Checked,
    Disabled,
    Expanded,
    Hidden,
    Invalid,
    Pressed,
    Selected,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleState::{}",
            match *self {
                AccessibleState::Busy => "Busy",
                AccessibleState::Checked => "Checked",
                AccessibleState::Disabled => "Disabled",
                AccessibleState::Expanded => "Expanded",
                AccessibleState::Hidden => "Hidden",
                AccessibleState::Invalid => "Invalid",
                AccessibleState::Pressed => "Pressed",
                AccessibleState::Selected => "Selected",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleState {
    type GlibType = ffi::GtkAccessibleState;

    fn to_glib(&self) -> ffi::GtkAccessibleState {
        match *self {
            AccessibleState::Busy => ffi::GTK_ACCESSIBLE_STATE_BUSY,
            AccessibleState::Checked => ffi::GTK_ACCESSIBLE_STATE_CHECKED,
            AccessibleState::Disabled => ffi::GTK_ACCESSIBLE_STATE_DISABLED,
            AccessibleState::Expanded => ffi::GTK_ACCESSIBLE_STATE_EXPANDED,
            AccessibleState::Hidden => ffi::GTK_ACCESSIBLE_STATE_HIDDEN,
            AccessibleState::Invalid => ffi::GTK_ACCESSIBLE_STATE_INVALID,
            AccessibleState::Pressed => ffi::GTK_ACCESSIBLE_STATE_PRESSED,
            AccessibleState::Selected => ffi::GTK_ACCESSIBLE_STATE_SELECTED,
            AccessibleState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleState> for AccessibleState {
    fn from_glib(value: ffi::GtkAccessibleState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleState::Busy,
            1 => AccessibleState::Checked,
            2 => AccessibleState::Disabled,
            3 => AccessibleState::Expanded,
            4 => AccessibleState::Hidden,
            5 => AccessibleState::Invalid,
            6 => AccessibleState::Pressed,
            7 => AccessibleState::Selected,
            value => AccessibleState::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AccessibleTristate {
    False,
    True,
    Mixed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AccessibleTristate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AccessibleTristate::{}",
            match *self {
                AccessibleTristate::False => "False",
                AccessibleTristate::True => "True",
                AccessibleTristate::Mixed => "Mixed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AccessibleTristate {
    type GlibType = ffi::GtkAccessibleTristate;

    fn to_glib(&self) -> ffi::GtkAccessibleTristate {
        match *self {
            AccessibleTristate::False => ffi::GTK_ACCESSIBLE_TRISTATE_FALSE,
            AccessibleTristate::True => ffi::GTK_ACCESSIBLE_TRISTATE_TRUE,
            AccessibleTristate::Mixed => ffi::GTK_ACCESSIBLE_TRISTATE_MIXED,
            AccessibleTristate::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleTristate> for AccessibleTristate {
    fn from_glib(value: ffi::GtkAccessibleTristate) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AccessibleTristate::False,
            1 => AccessibleTristate::True,
            2 => AccessibleTristate::Mixed,
            value => AccessibleTristate::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleTristate {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accessible_tristate_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AccessibleTristate {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AccessibleTristate {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AccessibleTristate {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Align {
    Fill,
    Start,
    End,
    Center,
    Baseline,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Align {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Align::{}",
            match *self {
                Align::Fill => "Fill",
                Align::Start => "Start",
                Align::End => "End",
                Align::Center => "Center",
                Align::Baseline => "Baseline",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Align {
    type GlibType = ffi::GtkAlign;

    fn to_glib(&self) -> ffi::GtkAlign {
        match *self {
            Align::Fill => ffi::GTK_ALIGN_FILL,
            Align::Start => ffi::GTK_ALIGN_START,
            Align::End => ffi::GTK_ALIGN_END,
            Align::Center => ffi::GTK_ALIGN_CENTER,
            Align::Baseline => ffi::GTK_ALIGN_BASELINE,
            Align::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAlign> for Align {
    fn from_glib(value: ffi::GtkAlign) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Align::Fill,
            1 => Align::Start,
            2 => Align::End,
            3 => Align::Center,
            4 => Align::Baseline,
            value => Align::__Unknown(value),
        }
    }
}

impl StaticType for Align {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_align_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Align {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Align {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Align {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ArrowType {
    Up,
    Down,
    Left,
    Right,
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ArrowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ArrowType::{}",
            match *self {
                ArrowType::Up => "Up",
                ArrowType::Down => "Down",
                ArrowType::Left => "Left",
                ArrowType::Right => "Right",
                ArrowType::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ArrowType {
    type GlibType = ffi::GtkArrowType;

    fn to_glib(&self) -> ffi::GtkArrowType {
        match *self {
            ArrowType::Up => ffi::GTK_ARROW_UP,
            ArrowType::Down => ffi::GTK_ARROW_DOWN,
            ArrowType::Left => ffi::GTK_ARROW_LEFT,
            ArrowType::Right => ffi::GTK_ARROW_RIGHT,
            ArrowType::None => ffi::GTK_ARROW_NONE,
            ArrowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkArrowType> for ArrowType {
    fn from_glib(value: ffi::GtkArrowType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ArrowType::Up,
            1 => ArrowType::Down,
            2 => ArrowType::Left,
            3 => ArrowType::Right,
            4 => ArrowType::None,
            value => ArrowType::__Unknown(value),
        }
    }
}

impl StaticType for ArrowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_arrow_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ArrowType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ArrowType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ArrowType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AssistantPageType {
    Content,
    Intro,
    Confirm,
    Summary,
    Progress,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AssistantPageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AssistantPageType::{}",
            match *self {
                AssistantPageType::Content => "Content",
                AssistantPageType::Intro => "Intro",
                AssistantPageType::Confirm => "Confirm",
                AssistantPageType::Summary => "Summary",
                AssistantPageType::Progress => "Progress",
                AssistantPageType::Custom => "Custom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AssistantPageType {
    type GlibType = ffi::GtkAssistantPageType;

    fn to_glib(&self) -> ffi::GtkAssistantPageType {
        match *self {
            AssistantPageType::Content => ffi::GTK_ASSISTANT_PAGE_CONTENT,
            AssistantPageType::Intro => ffi::GTK_ASSISTANT_PAGE_INTRO,
            AssistantPageType::Confirm => ffi::GTK_ASSISTANT_PAGE_CONFIRM,
            AssistantPageType::Summary => ffi::GTK_ASSISTANT_PAGE_SUMMARY,
            AssistantPageType::Progress => ffi::GTK_ASSISTANT_PAGE_PROGRESS,
            AssistantPageType::Custom => ffi::GTK_ASSISTANT_PAGE_CUSTOM,
            AssistantPageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAssistantPageType> for AssistantPageType {
    fn from_glib(value: ffi::GtkAssistantPageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AssistantPageType::Content,
            1 => AssistantPageType::Intro,
            2 => AssistantPageType::Confirm,
            3 => AssistantPageType::Summary,
            4 => AssistantPageType::Progress,
            5 => AssistantPageType::Custom,
            value => AssistantPageType::__Unknown(value),
        }
    }
}

impl StaticType for AssistantPageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_assistant_page_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AssistantPageType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AssistantPageType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AssistantPageType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BaselinePosition {
    Top,
    Center,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BaselinePosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BaselinePosition::{}",
            match *self {
                BaselinePosition::Top => "Top",
                BaselinePosition::Center => "Center",
                BaselinePosition::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BaselinePosition {
    type GlibType = ffi::GtkBaselinePosition;

    fn to_glib(&self) -> ffi::GtkBaselinePosition {
        match *self {
            BaselinePosition::Top => ffi::GTK_BASELINE_POSITION_TOP,
            BaselinePosition::Center => ffi::GTK_BASELINE_POSITION_CENTER,
            BaselinePosition::Bottom => ffi::GTK_BASELINE_POSITION_BOTTOM,
            BaselinePosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBaselinePosition> for BaselinePosition {
    fn from_glib(value: ffi::GtkBaselinePosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BaselinePosition::Top,
            1 => BaselinePosition::Center,
            2 => BaselinePosition::Bottom,
            value => BaselinePosition::__Unknown(value),
        }
    }
}

impl StaticType for BaselinePosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_baseline_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BaselinePosition {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BaselinePosition {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BaselinePosition {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BorderStyle {
    None,
    Hidden,
    Solid,
    Inset,
    Outset,
    Dotted,
    Dashed,
    Double,
    Groove,
    Ridge,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BorderStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BorderStyle::{}",
            match *self {
                BorderStyle::None => "None",
                BorderStyle::Hidden => "Hidden",
                BorderStyle::Solid => "Solid",
                BorderStyle::Inset => "Inset",
                BorderStyle::Outset => "Outset",
                BorderStyle::Dotted => "Dotted",
                BorderStyle::Dashed => "Dashed",
                BorderStyle::Double => "Double",
                BorderStyle::Groove => "Groove",
                BorderStyle::Ridge => "Ridge",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BorderStyle {
    type GlibType = ffi::GtkBorderStyle;

    fn to_glib(&self) -> ffi::GtkBorderStyle {
        match *self {
            BorderStyle::None => ffi::GTK_BORDER_STYLE_NONE,
            BorderStyle::Hidden => ffi::GTK_BORDER_STYLE_HIDDEN,
            BorderStyle::Solid => ffi::GTK_BORDER_STYLE_SOLID,
            BorderStyle::Inset => ffi::GTK_BORDER_STYLE_INSET,
            BorderStyle::Outset => ffi::GTK_BORDER_STYLE_OUTSET,
            BorderStyle::Dotted => ffi::GTK_BORDER_STYLE_DOTTED,
            BorderStyle::Dashed => ffi::GTK_BORDER_STYLE_DASHED,
            BorderStyle::Double => ffi::GTK_BORDER_STYLE_DOUBLE,
            BorderStyle::Groove => ffi::GTK_BORDER_STYLE_GROOVE,
            BorderStyle::Ridge => ffi::GTK_BORDER_STYLE_RIDGE,
            BorderStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBorderStyle> for BorderStyle {
    fn from_glib(value: ffi::GtkBorderStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BorderStyle::None,
            1 => BorderStyle::Hidden,
            2 => BorderStyle::Solid,
            3 => BorderStyle::Inset,
            4 => BorderStyle::Outset,
            5 => BorderStyle::Dotted,
            6 => BorderStyle::Dashed,
            7 => BorderStyle::Double,
            8 => BorderStyle::Groove,
            9 => BorderStyle::Ridge,
            value => BorderStyle::__Unknown(value),
        }
    }
}

impl StaticType for BorderStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_border_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BorderStyle {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BorderStyle {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BorderStyle {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BuilderError {
    InvalidTypeFunction,
    UnhandledTag,
    MissingAttribute,
    InvalidAttribute,
    InvalidTag,
    MissingPropertyValue,
    InvalidValue,
    VersionMismatch,
    DuplicateId,
    ObjectTypeRefused,
    TemplateMismatch,
    InvalidProperty,
    InvalidSignal,
    InvalidId,
    InvalidFunction,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BuilderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BuilderError::{}",
            match *self {
                BuilderError::InvalidTypeFunction => "InvalidTypeFunction",
                BuilderError::UnhandledTag => "UnhandledTag",
                BuilderError::MissingAttribute => "MissingAttribute",
                BuilderError::InvalidAttribute => "InvalidAttribute",
                BuilderError::InvalidTag => "InvalidTag",
                BuilderError::MissingPropertyValue => "MissingPropertyValue",
                BuilderError::InvalidValue => "InvalidValue",
                BuilderError::VersionMismatch => "VersionMismatch",
                BuilderError::DuplicateId => "DuplicateId",
                BuilderError::ObjectTypeRefused => "ObjectTypeRefused",
                BuilderError::TemplateMismatch => "TemplateMismatch",
                BuilderError::InvalidProperty => "InvalidProperty",
                BuilderError::InvalidSignal => "InvalidSignal",
                BuilderError::InvalidId => "InvalidId",
                BuilderError::InvalidFunction => "InvalidFunction",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BuilderError {
    type GlibType = ffi::GtkBuilderError;

    fn to_glib(&self) -> ffi::GtkBuilderError {
        match *self {
            BuilderError::InvalidTypeFunction => ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION,
            BuilderError::UnhandledTag => ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG,
            BuilderError::MissingAttribute => ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE,
            BuilderError::InvalidAttribute => ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE,
            BuilderError::InvalidTag => ffi::GTK_BUILDER_ERROR_INVALID_TAG,
            BuilderError::MissingPropertyValue => ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE,
            BuilderError::InvalidValue => ffi::GTK_BUILDER_ERROR_INVALID_VALUE,
            BuilderError::VersionMismatch => ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH,
            BuilderError::DuplicateId => ffi::GTK_BUILDER_ERROR_DUPLICATE_ID,
            BuilderError::ObjectTypeRefused => ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED,
            BuilderError::TemplateMismatch => ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH,
            BuilderError::InvalidProperty => ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY,
            BuilderError::InvalidSignal => ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL,
            BuilderError::InvalidId => ffi::GTK_BUILDER_ERROR_INVALID_ID,
            BuilderError::InvalidFunction => ffi::GTK_BUILDER_ERROR_INVALID_FUNCTION,
            BuilderError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderError> for BuilderError {
    fn from_glib(value: ffi::GtkBuilderError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BuilderError::InvalidTypeFunction,
            1 => BuilderError::UnhandledTag,
            2 => BuilderError::MissingAttribute,
            3 => BuilderError::InvalidAttribute,
            4 => BuilderError::InvalidTag,
            5 => BuilderError::MissingPropertyValue,
            6 => BuilderError::InvalidValue,
            7 => BuilderError::VersionMismatch,
            8 => BuilderError::DuplicateId,
            9 => BuilderError::ObjectTypeRefused,
            10 => BuilderError::TemplateMismatch,
            11 => BuilderError::InvalidProperty,
            12 => BuilderError::InvalidSignal,
            13 => BuilderError::InvalidId,
            14 => BuilderError::InvalidFunction,
            value => BuilderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for BuilderError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_builder_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(BuilderError::InvalidTypeFunction),
            1 => Some(BuilderError::UnhandledTag),
            2 => Some(BuilderError::MissingAttribute),
            3 => Some(BuilderError::InvalidAttribute),
            4 => Some(BuilderError::InvalidTag),
            5 => Some(BuilderError::MissingPropertyValue),
            6 => Some(BuilderError::InvalidValue),
            7 => Some(BuilderError::VersionMismatch),
            8 => Some(BuilderError::DuplicateId),
            9 => Some(BuilderError::ObjectTypeRefused),
            10 => Some(BuilderError::TemplateMismatch),
            11 => Some(BuilderError::InvalidProperty),
            12 => Some(BuilderError::InvalidSignal),
            13 => Some(BuilderError::InvalidId),
            14 => Some(BuilderError::InvalidFunction),
            value => Some(BuilderError::__Unknown(value)),
        }
    }
}

impl StaticType for BuilderError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_builder_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BuilderError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BuilderError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BuilderError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ButtonsType {
    None,
    Ok,
    Close,
    Cancel,
    YesNo,
    OkCancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ButtonsType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ButtonsType::{}",
            match *self {
                ButtonsType::None => "None",
                ButtonsType::Ok => "Ok",
                ButtonsType::Close => "Close",
                ButtonsType::Cancel => "Cancel",
                ButtonsType::YesNo => "YesNo",
                ButtonsType::OkCancel => "OkCancel",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ButtonsType {
    type GlibType = ffi::GtkButtonsType;

    fn to_glib(&self) -> ffi::GtkButtonsType {
        match *self {
            ButtonsType::None => ffi::GTK_BUTTONS_NONE,
            ButtonsType::Ok => ffi::GTK_BUTTONS_OK,
            ButtonsType::Close => ffi::GTK_BUTTONS_CLOSE,
            ButtonsType::Cancel => ffi::GTK_BUTTONS_CANCEL,
            ButtonsType::YesNo => ffi::GTK_BUTTONS_YES_NO,
            ButtonsType::OkCancel => ffi::GTK_BUTTONS_OK_CANCEL,
            ButtonsType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonsType> for ButtonsType {
    fn from_glib(value: ffi::GtkButtonsType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ButtonsType::None,
            1 => ButtonsType::Ok,
            2 => ButtonsType::Close,
            3 => ButtonsType::Cancel,
            4 => ButtonsType::YesNo,
            5 => ButtonsType::OkCancel,
            value => ButtonsType::__Unknown(value),
        }
    }
}

impl StaticType for ButtonsType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_buttons_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ButtonsType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ButtonsType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ButtonsType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CellRendererAccelMode {
    Gtk,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CellRendererAccelMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CellRendererAccelMode::{}",
            match *self {
                CellRendererAccelMode::Gtk => "Gtk",
                CellRendererAccelMode::Other => "Other",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CellRendererAccelMode {
    type GlibType = ffi::GtkCellRendererAccelMode;

    fn to_glib(&self) -> ffi::GtkCellRendererAccelMode {
        match *self {
            CellRendererAccelMode::Gtk => ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK,
            CellRendererAccelMode::Other => ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
            CellRendererAccelMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererAccelMode> for CellRendererAccelMode {
    fn from_glib(value: ffi::GtkCellRendererAccelMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CellRendererAccelMode::Gtk,
            1 => CellRendererAccelMode::Other,
            value => CellRendererAccelMode::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererAccelMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_accel_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CellRendererAccelMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CellRendererAccelMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CellRendererAccelMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CellRendererMode {
    Inert,
    Activatable,
    Editable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CellRendererMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CellRendererMode::{}",
            match *self {
                CellRendererMode::Inert => "Inert",
                CellRendererMode::Activatable => "Activatable",
                CellRendererMode::Editable => "Editable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CellRendererMode {
    type GlibType = ffi::GtkCellRendererMode;

    fn to_glib(&self) -> ffi::GtkCellRendererMode {
        match *self {
            CellRendererMode::Inert => ffi::GTK_CELL_RENDERER_MODE_INERT,
            CellRendererMode::Activatable => ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE,
            CellRendererMode::Editable => ffi::GTK_CELL_RENDERER_MODE_EDITABLE,
            CellRendererMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererMode> for CellRendererMode {
    fn from_glib(value: ffi::GtkCellRendererMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CellRendererMode::Inert,
            1 => CellRendererMode::Activatable,
            2 => CellRendererMode::Editable,
            value => CellRendererMode::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CellRendererMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CellRendererMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CellRendererMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConstraintAttribute {
    None,
    Left,
    Right,
    Top,
    Bottom,
    Start,
    End,
    Width,
    Height,
    CenterX,
    CenterY,
    Baseline,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConstraintAttribute {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConstraintAttribute::{}",
            match *self {
                ConstraintAttribute::None => "None",
                ConstraintAttribute::Left => "Left",
                ConstraintAttribute::Right => "Right",
                ConstraintAttribute::Top => "Top",
                ConstraintAttribute::Bottom => "Bottom",
                ConstraintAttribute::Start => "Start",
                ConstraintAttribute::End => "End",
                ConstraintAttribute::Width => "Width",
                ConstraintAttribute::Height => "Height",
                ConstraintAttribute::CenterX => "CenterX",
                ConstraintAttribute::CenterY => "CenterY",
                ConstraintAttribute::Baseline => "Baseline",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConstraintAttribute {
    type GlibType = ffi::GtkConstraintAttribute;

    fn to_glib(&self) -> ffi::GtkConstraintAttribute {
        match *self {
            ConstraintAttribute::None => ffi::GTK_CONSTRAINT_ATTRIBUTE_NONE,
            ConstraintAttribute::Left => ffi::GTK_CONSTRAINT_ATTRIBUTE_LEFT,
            ConstraintAttribute::Right => ffi::GTK_CONSTRAINT_ATTRIBUTE_RIGHT,
            ConstraintAttribute::Top => ffi::GTK_CONSTRAINT_ATTRIBUTE_TOP,
            ConstraintAttribute::Bottom => ffi::GTK_CONSTRAINT_ATTRIBUTE_BOTTOM,
            ConstraintAttribute::Start => ffi::GTK_CONSTRAINT_ATTRIBUTE_START,
            ConstraintAttribute::End => ffi::GTK_CONSTRAINT_ATTRIBUTE_END,
            ConstraintAttribute::Width => ffi::GTK_CONSTRAINT_ATTRIBUTE_WIDTH,
            ConstraintAttribute::Height => ffi::GTK_CONSTRAINT_ATTRIBUTE_HEIGHT,
            ConstraintAttribute::CenterX => ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_X,
            ConstraintAttribute::CenterY => ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_Y,
            ConstraintAttribute::Baseline => ffi::GTK_CONSTRAINT_ATTRIBUTE_BASELINE,
            ConstraintAttribute::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintAttribute> for ConstraintAttribute {
    fn from_glib(value: ffi::GtkConstraintAttribute) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ConstraintAttribute::None,
            1 => ConstraintAttribute::Left,
            2 => ConstraintAttribute::Right,
            3 => ConstraintAttribute::Top,
            4 => ConstraintAttribute::Bottom,
            5 => ConstraintAttribute::Start,
            6 => ConstraintAttribute::End,
            7 => ConstraintAttribute::Width,
            8 => ConstraintAttribute::Height,
            9 => ConstraintAttribute::CenterX,
            10 => ConstraintAttribute::CenterY,
            11 => ConstraintAttribute::Baseline,
            value => ConstraintAttribute::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintAttribute {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_constraint_attribute_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConstraintAttribute {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConstraintAttribute {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConstraintAttribute {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConstraintRelation {
    Le,
    Eq,
    Ge,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConstraintRelation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConstraintRelation::{}",
            match *self {
                ConstraintRelation::Le => "Le",
                ConstraintRelation::Eq => "Eq",
                ConstraintRelation::Ge => "Ge",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConstraintRelation {
    type GlibType = ffi::GtkConstraintRelation;

    fn to_glib(&self) -> ffi::GtkConstraintRelation {
        match *self {
            ConstraintRelation::Le => ffi::GTK_CONSTRAINT_RELATION_LE,
            ConstraintRelation::Eq => ffi::GTK_CONSTRAINT_RELATION_EQ,
            ConstraintRelation::Ge => ffi::GTK_CONSTRAINT_RELATION_GE,
            ConstraintRelation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintRelation> for ConstraintRelation {
    fn from_glib(value: ffi::GtkConstraintRelation) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => ConstraintRelation::Le,
            0 => ConstraintRelation::Eq,
            1 => ConstraintRelation::Ge,
            value => ConstraintRelation::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintRelation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_constraint_relation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConstraintRelation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConstraintRelation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConstraintRelation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConstraintStrength {
    Required,
    Strong,
    Medium,
    Weak,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConstraintStrength {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConstraintStrength::{}",
            match *self {
                ConstraintStrength::Required => "Required",
                ConstraintStrength::Strong => "Strong",
                ConstraintStrength::Medium => "Medium",
                ConstraintStrength::Weak => "Weak",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConstraintStrength {
    type GlibType = ffi::GtkConstraintStrength;

    fn to_glib(&self) -> ffi::GtkConstraintStrength {
        match *self {
            ConstraintStrength::Required => ffi::GTK_CONSTRAINT_STRENGTH_REQUIRED,
            ConstraintStrength::Strong => ffi::GTK_CONSTRAINT_STRENGTH_STRONG,
            ConstraintStrength::Medium => ffi::GTK_CONSTRAINT_STRENGTH_MEDIUM,
            ConstraintStrength::Weak => ffi::GTK_CONSTRAINT_STRENGTH_WEAK,
            ConstraintStrength::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintStrength> for ConstraintStrength {
    fn from_glib(value: ffi::GtkConstraintStrength) -> Self {
        skip_assert_initialized!();
        match value {
            1001001000 => ConstraintStrength::Required,
            1000000000 => ConstraintStrength::Strong,
            1000 => ConstraintStrength::Medium,
            1 => ConstraintStrength::Weak,
            value => ConstraintStrength::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintStrength {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_constraint_strength_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConstraintStrength {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConstraintStrength {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConstraintStrength {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConstraintVflParserError {
    Symbol,
    Attribute,
    View,
    Metric,
    Priority,
    Relation,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConstraintVflParserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConstraintVflParserError::{}",
            match *self {
                ConstraintVflParserError::Symbol => "Symbol",
                ConstraintVflParserError::Attribute => "Attribute",
                ConstraintVflParserError::View => "View",
                ConstraintVflParserError::Metric => "Metric",
                ConstraintVflParserError::Priority => "Priority",
                ConstraintVflParserError::Relation => "Relation",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConstraintVflParserError {
    type GlibType = ffi::GtkConstraintVflParserError;

    fn to_glib(&self) -> ffi::GtkConstraintVflParserError {
        match *self {
            ConstraintVflParserError::Symbol => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_SYMBOL,
            ConstraintVflParserError::Attribute => {
                ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_ATTRIBUTE
            }
            ConstraintVflParserError::View => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_VIEW,
            ConstraintVflParserError::Metric => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_METRIC,
            ConstraintVflParserError::Priority => {
                ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_PRIORITY
            }
            ConstraintVflParserError::Relation => {
                ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_RELATION
            }
            ConstraintVflParserError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintVflParserError> for ConstraintVflParserError {
    fn from_glib(value: ffi::GtkConstraintVflParserError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ConstraintVflParserError::Symbol,
            1 => ConstraintVflParserError::Attribute,
            2 => ConstraintVflParserError::View,
            3 => ConstraintVflParserError::Metric,
            4 => ConstraintVflParserError::Priority,
            5 => ConstraintVflParserError::Relation,
            value => ConstraintVflParserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for ConstraintVflParserError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_constraint_vfl_parser_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(ConstraintVflParserError::Symbol),
            1 => Some(ConstraintVflParserError::Attribute),
            2 => Some(ConstraintVflParserError::View),
            3 => Some(ConstraintVflParserError::Metric),
            4 => Some(ConstraintVflParserError::Priority),
            5 => Some(ConstraintVflParserError::Relation),
            value => Some(ConstraintVflParserError::__Unknown(value)),
        }
    }
}

impl StaticType for ConstraintVflParserError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_constraint_vfl_parser_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConstraintVflParserError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConstraintVflParserError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConstraintVflParserError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CornerType {
    TopLeft,
    BottomLeft,
    TopRight,
    BottomRight,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CornerType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CornerType::{}",
            match *self {
                CornerType::TopLeft => "TopLeft",
                CornerType::BottomLeft => "BottomLeft",
                CornerType::TopRight => "TopRight",
                CornerType::BottomRight => "BottomRight",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CornerType {
    type GlibType = ffi::GtkCornerType;

    fn to_glib(&self) -> ffi::GtkCornerType {
        match *self {
            CornerType::TopLeft => ffi::GTK_CORNER_TOP_LEFT,
            CornerType::BottomLeft => ffi::GTK_CORNER_BOTTOM_LEFT,
            CornerType::TopRight => ffi::GTK_CORNER_TOP_RIGHT,
            CornerType::BottomRight => ffi::GTK_CORNER_BOTTOM_RIGHT,
            CornerType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCornerType> for CornerType {
    fn from_glib(value: ffi::GtkCornerType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CornerType::TopLeft,
            1 => CornerType::BottomLeft,
            2 => CornerType::TopRight,
            3 => CornerType::BottomRight,
            value => CornerType::__Unknown(value),
        }
    }
}

impl StaticType for CornerType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_corner_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CornerType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CornerType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CornerType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CssParserError {
    Failed,
    Syntax,
    Import,
    Name,
    UnknownValue,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CssParserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CssParserError::{}",
            match *self {
                CssParserError::Failed => "Failed",
                CssParserError::Syntax => "Syntax",
                CssParserError::Import => "Import",
                CssParserError::Name => "Name",
                CssParserError::UnknownValue => "UnknownValue",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CssParserError {
    type GlibType = ffi::GtkCssParserError;

    fn to_glib(&self) -> ffi::GtkCssParserError {
        match *self {
            CssParserError::Failed => ffi::GTK_CSS_PARSER_ERROR_FAILED,
            CssParserError::Syntax => ffi::GTK_CSS_PARSER_ERROR_SYNTAX,
            CssParserError::Import => ffi::GTK_CSS_PARSER_ERROR_IMPORT,
            CssParserError::Name => ffi::GTK_CSS_PARSER_ERROR_NAME,
            CssParserError::UnknownValue => ffi::GTK_CSS_PARSER_ERROR_UNKNOWN_VALUE,
            CssParserError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssParserError> for CssParserError {
    fn from_glib(value: ffi::GtkCssParserError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CssParserError::Failed,
            1 => CssParserError::Syntax,
            2 => CssParserError::Import,
            3 => CssParserError::Name,
            4 => CssParserError::UnknownValue,
            value => CssParserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for CssParserError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_css_parser_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(CssParserError::Failed),
            1 => Some(CssParserError::Syntax),
            2 => Some(CssParserError::Import),
            3 => Some(CssParserError::Name),
            4 => Some(CssParserError::UnknownValue),
            _ => Some(CssParserError::Failed),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CssParserWarning {
    Deprecated,
    Syntax,
    Unimplemented,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CssParserWarning {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CssParserWarning::{}",
            match *self {
                CssParserWarning::Deprecated => "Deprecated",
                CssParserWarning::Syntax => "Syntax",
                CssParserWarning::Unimplemented => "Unimplemented",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CssParserWarning {
    type GlibType = ffi::GtkCssParserWarning;

    fn to_glib(&self) -> ffi::GtkCssParserWarning {
        match *self {
            CssParserWarning::Deprecated => ffi::GTK_CSS_PARSER_WARNING_DEPRECATED,
            CssParserWarning::Syntax => ffi::GTK_CSS_PARSER_WARNING_SYNTAX,
            CssParserWarning::Unimplemented => ffi::GTK_CSS_PARSER_WARNING_UNIMPLEMENTED,
            CssParserWarning::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssParserWarning> for CssParserWarning {
    fn from_glib(value: ffi::GtkCssParserWarning) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CssParserWarning::Deprecated,
            1 => CssParserWarning::Syntax,
            2 => CssParserWarning::Unimplemented,
            value => CssParserWarning::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeleteType {
    Chars,
    WordEnds,
    Words,
    DisplayLines,
    DisplayLineEnds,
    ParagraphEnds,
    Paragraphs,
    Whitespace,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeleteType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeleteType::{}",
            match *self {
                DeleteType::Chars => "Chars",
                DeleteType::WordEnds => "WordEnds",
                DeleteType::Words => "Words",
                DeleteType::DisplayLines => "DisplayLines",
                DeleteType::DisplayLineEnds => "DisplayLineEnds",
                DeleteType::ParagraphEnds => "ParagraphEnds",
                DeleteType::Paragraphs => "Paragraphs",
                DeleteType::Whitespace => "Whitespace",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeleteType {
    type GlibType = ffi::GtkDeleteType;

    fn to_glib(&self) -> ffi::GtkDeleteType {
        match *self {
            DeleteType::Chars => ffi::GTK_DELETE_CHARS,
            DeleteType::WordEnds => ffi::GTK_DELETE_WORD_ENDS,
            DeleteType::Words => ffi::GTK_DELETE_WORDS,
            DeleteType::DisplayLines => ffi::GTK_DELETE_DISPLAY_LINES,
            DeleteType::DisplayLineEnds => ffi::GTK_DELETE_DISPLAY_LINE_ENDS,
            DeleteType::ParagraphEnds => ffi::GTK_DELETE_PARAGRAPH_ENDS,
            DeleteType::Paragraphs => ffi::GTK_DELETE_PARAGRAPHS,
            DeleteType::Whitespace => ffi::GTK_DELETE_WHITESPACE,
            DeleteType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDeleteType> for DeleteType {
    fn from_glib(value: ffi::GtkDeleteType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DeleteType::Chars,
            1 => DeleteType::WordEnds,
            2 => DeleteType::Words,
            3 => DeleteType::DisplayLines,
            4 => DeleteType::DisplayLineEnds,
            5 => DeleteType::ParagraphEnds,
            6 => DeleteType::Paragraphs,
            7 => DeleteType::Whitespace,
            value => DeleteType::__Unknown(value),
        }
    }
}

impl StaticType for DeleteType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_delete_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeleteType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeleteType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeleteType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DirectionType {
    TabForward,
    TabBackward,
    Up,
    Down,
    Left,
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DirectionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DirectionType::{}",
            match *self {
                DirectionType::TabForward => "TabForward",
                DirectionType::TabBackward => "TabBackward",
                DirectionType::Up => "Up",
                DirectionType::Down => "Down",
                DirectionType::Left => "Left",
                DirectionType::Right => "Right",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DirectionType {
    type GlibType = ffi::GtkDirectionType;

    fn to_glib(&self) -> ffi::GtkDirectionType {
        match *self {
            DirectionType::TabForward => ffi::GTK_DIR_TAB_FORWARD,
            DirectionType::TabBackward => ffi::GTK_DIR_TAB_BACKWARD,
            DirectionType::Up => ffi::GTK_DIR_UP,
            DirectionType::Down => ffi::GTK_DIR_DOWN,
            DirectionType::Left => ffi::GTK_DIR_LEFT,
            DirectionType::Right => ffi::GTK_DIR_RIGHT,
            DirectionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDirectionType> for DirectionType {
    fn from_glib(value: ffi::GtkDirectionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DirectionType::TabForward,
            1 => DirectionType::TabBackward,
            2 => DirectionType::Up,
            3 => DirectionType::Down,
            4 => DirectionType::Left,
            5 => DirectionType::Right,
            value => DirectionType::__Unknown(value),
        }
    }
}

impl StaticType for DirectionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_direction_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DirectionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DirectionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DirectionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EditableProperties {
    PropText,
    PropCursorPosition,
    PropSelectionBound,
    PropEditable,
    PropWidthChars,
    PropMaxWidthChars,
    PropXalign,
    PropEnableUndo,
    NumProperties,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EditableProperties {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EditableProperties::{}",
            match *self {
                EditableProperties::PropText => "PropText",
                EditableProperties::PropCursorPosition => "PropCursorPosition",
                EditableProperties::PropSelectionBound => "PropSelectionBound",
                EditableProperties::PropEditable => "PropEditable",
                EditableProperties::PropWidthChars => "PropWidthChars",
                EditableProperties::PropMaxWidthChars => "PropMaxWidthChars",
                EditableProperties::PropXalign => "PropXalign",
                EditableProperties::PropEnableUndo => "PropEnableUndo",
                EditableProperties::NumProperties => "NumProperties",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EditableProperties {
    type GlibType = ffi::GtkEditableProperties;

    fn to_glib(&self) -> ffi::GtkEditableProperties {
        match *self {
            EditableProperties::PropText => ffi::GTK_EDITABLE_PROP_TEXT,
            EditableProperties::PropCursorPosition => ffi::GTK_EDITABLE_PROP_CURSOR_POSITION,
            EditableProperties::PropSelectionBound => ffi::GTK_EDITABLE_PROP_SELECTION_BOUND,
            EditableProperties::PropEditable => ffi::GTK_EDITABLE_PROP_EDITABLE,
            EditableProperties::PropWidthChars => ffi::GTK_EDITABLE_PROP_WIDTH_CHARS,
            EditableProperties::PropMaxWidthChars => ffi::GTK_EDITABLE_PROP_MAX_WIDTH_CHARS,
            EditableProperties::PropXalign => ffi::GTK_EDITABLE_PROP_XALIGN,
            EditableProperties::PropEnableUndo => ffi::GTK_EDITABLE_PROP_ENABLE_UNDO,
            EditableProperties::NumProperties => ffi::GTK_EDITABLE_NUM_PROPERTIES,
            EditableProperties::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEditableProperties> for EditableProperties {
    fn from_glib(value: ffi::GtkEditableProperties) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EditableProperties::PropText,
            1 => EditableProperties::PropCursorPosition,
            2 => EditableProperties::PropSelectionBound,
            3 => EditableProperties::PropEditable,
            4 => EditableProperties::PropWidthChars,
            5 => EditableProperties::PropMaxWidthChars,
            6 => EditableProperties::PropXalign,
            7 => EditableProperties::PropEnableUndo,
            8 => EditableProperties::NumProperties,
            value => EditableProperties::__Unknown(value),
        }
    }
}

impl StaticType for EditableProperties {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_editable_properties_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EditableProperties {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EditableProperties {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EditableProperties {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EntryIconPosition {
    Primary,
    Secondary,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EntryIconPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EntryIconPosition::{}",
            match *self {
                EntryIconPosition::Primary => "Primary",
                EntryIconPosition::Secondary => "Secondary",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EntryIconPosition {
    type GlibType = ffi::GtkEntryIconPosition;

    fn to_glib(&self) -> ffi::GtkEntryIconPosition {
        match *self {
            EntryIconPosition::Primary => ffi::GTK_ENTRY_ICON_PRIMARY,
            EntryIconPosition::Secondary => ffi::GTK_ENTRY_ICON_SECONDARY,
            EntryIconPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEntryIconPosition> for EntryIconPosition {
    fn from_glib(value: ffi::GtkEntryIconPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EntryIconPosition::Primary,
            1 => EntryIconPosition::Secondary,
            value => EntryIconPosition::__Unknown(value),
        }
    }
}

impl StaticType for EntryIconPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_entry_icon_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EntryIconPosition {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EntryIconPosition {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EntryIconPosition {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EventSequenceState {
    None,
    Claimed,
    Denied,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EventSequenceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EventSequenceState::{}",
            match *self {
                EventSequenceState::None => "None",
                EventSequenceState::Claimed => "Claimed",
                EventSequenceState::Denied => "Denied",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EventSequenceState {
    type GlibType = ffi::GtkEventSequenceState;

    fn to_glib(&self) -> ffi::GtkEventSequenceState {
        match *self {
            EventSequenceState::None => ffi::GTK_EVENT_SEQUENCE_NONE,
            EventSequenceState::Claimed => ffi::GTK_EVENT_SEQUENCE_CLAIMED,
            EventSequenceState::Denied => ffi::GTK_EVENT_SEQUENCE_DENIED,
            EventSequenceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEventSequenceState> for EventSequenceState {
    fn from_glib(value: ffi::GtkEventSequenceState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EventSequenceState::None,
            1 => EventSequenceState::Claimed,
            2 => EventSequenceState::Denied,
            value => EventSequenceState::__Unknown(value),
        }
    }
}

impl StaticType for EventSequenceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_event_sequence_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EventSequenceState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EventSequenceState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EventSequenceState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FileChooserAction {
    Open,
    Save,
    SelectFolder,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileChooserAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileChooserAction::{}",
            match *self {
                FileChooserAction::Open => "Open",
                FileChooserAction::Save => "Save",
                FileChooserAction::SelectFolder => "SelectFolder",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileChooserAction {
    type GlibType = ffi::GtkFileChooserAction;

    fn to_glib(&self) -> ffi::GtkFileChooserAction {
        match *self {
            FileChooserAction::Open => ffi::GTK_FILE_CHOOSER_ACTION_OPEN,
            FileChooserAction::Save => ffi::GTK_FILE_CHOOSER_ACTION_SAVE,
            FileChooserAction::SelectFolder => ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
            FileChooserAction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserAction> for FileChooserAction {
    fn from_glib(value: ffi::GtkFileChooserAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileChooserAction::Open,
            1 => FileChooserAction::Save,
            2 => FileChooserAction::SelectFolder,
            value => FileChooserAction::__Unknown(value),
        }
    }
}

impl StaticType for FileChooserAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_chooser_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileChooserAction {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileChooserAction {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileChooserAction {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FileChooserError {
    Nonexistent,
    BadFilename,
    AlreadyExists,
    IncompleteHostname,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileChooserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileChooserError::{}",
            match *self {
                FileChooserError::Nonexistent => "Nonexistent",
                FileChooserError::BadFilename => "BadFilename",
                FileChooserError::AlreadyExists => "AlreadyExists",
                FileChooserError::IncompleteHostname => "IncompleteHostname",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileChooserError {
    type GlibType = ffi::GtkFileChooserError;

    fn to_glib(&self) -> ffi::GtkFileChooserError {
        match *self {
            FileChooserError::Nonexistent => ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT,
            FileChooserError::BadFilename => ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME,
            FileChooserError::AlreadyExists => ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS,
            FileChooserError::IncompleteHostname => ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME,
            FileChooserError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserError> for FileChooserError {
    fn from_glib(value: ffi::GtkFileChooserError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileChooserError::Nonexistent,
            1 => FileChooserError::BadFilename,
            2 => FileChooserError::AlreadyExists,
            3 => FileChooserError::IncompleteHostname,
            value => FileChooserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileChooserError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_file_chooser_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FileChooserError::Nonexistent),
            1 => Some(FileChooserError::BadFilename),
            2 => Some(FileChooserError::AlreadyExists),
            3 => Some(FileChooserError::IncompleteHostname),
            value => Some(FileChooserError::__Unknown(value)),
        }
    }
}

impl StaticType for FileChooserError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_chooser_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileChooserError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileChooserError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileChooserError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FilterChange {
    Different,
    LessStrict,
    MoreStrict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FilterChange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FilterChange::{}",
            match *self {
                FilterChange::Different => "Different",
                FilterChange::LessStrict => "LessStrict",
                FilterChange::MoreStrict => "MoreStrict",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FilterChange {
    type GlibType = ffi::GtkFilterChange;

    fn to_glib(&self) -> ffi::GtkFilterChange {
        match *self {
            FilterChange::Different => ffi::GTK_FILTER_CHANGE_DIFFERENT,
            FilterChange::LessStrict => ffi::GTK_FILTER_CHANGE_LESS_STRICT,
            FilterChange::MoreStrict => ffi::GTK_FILTER_CHANGE_MORE_STRICT,
            FilterChange::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFilterChange> for FilterChange {
    fn from_glib(value: ffi::GtkFilterChange) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FilterChange::Different,
            1 => FilterChange::LessStrict,
            2 => FilterChange::MoreStrict,
            value => FilterChange::__Unknown(value),
        }
    }
}

impl StaticType for FilterChange {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_filter_change_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FilterChange {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FilterChange {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FilterChange {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FilterMatch {
    Some,
    None,
    All,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FilterMatch {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FilterMatch::{}",
            match *self {
                FilterMatch::Some => "Some",
                FilterMatch::None => "None",
                FilterMatch::All => "All",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FilterMatch {
    type GlibType = ffi::GtkFilterMatch;

    fn to_glib(&self) -> ffi::GtkFilterMatch {
        match *self {
            FilterMatch::Some => ffi::GTK_FILTER_MATCH_SOME,
            FilterMatch::None => ffi::GTK_FILTER_MATCH_NONE,
            FilterMatch::All => ffi::GTK_FILTER_MATCH_ALL,
            FilterMatch::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFilterMatch> for FilterMatch {
    fn from_glib(value: ffi::GtkFilterMatch) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FilterMatch::Some,
            1 => FilterMatch::None,
            2 => FilterMatch::All,
            value => FilterMatch::__Unknown(value),
        }
    }
}

impl StaticType for FilterMatch {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_filter_match_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FilterMatch {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FilterMatch {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FilterMatch {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum IconSize {
    Inherit,
    Normal,
    Large,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IconSize {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconSize::{}",
            match *self {
                IconSize::Inherit => "Inherit",
                IconSize::Normal => "Normal",
                IconSize::Large => "Large",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconSize {
    type GlibType = ffi::GtkIconSize;

    fn to_glib(&self) -> ffi::GtkIconSize {
        match *self {
            IconSize::Inherit => ffi::GTK_ICON_SIZE_INHERIT,
            IconSize::Normal => ffi::GTK_ICON_SIZE_NORMAL,
            IconSize::Large => ffi::GTK_ICON_SIZE_LARGE,
            IconSize::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconSize> for IconSize {
    fn from_glib(value: ffi::GtkIconSize) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconSize::Inherit,
            1 => IconSize::Normal,
            2 => IconSize::Large,
            value => IconSize::__Unknown(value),
        }
    }
}

impl StaticType for IconSize {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_size_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconSize {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconSize {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconSize {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum IconThemeError {
    NotFound,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IconThemeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconThemeError::{}",
            match *self {
                IconThemeError::NotFound => "NotFound",
                IconThemeError::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconThemeError {
    type GlibType = ffi::GtkIconThemeError;

    fn to_glib(&self) -> ffi::GtkIconThemeError {
        match *self {
            IconThemeError::NotFound => ffi::GTK_ICON_THEME_NOT_FOUND,
            IconThemeError::Failed => ffi::GTK_ICON_THEME_FAILED,
            IconThemeError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconThemeError> for IconThemeError {
    fn from_glib(value: ffi::GtkIconThemeError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconThemeError::NotFound,
            1 => IconThemeError::Failed,
            value => IconThemeError::__Unknown(value),
        }
    }
}

impl ErrorDomain for IconThemeError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_icon_theme_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(IconThemeError::NotFound),
            1 => Some(IconThemeError::Failed),
            _ => Some(IconThemeError::Failed),
        }
    }
}

impl StaticType for IconThemeError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_theme_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconThemeError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconThemeError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconThemeError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum IconViewDropPosition {
    NoDrop,
    DropInto,
    DropLeft,
    DropRight,
    DropAbove,
    DropBelow,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IconViewDropPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconViewDropPosition::{}",
            match *self {
                IconViewDropPosition::NoDrop => "NoDrop",
                IconViewDropPosition::DropInto => "DropInto",
                IconViewDropPosition::DropLeft => "DropLeft",
                IconViewDropPosition::DropRight => "DropRight",
                IconViewDropPosition::DropAbove => "DropAbove",
                IconViewDropPosition::DropBelow => "DropBelow",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconViewDropPosition {
    type GlibType = ffi::GtkIconViewDropPosition;

    fn to_glib(&self) -> ffi::GtkIconViewDropPosition {
        match *self {
            IconViewDropPosition::NoDrop => ffi::GTK_ICON_VIEW_NO_DROP,
            IconViewDropPosition::DropInto => ffi::GTK_ICON_VIEW_DROP_INTO,
            IconViewDropPosition::DropLeft => ffi::GTK_ICON_VIEW_DROP_LEFT,
            IconViewDropPosition::DropRight => ffi::GTK_ICON_VIEW_DROP_RIGHT,
            IconViewDropPosition::DropAbove => ffi::GTK_ICON_VIEW_DROP_ABOVE,
            IconViewDropPosition::DropBelow => ffi::GTK_ICON_VIEW_DROP_BELOW,
            IconViewDropPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconViewDropPosition> for IconViewDropPosition {
    fn from_glib(value: ffi::GtkIconViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconViewDropPosition::NoDrop,
            1 => IconViewDropPosition::DropInto,
            2 => IconViewDropPosition::DropLeft,
            3 => IconViewDropPosition::DropRight,
            4 => IconViewDropPosition::DropAbove,
            5 => IconViewDropPosition::DropBelow,
            value => IconViewDropPosition::__Unknown(value),
        }
    }
}

impl StaticType for IconViewDropPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_view_drop_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconViewDropPosition {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconViewDropPosition {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconViewDropPosition {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ImageType {
    Empty,
    IconName,
    Gicon,
    Paintable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ImageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ImageType::{}",
            match *self {
                ImageType::Empty => "Empty",
                ImageType::IconName => "IconName",
                ImageType::Gicon => "Gicon",
                ImageType::Paintable => "Paintable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ImageType {
    type GlibType = ffi::GtkImageType;

    fn to_glib(&self) -> ffi::GtkImageType {
        match *self {
            ImageType::Empty => ffi::GTK_IMAGE_EMPTY,
            ImageType::IconName => ffi::GTK_IMAGE_ICON_NAME,
            ImageType::Gicon => ffi::GTK_IMAGE_GICON,
            ImageType::Paintable => ffi::GTK_IMAGE_PAINTABLE,
            ImageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkImageType> for ImageType {
    fn from_glib(value: ffi::GtkImageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ImageType::Empty,
            1 => ImageType::IconName,
            2 => ImageType::Gicon,
            3 => ImageType::Paintable,
            value => ImageType::__Unknown(value),
        }
    }
}

impl StaticType for ImageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_image_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ImageType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ImageType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ImageType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum InputPurpose {
    FreeForm,
    Alpha,
    Digits,
    Number,
    Phone,
    Url,
    Email,
    Name,
    Password,
    Pin,
    Terminal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputPurpose::{}",
            match *self {
                InputPurpose::FreeForm => "FreeForm",
                InputPurpose::Alpha => "Alpha",
                InputPurpose::Digits => "Digits",
                InputPurpose::Number => "Number",
                InputPurpose::Phone => "Phone",
                InputPurpose::Url => "Url",
                InputPurpose::Email => "Email",
                InputPurpose::Name => "Name",
                InputPurpose::Password => "Password",
                InputPurpose::Pin => "Pin",
                InputPurpose::Terminal => "Terminal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ffi::GtkInputPurpose;

    fn to_glib(&self) -> ffi::GtkInputPurpose {
        match *self {
            InputPurpose::FreeForm => ffi::GTK_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Alpha => ffi::GTK_INPUT_PURPOSE_ALPHA,
            InputPurpose::Digits => ffi::GTK_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ffi::GTK_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ffi::GTK_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ffi::GTK_INPUT_PURPOSE_URL,
            InputPurpose::Email => ffi::GTK_INPUT_PURPOSE_EMAIL,
            InputPurpose::Name => ffi::GTK_INPUT_PURPOSE_NAME,
            InputPurpose::Password => ffi::GTK_INPUT_PURPOSE_PASSWORD,
            InputPurpose::Pin => ffi::GTK_INPUT_PURPOSE_PIN,
            InputPurpose::Terminal => ffi::GTK_INPUT_PURPOSE_TERMINAL,
            InputPurpose::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkInputPurpose> for InputPurpose {
    fn from_glib(value: ffi::GtkInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Alpha,
            2 => InputPurpose::Digits,
            3 => InputPurpose::Number,
            4 => InputPurpose::Phone,
            5 => InputPurpose::Url,
            6 => InputPurpose::Email,
            7 => InputPurpose::Name,
            8 => InputPurpose::Password,
            9 => InputPurpose::Pin,
            10 => InputPurpose::Terminal,
            value => InputPurpose::__Unknown(value),
        }
    }
}

impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_input_purpose_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputPurpose {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputPurpose {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputPurpose {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Justification {
    Left,
    Right,
    Center,
    Fill,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Justification {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Justification::{}",
            match *self {
                Justification::Left => "Left",
                Justification::Right => "Right",
                Justification::Center => "Center",
                Justification::Fill => "Fill",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Justification {
    type GlibType = ffi::GtkJustification;

    fn to_glib(&self) -> ffi::GtkJustification {
        match *self {
            Justification::Left => ffi::GTK_JUSTIFY_LEFT,
            Justification::Right => ffi::GTK_JUSTIFY_RIGHT,
            Justification::Center => ffi::GTK_JUSTIFY_CENTER,
            Justification::Fill => ffi::GTK_JUSTIFY_FILL,
            Justification::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJustification> for Justification {
    fn from_glib(value: ffi::GtkJustification) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Justification::Left,
            1 => Justification::Right,
            2 => Justification::Center,
            3 => Justification::Fill,
            value => Justification::__Unknown(value),
        }
    }
}

impl StaticType for Justification {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_justification_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Justification {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Justification {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Justification {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum LevelBarMode {
    Continuous,
    Discrete,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LevelBarMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LevelBarMode::{}",
            match *self {
                LevelBarMode::Continuous => "Continuous",
                LevelBarMode::Discrete => "Discrete",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for LevelBarMode {
    type GlibType = ffi::GtkLevelBarMode;

    fn to_glib(&self) -> ffi::GtkLevelBarMode {
        match *self {
            LevelBarMode::Continuous => ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS,
            LevelBarMode::Discrete => ffi::GTK_LEVEL_BAR_MODE_DISCRETE,
            LevelBarMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLevelBarMode> for LevelBarMode {
    fn from_glib(value: ffi::GtkLevelBarMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LevelBarMode::Continuous,
            1 => LevelBarMode::Discrete,
            value => LevelBarMode::__Unknown(value),
        }
    }
}

impl StaticType for LevelBarMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_level_bar_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LevelBarMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LevelBarMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LevelBarMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum License {
    Unknown,
    Custom,
    Gpl20,
    Gpl30,
    Lgpl21,
    Lgpl30,
    Bsd,
    MitX11,
    Artistic,
    Gpl20Only,
    Gpl30Only,
    Lgpl21Only,
    Lgpl30Only,
    Agpl30,
    Agpl30Only,
    Bsd3,
    Apache20,
    Mpl20,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for License {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "License::{}",
            match *self {
                License::Unknown => "Unknown",
                License::Custom => "Custom",
                License::Gpl20 => "Gpl20",
                License::Gpl30 => "Gpl30",
                License::Lgpl21 => "Lgpl21",
                License::Lgpl30 => "Lgpl30",
                License::Bsd => "Bsd",
                License::MitX11 => "MitX11",
                License::Artistic => "Artistic",
                License::Gpl20Only => "Gpl20Only",
                License::Gpl30Only => "Gpl30Only",
                License::Lgpl21Only => "Lgpl21Only",
                License::Lgpl30Only => "Lgpl30Only",
                License::Agpl30 => "Agpl30",
                License::Agpl30Only => "Agpl30Only",
                License::Bsd3 => "Bsd3",
                License::Apache20 => "Apache20",
                License::Mpl20 => "Mpl20",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for License {
    type GlibType = ffi::GtkLicense;

    fn to_glib(&self) -> ffi::GtkLicense {
        match *self {
            License::Unknown => ffi::GTK_LICENSE_UNKNOWN,
            License::Custom => ffi::GTK_LICENSE_CUSTOM,
            License::Gpl20 => ffi::GTK_LICENSE_GPL_2_0,
            License::Gpl30 => ffi::GTK_LICENSE_GPL_3_0,
            License::Lgpl21 => ffi::GTK_LICENSE_LGPL_2_1,
            License::Lgpl30 => ffi::GTK_LICENSE_LGPL_3_0,
            License::Bsd => ffi::GTK_LICENSE_BSD,
            License::MitX11 => ffi::GTK_LICENSE_MIT_X11,
            License::Artistic => ffi::GTK_LICENSE_ARTISTIC,
            License::Gpl20Only => ffi::GTK_LICENSE_GPL_2_0_ONLY,
            License::Gpl30Only => ffi::GTK_LICENSE_GPL_3_0_ONLY,
            License::Lgpl21Only => ffi::GTK_LICENSE_LGPL_2_1_ONLY,
            License::Lgpl30Only => ffi::GTK_LICENSE_LGPL_3_0_ONLY,
            License::Agpl30 => ffi::GTK_LICENSE_AGPL_3_0,
            License::Agpl30Only => ffi::GTK_LICENSE_AGPL_3_0_ONLY,
            License::Bsd3 => ffi::GTK_LICENSE_BSD_3,
            License::Apache20 => ffi::GTK_LICENSE_APACHE_2_0,
            License::Mpl20 => ffi::GTK_LICENSE_MPL_2_0,
            License::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLicense> for License {
    fn from_glib(value: ffi::GtkLicense) -> Self {
        skip_assert_initialized!();
        match value {
            0 => License::Unknown,
            1 => License::Custom,
            2 => License::Gpl20,
            3 => License::Gpl30,
            4 => License::Lgpl21,
            5 => License::Lgpl30,
            6 => License::Bsd,
            7 => License::MitX11,
            8 => License::Artistic,
            9 => License::Gpl20Only,
            10 => License::Gpl30Only,
            11 => License::Lgpl21Only,
            12 => License::Lgpl30Only,
            13 => License::Agpl30,
            14 => License::Agpl30Only,
            15 => License::Bsd3,
            16 => License::Apache20,
            17 => License::Mpl20,
            value => License::__Unknown(value),
        }
    }
}

impl StaticType for License {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_license_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for License {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for License {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for License {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MessageType {
    Info,
    Warning,
    Question,
    Error,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MessageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MessageType::{}",
            match *self {
                MessageType::Info => "Info",
                MessageType::Warning => "Warning",
                MessageType::Question => "Question",
                MessageType::Error => "Error",
                MessageType::Other => "Other",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MessageType {
    type GlibType = ffi::GtkMessageType;

    fn to_glib(&self) -> ffi::GtkMessageType {
        match *self {
            MessageType::Info => ffi::GTK_MESSAGE_INFO,
            MessageType::Warning => ffi::GTK_MESSAGE_WARNING,
            MessageType::Question => ffi::GTK_MESSAGE_QUESTION,
            MessageType::Error => ffi::GTK_MESSAGE_ERROR,
            MessageType::Other => ffi::GTK_MESSAGE_OTHER,
            MessageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMessageType> for MessageType {
    fn from_glib(value: ffi::GtkMessageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MessageType::Info,
            1 => MessageType::Warning,
            2 => MessageType::Question,
            3 => MessageType::Error,
            4 => MessageType::Other,
            value => MessageType::__Unknown(value),
        }
    }
}

impl StaticType for MessageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_message_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MessageType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MessageType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MessageType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MovementStep {
    LogicalPositions,
    VisualPositions,
    Words,
    DisplayLines,
    DisplayLineEnds,
    Paragraphs,
    ParagraphEnds,
    Pages,
    BufferEnds,
    HorizontalPages,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MovementStep {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MovementStep::{}",
            match *self {
                MovementStep::LogicalPositions => "LogicalPositions",
                MovementStep::VisualPositions => "VisualPositions",
                MovementStep::Words => "Words",
                MovementStep::DisplayLines => "DisplayLines",
                MovementStep::DisplayLineEnds => "DisplayLineEnds",
                MovementStep::Paragraphs => "Paragraphs",
                MovementStep::ParagraphEnds => "ParagraphEnds",
                MovementStep::Pages => "Pages",
                MovementStep::BufferEnds => "BufferEnds",
                MovementStep::HorizontalPages => "HorizontalPages",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MovementStep {
    type GlibType = ffi::GtkMovementStep;

    fn to_glib(&self) -> ffi::GtkMovementStep {
        match *self {
            MovementStep::LogicalPositions => ffi::GTK_MOVEMENT_LOGICAL_POSITIONS,
            MovementStep::VisualPositions => ffi::GTK_MOVEMENT_VISUAL_POSITIONS,
            MovementStep::Words => ffi::GTK_MOVEMENT_WORDS,
            MovementStep::DisplayLines => ffi::GTK_MOVEMENT_DISPLAY_LINES,
            MovementStep::DisplayLineEnds => ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS,
            MovementStep::Paragraphs => ffi::GTK_MOVEMENT_PARAGRAPHS,
            MovementStep::ParagraphEnds => ffi::GTK_MOVEMENT_PARAGRAPH_ENDS,
            MovementStep::Pages => ffi::GTK_MOVEMENT_PAGES,
            MovementStep::BufferEnds => ffi::GTK_MOVEMENT_BUFFER_ENDS,
            MovementStep::HorizontalPages => ffi::GTK_MOVEMENT_HORIZONTAL_PAGES,
            MovementStep::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMovementStep> for MovementStep {
    fn from_glib(value: ffi::GtkMovementStep) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MovementStep::LogicalPositions,
            1 => MovementStep::VisualPositions,
            2 => MovementStep::Words,
            3 => MovementStep::DisplayLines,
            4 => MovementStep::DisplayLineEnds,
            5 => MovementStep::Paragraphs,
            6 => MovementStep::ParagraphEnds,
            7 => MovementStep::Pages,
            8 => MovementStep::BufferEnds,
            9 => MovementStep::HorizontalPages,
            value => MovementStep::__Unknown(value),
        }
    }
}

impl StaticType for MovementStep {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_movement_step_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MovementStep {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MovementStep {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MovementStep {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum NotebookTab {
    First,
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NotebookTab {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NotebookTab::{}",
            match *self {
                NotebookTab::First => "First",
                NotebookTab::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NotebookTab {
    type GlibType = ffi::GtkNotebookTab;

    fn to_glib(&self) -> ffi::GtkNotebookTab {
        match *self {
            NotebookTab::First => ffi::GTK_NOTEBOOK_TAB_FIRST,
            NotebookTab::Last => ffi::GTK_NOTEBOOK_TAB_LAST,
            NotebookTab::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNotebookTab> for NotebookTab {
    fn from_glib(value: ffi::GtkNotebookTab) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NotebookTab::First,
            1 => NotebookTab::Last,
            value => NotebookTab::__Unknown(value),
        }
    }
}

impl StaticType for NotebookTab {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_notebook_tab_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NotebookTab {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NotebookTab {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NotebookTab {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum NumberUpLayout {
    Lrtb,
    Lrbt,
    Rltb,
    Rlbt,
    Tblr,
    Tbrl,
    Btlr,
    Btrl,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NumberUpLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NumberUpLayout::{}",
            match *self {
                NumberUpLayout::Lrtb => "Lrtb",
                NumberUpLayout::Lrbt => "Lrbt",
                NumberUpLayout::Rltb => "Rltb",
                NumberUpLayout::Rlbt => "Rlbt",
                NumberUpLayout::Tblr => "Tblr",
                NumberUpLayout::Tbrl => "Tbrl",
                NumberUpLayout::Btlr => "Btlr",
                NumberUpLayout::Btrl => "Btrl",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NumberUpLayout {
    type GlibType = ffi::GtkNumberUpLayout;

    fn to_glib(&self) -> ffi::GtkNumberUpLayout {
        match *self {
            NumberUpLayout::Lrtb => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM,
            NumberUpLayout::Lrbt => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP,
            NumberUpLayout::Rltb => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM,
            NumberUpLayout::Rlbt => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP,
            NumberUpLayout::Tblr => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT,
            NumberUpLayout::Tbrl => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT,
            NumberUpLayout::Btlr => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT,
            NumberUpLayout::Btrl => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT,
            NumberUpLayout::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNumberUpLayout> for NumberUpLayout {
    fn from_glib(value: ffi::GtkNumberUpLayout) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NumberUpLayout::Lrtb,
            1 => NumberUpLayout::Lrbt,
            2 => NumberUpLayout::Rltb,
            3 => NumberUpLayout::Rlbt,
            4 => NumberUpLayout::Tblr,
            5 => NumberUpLayout::Tbrl,
            6 => NumberUpLayout::Btlr,
            7 => NumberUpLayout::Btrl,
            value => NumberUpLayout::__Unknown(value),
        }
    }
}

impl StaticType for NumberUpLayout {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_number_up_layout_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NumberUpLayout {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NumberUpLayout {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NumberUpLayout {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Ordering {
    Smaller,
    Equal,
    Larger,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Ordering {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Ordering::{}",
            match *self {
                Ordering::Smaller => "Smaller",
                Ordering::Equal => "Equal",
                Ordering::Larger => "Larger",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Ordering {
    type GlibType = ffi::GtkOrdering;

    fn to_glib(&self) -> ffi::GtkOrdering {
        match *self {
            Ordering::Smaller => ffi::GTK_ORDERING_SMALLER,
            Ordering::Equal => ffi::GTK_ORDERING_EQUAL,
            Ordering::Larger => ffi::GTK_ORDERING_LARGER,
            Ordering::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrdering> for Ordering {
    fn from_glib(value: ffi::GtkOrdering) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => Ordering::Smaller,
            0 => Ordering::Equal,
            1 => Ordering::Larger,
            value => Ordering::__Unknown(value),
        }
    }
}

impl StaticType for Ordering {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_ordering_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Ordering {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Ordering {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Ordering {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Orientation {
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Orientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orientation::{}",
            match *self {
                Orientation::Horizontal => "Horizontal",
                Orientation::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ffi::GtkOrientation;

    fn to_glib(&self) -> ffi::GtkOrientation {
        match *self {
            Orientation::Horizontal => ffi::GTK_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ffi::GTK_ORIENTATION_VERTICAL,
            Orientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrientation> for Orientation {
    fn from_glib(value: ffi::GtkOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Orientation::Horizontal,
            1 => Orientation::Vertical,
            value => Orientation::__Unknown(value),
        }
    }
}

impl StaticType for Orientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Orientation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Orientation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Orientation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Overflow {
    Visible,
    Hidden,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Overflow {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Overflow::{}",
            match *self {
                Overflow::Visible => "Visible",
                Overflow::Hidden => "Hidden",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Overflow {
    type GlibType = ffi::GtkOverflow;

    fn to_glib(&self) -> ffi::GtkOverflow {
        match *self {
            Overflow::Visible => ffi::GTK_OVERFLOW_VISIBLE,
            Overflow::Hidden => ffi::GTK_OVERFLOW_HIDDEN,
            Overflow::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOverflow> for Overflow {
    fn from_glib(value: ffi::GtkOverflow) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Overflow::Visible,
            1 => Overflow::Hidden,
            value => Overflow::__Unknown(value),
        }
    }
}

impl StaticType for Overflow {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_overflow_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Overflow {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Overflow {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Overflow {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PackType {
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PackType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PackType::{}",
            match *self {
                PackType::Start => "Start",
                PackType::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PackType {
    type GlibType = ffi::GtkPackType;

    fn to_glib(&self) -> ffi::GtkPackType {
        match *self {
            PackType::Start => ffi::GTK_PACK_START,
            PackType::End => ffi::GTK_PACK_END,
            PackType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackType> for PackType {
    fn from_glib(value: ffi::GtkPackType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PackType::Start,
            1 => PackType::End,
            value => PackType::__Unknown(value),
        }
    }
}

impl StaticType for PackType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pack_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PackType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PackType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PackType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PadActionType {
    Button,
    Ring,
    Strip,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PadActionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PadActionType::{}",
            match *self {
                PadActionType::Button => "Button",
                PadActionType::Ring => "Ring",
                PadActionType::Strip => "Strip",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PadActionType {
    type GlibType = ffi::GtkPadActionType;

    fn to_glib(&self) -> ffi::GtkPadActionType {
        match *self {
            PadActionType::Button => ffi::GTK_PAD_ACTION_BUTTON,
            PadActionType::Ring => ffi::GTK_PAD_ACTION_RING,
            PadActionType::Strip => ffi::GTK_PAD_ACTION_STRIP,
            PadActionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPadActionType> for PadActionType {
    fn from_glib(value: ffi::GtkPadActionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PadActionType::Button,
            1 => PadActionType::Ring,
            2 => PadActionType::Strip,
            value => PadActionType::__Unknown(value),
        }
    }
}

impl StaticType for PadActionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pad_action_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PadActionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PadActionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PadActionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PageOrientation {
    Portrait,
    Landscape,
    ReversePortrait,
    ReverseLandscape,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PageOrientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PageOrientation::{}",
            match *self {
                PageOrientation::Portrait => "Portrait",
                PageOrientation::Landscape => "Landscape",
                PageOrientation::ReversePortrait => "ReversePortrait",
                PageOrientation::ReverseLandscape => "ReverseLandscape",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PageOrientation {
    type GlibType = ffi::GtkPageOrientation;

    fn to_glib(&self) -> ffi::GtkPageOrientation {
        match *self {
            PageOrientation::Portrait => ffi::GTK_PAGE_ORIENTATION_PORTRAIT,
            PageOrientation::Landscape => ffi::GTK_PAGE_ORIENTATION_LANDSCAPE,
            PageOrientation::ReversePortrait => ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
            PageOrientation::ReverseLandscape => ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE,
            PageOrientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageOrientation> for PageOrientation {
    fn from_glib(value: ffi::GtkPageOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PageOrientation::Portrait,
            1 => PageOrientation::Landscape,
            2 => PageOrientation::ReversePortrait,
            3 => PageOrientation::ReverseLandscape,
            value => PageOrientation::__Unknown(value),
        }
    }
}

impl StaticType for PageOrientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_page_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PageOrientation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PageOrientation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PageOrientation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PageSet {
    All,
    Even,
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PageSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PageSet::{}",
            match *self {
                PageSet::All => "All",
                PageSet::Even => "Even",
                PageSet::Odd => "Odd",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PageSet {
    type GlibType = ffi::GtkPageSet;

    fn to_glib(&self) -> ffi::GtkPageSet {
        match *self {
            PageSet::All => ffi::GTK_PAGE_SET_ALL,
            PageSet::Even => ffi::GTK_PAGE_SET_EVEN,
            PageSet::Odd => ffi::GTK_PAGE_SET_ODD,
            PageSet::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageSet> for PageSet {
    fn from_glib(value: ffi::GtkPageSet) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PageSet::All,
            1 => PageSet::Even,
            2 => PageSet::Odd,
            value => PageSet::__Unknown(value),
        }
    }
}

impl StaticType for PageSet {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_page_set_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PageSet {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PageSet {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PageSet {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PanDirection {
    Left,
    Right,
    Up,
    Down,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PanDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PanDirection::{}",
            match *self {
                PanDirection::Left => "Left",
                PanDirection::Right => "Right",
                PanDirection::Up => "Up",
                PanDirection::Down => "Down",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PanDirection {
    type GlibType = ffi::GtkPanDirection;

    fn to_glib(&self) -> ffi::GtkPanDirection {
        match *self {
            PanDirection::Left => ffi::GTK_PAN_DIRECTION_LEFT,
            PanDirection::Right => ffi::GTK_PAN_DIRECTION_RIGHT,
            PanDirection::Up => ffi::GTK_PAN_DIRECTION_UP,
            PanDirection::Down => ffi::GTK_PAN_DIRECTION_DOWN,
            PanDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPanDirection> for PanDirection {
    fn from_glib(value: ffi::GtkPanDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PanDirection::Left,
            1 => PanDirection::Right,
            2 => PanDirection::Up,
            3 => PanDirection::Down,
            value => PanDirection::__Unknown(value),
        }
    }
}

impl StaticType for PanDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pan_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PanDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PanDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PanDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PolicyType {
    Always,
    Automatic,
    Never,
    External,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PolicyType::{}",
            match *self {
                PolicyType::Always => "Always",
                PolicyType::Automatic => "Automatic",
                PolicyType::Never => "Never",
                PolicyType::External => "External",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PolicyType {
    type GlibType = ffi::GtkPolicyType;

    fn to_glib(&self) -> ffi::GtkPolicyType {
        match *self {
            PolicyType::Always => ffi::GTK_POLICY_ALWAYS,
            PolicyType::Automatic => ffi::GTK_POLICY_AUTOMATIC,
            PolicyType::Never => ffi::GTK_POLICY_NEVER,
            PolicyType::External => ffi::GTK_POLICY_EXTERNAL,
            PolicyType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPolicyType> for PolicyType {
    fn from_glib(value: ffi::GtkPolicyType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PolicyType::Always,
            1 => PolicyType::Automatic,
            2 => PolicyType::Never,
            3 => PolicyType::External,
            value => PolicyType::__Unknown(value),
        }
    }
}

impl StaticType for PolicyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_policy_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PositionType {
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PositionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PositionType::{}",
            match *self {
                PositionType::Left => "Left",
                PositionType::Right => "Right",
                PositionType::Top => "Top",
                PositionType::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PositionType {
    type GlibType = ffi::GtkPositionType;

    fn to_glib(&self) -> ffi::GtkPositionType {
        match *self {
            PositionType::Left => ffi::GTK_POS_LEFT,
            PositionType::Right => ffi::GTK_POS_RIGHT,
            PositionType::Top => ffi::GTK_POS_TOP,
            PositionType::Bottom => ffi::GTK_POS_BOTTOM,
            PositionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPositionType> for PositionType {
    fn from_glib(value: ffi::GtkPositionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PositionType::Left,
            1 => PositionType::Right,
            2 => PositionType::Top,
            3 => PositionType::Bottom,
            value => PositionType::__Unknown(value),
        }
    }
}

impl StaticType for PositionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_position_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PositionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PositionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PositionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintDuplex {
    Simplex,
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintDuplex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintDuplex::{}",
            match *self {
                PrintDuplex::Simplex => "Simplex",
                PrintDuplex::Horizontal => "Horizontal",
                PrintDuplex::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintDuplex {
    type GlibType = ffi::GtkPrintDuplex;

    fn to_glib(&self) -> ffi::GtkPrintDuplex {
        match *self {
            PrintDuplex::Simplex => ffi::GTK_PRINT_DUPLEX_SIMPLEX,
            PrintDuplex::Horizontal => ffi::GTK_PRINT_DUPLEX_HORIZONTAL,
            PrintDuplex::Vertical => ffi::GTK_PRINT_DUPLEX_VERTICAL,
            PrintDuplex::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintDuplex> for PrintDuplex {
    fn from_glib(value: ffi::GtkPrintDuplex) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintDuplex::Simplex,
            1 => PrintDuplex::Horizontal,
            2 => PrintDuplex::Vertical,
            value => PrintDuplex::__Unknown(value),
        }
    }
}

impl StaticType for PrintDuplex {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_duplex_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintDuplex {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintDuplex {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintDuplex {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintError {
    General,
    InternalError,
    Nomem,
    InvalidFile,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintError::{}",
            match *self {
                PrintError::General => "General",
                PrintError::InternalError => "InternalError",
                PrintError::Nomem => "Nomem",
                PrintError::InvalidFile => "InvalidFile",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::GtkPrintError;

    fn to_glib(&self) -> ffi::GtkPrintError {
        match *self {
            PrintError::General => ffi::GTK_PRINT_ERROR_GENERAL,
            PrintError::InternalError => ffi::GTK_PRINT_ERROR_INTERNAL_ERROR,
            PrintError::Nomem => ffi::GTK_PRINT_ERROR_NOMEM,
            PrintError::InvalidFile => ffi::GTK_PRINT_ERROR_INVALID_FILE,
            PrintError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintError> for PrintError {
    fn from_glib(value: ffi::GtkPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintError::General,
            1 => PrintError::InternalError,
            2 => PrintError::Nomem,
            3 => PrintError::InvalidFile,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_print_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(PrintError::General),
            1 => Some(PrintError::InternalError),
            2 => Some(PrintError::Nomem),
            3 => Some(PrintError::InvalidFile),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

impl StaticType for PrintError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintOperationAction {
    PrintDialog,
    Print,
    Preview,
    Export,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintOperationAction::{}",
            match *self {
                PrintOperationAction::PrintDialog => "PrintDialog",
                PrintOperationAction::Print => "Print",
                PrintOperationAction::Preview => "Preview",
                PrintOperationAction::Export => "Export",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationAction {
    type GlibType = ffi::GtkPrintOperationAction;

    fn to_glib(&self) -> ffi::GtkPrintOperationAction {
        match *self {
            PrintOperationAction::PrintDialog => ffi::GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
            PrintOperationAction::Print => ffi::GTK_PRINT_OPERATION_ACTION_PRINT,
            PrintOperationAction::Preview => ffi::GTK_PRINT_OPERATION_ACTION_PREVIEW,
            PrintOperationAction::Export => ffi::GTK_PRINT_OPERATION_ACTION_EXPORT,
            PrintOperationAction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationAction> for PrintOperationAction {
    fn from_glib(value: ffi::GtkPrintOperationAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationAction::PrintDialog,
            1 => PrintOperationAction::Print,
            2 => PrintOperationAction::Preview,
            3 => PrintOperationAction::Export,
            value => PrintOperationAction::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_operation_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationAction {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationAction {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationAction {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintOperationResult {
    Error,
    Apply,
    Cancel,
    InProgress,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintOperationResult::{}",
            match *self {
                PrintOperationResult::Error => "Error",
                PrintOperationResult::Apply => "Apply",
                PrintOperationResult::Cancel => "Cancel",
                PrintOperationResult::InProgress => "InProgress",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationResult {
    type GlibType = ffi::GtkPrintOperationResult;

    fn to_glib(&self) -> ffi::GtkPrintOperationResult {
        match *self {
            PrintOperationResult::Error => ffi::GTK_PRINT_OPERATION_RESULT_ERROR,
            PrintOperationResult::Apply => ffi::GTK_PRINT_OPERATION_RESULT_APPLY,
            PrintOperationResult::Cancel => ffi::GTK_PRINT_OPERATION_RESULT_CANCEL,
            PrintOperationResult::InProgress => ffi::GTK_PRINT_OPERATION_RESULT_IN_PROGRESS,
            PrintOperationResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationResult> for PrintOperationResult {
    fn from_glib(value: ffi::GtkPrintOperationResult) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationResult::Error,
            1 => PrintOperationResult::Apply,
            2 => PrintOperationResult::Cancel,
            3 => PrintOperationResult::InProgress,
            value => PrintOperationResult::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_operation_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintPages {
    All,
    Current,
    Ranges,
    Selection,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintPages {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintPages::{}",
            match *self {
                PrintPages::All => "All",
                PrintPages::Current => "Current",
                PrintPages::Ranges => "Ranges",
                PrintPages::Selection => "Selection",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintPages {
    type GlibType = ffi::GtkPrintPages;

    fn to_glib(&self) -> ffi::GtkPrintPages {
        match *self {
            PrintPages::All => ffi::GTK_PRINT_PAGES_ALL,
            PrintPages::Current => ffi::GTK_PRINT_PAGES_CURRENT,
            PrintPages::Ranges => ffi::GTK_PRINT_PAGES_RANGES,
            PrintPages::Selection => ffi::GTK_PRINT_PAGES_SELECTION,
            PrintPages::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintPages> for PrintPages {
    fn from_glib(value: ffi::GtkPrintPages) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintPages::All,
            1 => PrintPages::Current,
            2 => PrintPages::Ranges,
            3 => PrintPages::Selection,
            value => PrintPages::__Unknown(value),
        }
    }
}

impl StaticType for PrintPages {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_pages_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintPages {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintPages {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintPages {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintQuality {
    Low,
    Normal,
    High,
    Draft,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintQuality {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintQuality::{}",
            match *self {
                PrintQuality::Low => "Low",
                PrintQuality::Normal => "Normal",
                PrintQuality::High => "High",
                PrintQuality::Draft => "Draft",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintQuality {
    type GlibType = ffi::GtkPrintQuality;

    fn to_glib(&self) -> ffi::GtkPrintQuality {
        match *self {
            PrintQuality::Low => ffi::GTK_PRINT_QUALITY_LOW,
            PrintQuality::Normal => ffi::GTK_PRINT_QUALITY_NORMAL,
            PrintQuality::High => ffi::GTK_PRINT_QUALITY_HIGH,
            PrintQuality::Draft => ffi::GTK_PRINT_QUALITY_DRAFT,
            PrintQuality::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintQuality> for PrintQuality {
    fn from_glib(value: ffi::GtkPrintQuality) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintQuality::Low,
            1 => PrintQuality::Normal,
            2 => PrintQuality::High,
            3 => PrintQuality::Draft,
            value => PrintQuality::__Unknown(value),
        }
    }
}

impl StaticType for PrintQuality {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_quality_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintQuality {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintQuality {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintQuality {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PrintStatus {
    Initial,
    Preparing,
    GeneratingData,
    SendingData,
    Pending,
    PendingIssue,
    Printing,
    Finished,
    FinishedAborted,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintStatus::{}",
            match *self {
                PrintStatus::Initial => "Initial",
                PrintStatus::Preparing => "Preparing",
                PrintStatus::GeneratingData => "GeneratingData",
                PrintStatus::SendingData => "SendingData",
                PrintStatus::Pending => "Pending",
                PrintStatus::PendingIssue => "PendingIssue",
                PrintStatus::Printing => "Printing",
                PrintStatus::Finished => "Finished",
                PrintStatus::FinishedAborted => "FinishedAborted",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintStatus {
    type GlibType = ffi::GtkPrintStatus;

    fn to_glib(&self) -> ffi::GtkPrintStatus {
        match *self {
            PrintStatus::Initial => ffi::GTK_PRINT_STATUS_INITIAL,
            PrintStatus::Preparing => ffi::GTK_PRINT_STATUS_PREPARING,
            PrintStatus::GeneratingData => ffi::GTK_PRINT_STATUS_GENERATING_DATA,
            PrintStatus::SendingData => ffi::GTK_PRINT_STATUS_SENDING_DATA,
            PrintStatus::Pending => ffi::GTK_PRINT_STATUS_PENDING,
            PrintStatus::PendingIssue => ffi::GTK_PRINT_STATUS_PENDING_ISSUE,
            PrintStatus::Printing => ffi::GTK_PRINT_STATUS_PRINTING,
            PrintStatus::Finished => ffi::GTK_PRINT_STATUS_FINISHED,
            PrintStatus::FinishedAborted => ffi::GTK_PRINT_STATUS_FINISHED_ABORTED,
            PrintStatus::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintStatus> for PrintStatus {
    fn from_glib(value: ffi::GtkPrintStatus) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintStatus::Initial,
            1 => PrintStatus::Preparing,
            2 => PrintStatus::GeneratingData,
            3 => PrintStatus::SendingData,
            4 => PrintStatus::Pending,
            5 => PrintStatus::PendingIssue,
            6 => PrintStatus::Printing,
            7 => PrintStatus::Finished,
            8 => PrintStatus::FinishedAborted,
            value => PrintStatus::__Unknown(value),
        }
    }
}

impl StaticType for PrintStatus {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_status_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintStatus {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintStatus {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintStatus {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PropagationLimit {
    None,
    SameNative,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PropagationLimit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PropagationLimit::{}",
            match *self {
                PropagationLimit::None => "None",
                PropagationLimit::SameNative => "SameNative",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PropagationLimit {
    type GlibType = ffi::GtkPropagationLimit;

    fn to_glib(&self) -> ffi::GtkPropagationLimit {
        match *self {
            PropagationLimit::None => ffi::GTK_LIMIT_NONE,
            PropagationLimit::SameNative => ffi::GTK_LIMIT_SAME_NATIVE,
            PropagationLimit::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationLimit> for PropagationLimit {
    fn from_glib(value: ffi::GtkPropagationLimit) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PropagationLimit::None,
            1 => PropagationLimit::SameNative,
            value => PropagationLimit::__Unknown(value),
        }
    }
}

impl StaticType for PropagationLimit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_propagation_limit_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PropagationLimit {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PropagationLimit {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PropagationLimit {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PropagationPhase {
    None,
    Capture,
    Bubble,
    Target,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PropagationPhase {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PropagationPhase::{}",
            match *self {
                PropagationPhase::None => "None",
                PropagationPhase::Capture => "Capture",
                PropagationPhase::Bubble => "Bubble",
                PropagationPhase::Target => "Target",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PropagationPhase {
    type GlibType = ffi::GtkPropagationPhase;

    fn to_glib(&self) -> ffi::GtkPropagationPhase {
        match *self {
            PropagationPhase::None => ffi::GTK_PHASE_NONE,
            PropagationPhase::Capture => ffi::GTK_PHASE_CAPTURE,
            PropagationPhase::Bubble => ffi::GTK_PHASE_BUBBLE,
            PropagationPhase::Target => ffi::GTK_PHASE_TARGET,
            PropagationPhase::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationPhase> for PropagationPhase {
    fn from_glib(value: ffi::GtkPropagationPhase) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PropagationPhase::None,
            1 => PropagationPhase::Capture,
            2 => PropagationPhase::Bubble,
            3 => PropagationPhase::Target,
            value => PropagationPhase::__Unknown(value),
        }
    }
}

impl StaticType for PropagationPhase {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_propagation_phase_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PropagationPhase {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PropagationPhase {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PropagationPhase {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RecentManagerError {
    NotFound,
    InvalidUri,
    InvalidEncoding,
    NotRegistered,
    Read,
    Write,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RecentManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RecentManagerError::{}",
            match *self {
                RecentManagerError::NotFound => "NotFound",
                RecentManagerError::InvalidUri => "InvalidUri",
                RecentManagerError::InvalidEncoding => "InvalidEncoding",
                RecentManagerError::NotRegistered => "NotRegistered",
                RecentManagerError::Read => "Read",
                RecentManagerError::Write => "Write",
                RecentManagerError::Unknown => "Unknown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RecentManagerError {
    type GlibType = ffi::GtkRecentManagerError;

    fn to_glib(&self) -> ffi::GtkRecentManagerError {
        match *self {
            RecentManagerError::NotFound => ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
            RecentManagerError::InvalidUri => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI,
            RecentManagerError::InvalidEncoding => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
            RecentManagerError::NotRegistered => ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
            RecentManagerError::Read => ffi::GTK_RECENT_MANAGER_ERROR_READ,
            RecentManagerError::Write => ffi::GTK_RECENT_MANAGER_ERROR_WRITE,
            RecentManagerError::Unknown => ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN,
            RecentManagerError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentManagerError> for RecentManagerError {
    fn from_glib(value: ffi::GtkRecentManagerError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RecentManagerError::NotFound,
            1 => RecentManagerError::InvalidUri,
            2 => RecentManagerError::InvalidEncoding,
            3 => RecentManagerError::NotRegistered,
            4 => RecentManagerError::Read,
            5 => RecentManagerError::Write,
            6 => RecentManagerError::Unknown,
            value => RecentManagerError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RecentManagerError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_recent_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RecentManagerError::NotFound),
            1 => Some(RecentManagerError::InvalidUri),
            2 => Some(RecentManagerError::InvalidEncoding),
            3 => Some(RecentManagerError::NotRegistered),
            4 => Some(RecentManagerError::Read),
            5 => Some(RecentManagerError::Write),
            6 => Some(RecentManagerError::Unknown),
            value => Some(RecentManagerError::__Unknown(value)),
        }
    }
}

impl StaticType for RecentManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_recent_manager_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RecentManagerError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RecentManagerError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RecentManagerError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RevealerTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    SwingRight,
    SwingLeft,
    SwingUp,
    SwingDown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RevealerTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RevealerTransitionType::{}",
            match *self {
                RevealerTransitionType::None => "None",
                RevealerTransitionType::Crossfade => "Crossfade",
                RevealerTransitionType::SlideRight => "SlideRight",
                RevealerTransitionType::SlideLeft => "SlideLeft",
                RevealerTransitionType::SlideUp => "SlideUp",
                RevealerTransitionType::SlideDown => "SlideDown",
                RevealerTransitionType::SwingRight => "SwingRight",
                RevealerTransitionType::SwingLeft => "SwingLeft",
                RevealerTransitionType::SwingUp => "SwingUp",
                RevealerTransitionType::SwingDown => "SwingDown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RevealerTransitionType {
    type GlibType = ffi::GtkRevealerTransitionType;

    fn to_glib(&self) -> ffi::GtkRevealerTransitionType {
        match *self {
            RevealerTransitionType::None => ffi::GTK_REVEALER_TRANSITION_TYPE_NONE,
            RevealerTransitionType::Crossfade => ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE,
            RevealerTransitionType::SlideRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT,
            RevealerTransitionType::SlideLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT,
            RevealerTransitionType::SlideUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP,
            RevealerTransitionType::SlideDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN,
            RevealerTransitionType::SwingRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_RIGHT,
            RevealerTransitionType::SwingLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_LEFT,
            RevealerTransitionType::SwingUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_UP,
            RevealerTransitionType::SwingDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_DOWN,
            RevealerTransitionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRevealerTransitionType> for RevealerTransitionType {
    fn from_glib(value: ffi::GtkRevealerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RevealerTransitionType::None,
            1 => RevealerTransitionType::Crossfade,
            2 => RevealerTransitionType::SlideRight,
            3 => RevealerTransitionType::SlideLeft,
            4 => RevealerTransitionType::SlideUp,
            5 => RevealerTransitionType::SlideDown,
            6 => RevealerTransitionType::SwingRight,
            7 => RevealerTransitionType::SwingLeft,
            8 => RevealerTransitionType::SwingUp,
            9 => RevealerTransitionType::SwingDown,
            value => RevealerTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for RevealerTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_revealer_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RevealerTransitionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RevealerTransitionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RevealerTransitionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScrollStep {
    Steps,
    Pages,
    Ends,
    HorizontalSteps,
    HorizontalPages,
    HorizontalEnds,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollStep {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollStep::{}",
            match *self {
                ScrollStep::Steps => "Steps",
                ScrollStep::Pages => "Pages",
                ScrollStep::Ends => "Ends",
                ScrollStep::HorizontalSteps => "HorizontalSteps",
                ScrollStep::HorizontalPages => "HorizontalPages",
                ScrollStep::HorizontalEnds => "HorizontalEnds",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollStep {
    type GlibType = ffi::GtkScrollStep;

    fn to_glib(&self) -> ffi::GtkScrollStep {
        match *self {
            ScrollStep::Steps => ffi::GTK_SCROLL_STEPS,
            ScrollStep::Pages => ffi::GTK_SCROLL_PAGES,
            ScrollStep::Ends => ffi::GTK_SCROLL_ENDS,
            ScrollStep::HorizontalSteps => ffi::GTK_SCROLL_HORIZONTAL_STEPS,
            ScrollStep::HorizontalPages => ffi::GTK_SCROLL_HORIZONTAL_PAGES,
            ScrollStep::HorizontalEnds => ffi::GTK_SCROLL_HORIZONTAL_ENDS,
            ScrollStep::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollStep> for ScrollStep {
    fn from_glib(value: ffi::GtkScrollStep) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollStep::Steps,
            1 => ScrollStep::Pages,
            2 => ScrollStep::Ends,
            3 => ScrollStep::HorizontalSteps,
            4 => ScrollStep::HorizontalPages,
            5 => ScrollStep::HorizontalEnds,
            value => ScrollStep::__Unknown(value),
        }
    }
}

impl StaticType for ScrollStep {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scroll_step_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollStep {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollStep {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollStep {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScrollType {
    None,
    Jump,
    StepBackward,
    StepForward,
    PageBackward,
    PageForward,
    StepUp,
    StepDown,
    PageUp,
    PageDown,
    StepLeft,
    StepRight,
    PageLeft,
    PageRight,
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollType::{}",
            match *self {
                ScrollType::None => "None",
                ScrollType::Jump => "Jump",
                ScrollType::StepBackward => "StepBackward",
                ScrollType::StepForward => "StepForward",
                ScrollType::PageBackward => "PageBackward",
                ScrollType::PageForward => "PageForward",
                ScrollType::StepUp => "StepUp",
                ScrollType::StepDown => "StepDown",
                ScrollType::PageUp => "PageUp",
                ScrollType::PageDown => "PageDown",
                ScrollType::StepLeft => "StepLeft",
                ScrollType::StepRight => "StepRight",
                ScrollType::PageLeft => "PageLeft",
                ScrollType::PageRight => "PageRight",
                ScrollType::Start => "Start",
                ScrollType::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollType {
    type GlibType = ffi::GtkScrollType;

    fn to_glib(&self) -> ffi::GtkScrollType {
        match *self {
            ScrollType::None => ffi::GTK_SCROLL_NONE,
            ScrollType::Jump => ffi::GTK_SCROLL_JUMP,
            ScrollType::StepBackward => ffi::GTK_SCROLL_STEP_BACKWARD,
            ScrollType::StepForward => ffi::GTK_SCROLL_STEP_FORWARD,
            ScrollType::PageBackward => ffi::GTK_SCROLL_PAGE_BACKWARD,
            ScrollType::PageForward => ffi::GTK_SCROLL_PAGE_FORWARD,
            ScrollType::StepUp => ffi::GTK_SCROLL_STEP_UP,
            ScrollType::StepDown => ffi::GTK_SCROLL_STEP_DOWN,
            ScrollType::PageUp => ffi::GTK_SCROLL_PAGE_UP,
            ScrollType::PageDown => ffi::GTK_SCROLL_PAGE_DOWN,
            ScrollType::StepLeft => ffi::GTK_SCROLL_STEP_LEFT,
            ScrollType::StepRight => ffi::GTK_SCROLL_STEP_RIGHT,
            ScrollType::PageLeft => ffi::GTK_SCROLL_PAGE_LEFT,
            ScrollType::PageRight => ffi::GTK_SCROLL_PAGE_RIGHT,
            ScrollType::Start => ffi::GTK_SCROLL_START,
            ScrollType::End => ffi::GTK_SCROLL_END,
            ScrollType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollType> for ScrollType {
    fn from_glib(value: ffi::GtkScrollType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollType::None,
            1 => ScrollType::Jump,
            2 => ScrollType::StepBackward,
            3 => ScrollType::StepForward,
            4 => ScrollType::PageBackward,
            5 => ScrollType::PageForward,
            6 => ScrollType::StepUp,
            7 => ScrollType::StepDown,
            8 => ScrollType::PageUp,
            9 => ScrollType::PageDown,
            10 => ScrollType::StepLeft,
            11 => ScrollType::StepRight,
            12 => ScrollType::PageLeft,
            13 => ScrollType::PageRight,
            14 => ScrollType::Start,
            15 => ScrollType::End,
            value => ScrollType::__Unknown(value),
        }
    }
}

impl StaticType for ScrollType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scroll_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScrollablePolicy {
    Minimum,
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollablePolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollablePolicy::{}",
            match *self {
                ScrollablePolicy::Minimum => "Minimum",
                ScrollablePolicy::Natural => "Natural",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollablePolicy {
    type GlibType = ffi::GtkScrollablePolicy;

    fn to_glib(&self) -> ffi::GtkScrollablePolicy {
        match *self {
            ScrollablePolicy::Minimum => ffi::GTK_SCROLL_MINIMUM,
            ScrollablePolicy::Natural => ffi::GTK_SCROLL_NATURAL,
            ScrollablePolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollablePolicy> for ScrollablePolicy {
    fn from_glib(value: ffi::GtkScrollablePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollablePolicy::Minimum,
            1 => ScrollablePolicy::Natural,
            value => ScrollablePolicy::__Unknown(value),
        }
    }
}

impl StaticType for ScrollablePolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scrollable_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollablePolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollablePolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollablePolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SelectionMode {
    None,
    Single,
    Browse,
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SelectionMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SelectionMode::{}",
            match *self {
                SelectionMode::None => "None",
                SelectionMode::Single => "Single",
                SelectionMode::Browse => "Browse",
                SelectionMode::Multiple => "Multiple",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SelectionMode {
    type GlibType = ffi::GtkSelectionMode;

    fn to_glib(&self) -> ffi::GtkSelectionMode {
        match *self {
            SelectionMode::None => ffi::GTK_SELECTION_NONE,
            SelectionMode::Single => ffi::GTK_SELECTION_SINGLE,
            SelectionMode::Browse => ffi::GTK_SELECTION_BROWSE,
            SelectionMode::Multiple => ffi::GTK_SELECTION_MULTIPLE,
            SelectionMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSelectionMode> for SelectionMode {
    fn from_glib(value: ffi::GtkSelectionMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SelectionMode::None,
            1 => SelectionMode::Single,
            2 => SelectionMode::Browse,
            3 => SelectionMode::Multiple,
            value => SelectionMode::__Unknown(value),
        }
    }
}

impl StaticType for SelectionMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_selection_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SelectionMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SelectionMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SelectionMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SensitivityType {
    Auto,
    On,
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SensitivityType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SensitivityType::{}",
            match *self {
                SensitivityType::Auto => "Auto",
                SensitivityType::On => "On",
                SensitivityType::Off => "Off",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SensitivityType {
    type GlibType = ffi::GtkSensitivityType;

    fn to_glib(&self) -> ffi::GtkSensitivityType {
        match *self {
            SensitivityType::Auto => ffi::GTK_SENSITIVITY_AUTO,
            SensitivityType::On => ffi::GTK_SENSITIVITY_ON,
            SensitivityType::Off => ffi::GTK_SENSITIVITY_OFF,
            SensitivityType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSensitivityType> for SensitivityType {
    fn from_glib(value: ffi::GtkSensitivityType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SensitivityType::Auto,
            1 => SensitivityType::On,
            2 => SensitivityType::Off,
            value => SensitivityType::__Unknown(value),
        }
    }
}

impl StaticType for SensitivityType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sensitivity_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SensitivityType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SensitivityType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SensitivityType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ShortcutScope {
    Local,
    Managed,
    Global,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ShortcutScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShortcutScope::{}",
            match *self {
                ShortcutScope::Local => "Local",
                ShortcutScope::Managed => "Managed",
                ShortcutScope::Global => "Global",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ShortcutScope {
    type GlibType = ffi::GtkShortcutScope;

    fn to_glib(&self) -> ffi::GtkShortcutScope {
        match *self {
            ShortcutScope::Local => ffi::GTK_SHORTCUT_SCOPE_LOCAL,
            ShortcutScope::Managed => ffi::GTK_SHORTCUT_SCOPE_MANAGED,
            ShortcutScope::Global => ffi::GTK_SHORTCUT_SCOPE_GLOBAL,
            ShortcutScope::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutScope> for ShortcutScope {
    fn from_glib(value: ffi::GtkShortcutScope) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShortcutScope::Local,
            1 => ShortcutScope::Managed,
            2 => ShortcutScope::Global,
            value => ShortcutScope::__Unknown(value),
        }
    }
}

impl StaticType for ShortcutScope {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_shortcut_scope_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ShortcutScope {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ShortcutScope {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ShortcutScope {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ShortcutType {
    Accelerator,
    GesturePinch,
    GestureStretch,
    GestureRotateClockwise,
    GestureRotateCounterclockwise,
    GestureTwoFingerSwipeLeft,
    GestureTwoFingerSwipeRight,
    Gesture,
    GestureSwipeLeft,
    GestureSwipeRight,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ShortcutType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShortcutType::{}",
            match *self {
                ShortcutType::Accelerator => "Accelerator",
                ShortcutType::GesturePinch => "GesturePinch",
                ShortcutType::GestureStretch => "GestureStretch",
                ShortcutType::GestureRotateClockwise => "GestureRotateClockwise",
                ShortcutType::GestureRotateCounterclockwise => "GestureRotateCounterclockwise",
                ShortcutType::GestureTwoFingerSwipeLeft => "GestureTwoFingerSwipeLeft",
                ShortcutType::GestureTwoFingerSwipeRight => "GestureTwoFingerSwipeRight",
                ShortcutType::Gesture => "Gesture",
                ShortcutType::GestureSwipeLeft => "GestureSwipeLeft",
                ShortcutType::GestureSwipeRight => "GestureSwipeRight",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ShortcutType {
    type GlibType = ffi::GtkShortcutType;

    fn to_glib(&self) -> ffi::GtkShortcutType {
        match *self {
            ShortcutType::Accelerator => ffi::GTK_SHORTCUT_ACCELERATOR,
            ShortcutType::GesturePinch => ffi::GTK_SHORTCUT_GESTURE_PINCH,
            ShortcutType::GestureStretch => ffi::GTK_SHORTCUT_GESTURE_STRETCH,
            ShortcutType::GestureRotateClockwise => ffi::GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE,
            ShortcutType::GestureRotateCounterclockwise => {
                ffi::GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE
            }
            ShortcutType::GestureTwoFingerSwipeLeft => {
                ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT
            }
            ShortcutType::GestureTwoFingerSwipeRight => {
                ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT
            }
            ShortcutType::Gesture => ffi::GTK_SHORTCUT_GESTURE,
            ShortcutType::GestureSwipeLeft => ffi::GTK_SHORTCUT_GESTURE_SWIPE_LEFT,
            ShortcutType::GestureSwipeRight => ffi::GTK_SHORTCUT_GESTURE_SWIPE_RIGHT,
            ShortcutType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutType> for ShortcutType {
    fn from_glib(value: ffi::GtkShortcutType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShortcutType::Accelerator,
            1 => ShortcutType::GesturePinch,
            2 => ShortcutType::GestureStretch,
            3 => ShortcutType::GestureRotateClockwise,
            4 => ShortcutType::GestureRotateCounterclockwise,
            5 => ShortcutType::GestureTwoFingerSwipeLeft,
            6 => ShortcutType::GestureTwoFingerSwipeRight,
            7 => ShortcutType::Gesture,
            8 => ShortcutType::GestureSwipeLeft,
            9 => ShortcutType::GestureSwipeRight,
            value => ShortcutType::__Unknown(value),
        }
    }
}

impl StaticType for ShortcutType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_shortcut_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ShortcutType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ShortcutType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ShortcutType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SizeGroupMode {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SizeGroupMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SizeGroupMode::{}",
            match *self {
                SizeGroupMode::None => "None",
                SizeGroupMode::Horizontal => "Horizontal",
                SizeGroupMode::Vertical => "Vertical",
                SizeGroupMode::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SizeGroupMode {
    type GlibType = ffi::GtkSizeGroupMode;

    fn to_glib(&self) -> ffi::GtkSizeGroupMode {
        match *self {
            SizeGroupMode::None => ffi::GTK_SIZE_GROUP_NONE,
            SizeGroupMode::Horizontal => ffi::GTK_SIZE_GROUP_HORIZONTAL,
            SizeGroupMode::Vertical => ffi::GTK_SIZE_GROUP_VERTICAL,
            SizeGroupMode::Both => ffi::GTK_SIZE_GROUP_BOTH,
            SizeGroupMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeGroupMode> for SizeGroupMode {
    fn from_glib(value: ffi::GtkSizeGroupMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SizeGroupMode::None,
            1 => SizeGroupMode::Horizontal,
            2 => SizeGroupMode::Vertical,
            3 => SizeGroupMode::Both,
            value => SizeGroupMode::__Unknown(value),
        }
    }
}

impl StaticType for SizeGroupMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_size_group_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SizeGroupMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SizeGroupMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SizeGroupMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SizeRequestMode {
    HeightForWidth,
    WidthForHeight,
    ConstantSize,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SizeRequestMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SizeRequestMode::{}",
            match *self {
                SizeRequestMode::HeightForWidth => "HeightForWidth",
                SizeRequestMode::WidthForHeight => "WidthForHeight",
                SizeRequestMode::ConstantSize => "ConstantSize",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SizeRequestMode {
    type GlibType = ffi::GtkSizeRequestMode;

    fn to_glib(&self) -> ffi::GtkSizeRequestMode {
        match *self {
            SizeRequestMode::HeightForWidth => ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH,
            SizeRequestMode::WidthForHeight => ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT,
            SizeRequestMode::ConstantSize => ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE,
            SizeRequestMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeRequestMode> for SizeRequestMode {
    fn from_glib(value: ffi::GtkSizeRequestMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SizeRequestMode::HeightForWidth,
            1 => SizeRequestMode::WidthForHeight,
            2 => SizeRequestMode::ConstantSize,
            value => SizeRequestMode::__Unknown(value),
        }
    }
}

impl StaticType for SizeRequestMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_size_request_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SizeRequestMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SizeRequestMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SizeRequestMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SortType {
    Ascending,
    Descending,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SortType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SortType::{}",
            match *self {
                SortType::Ascending => "Ascending",
                SortType::Descending => "Descending",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SortType {
    type GlibType = ffi::GtkSortType;

    fn to_glib(&self) -> ffi::GtkSortType {
        match *self {
            SortType::Ascending => ffi::GTK_SORT_ASCENDING,
            SortType::Descending => ffi::GTK_SORT_DESCENDING,
            SortType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSortType> for SortType {
    fn from_glib(value: ffi::GtkSortType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SortType::Ascending,
            1 => SortType::Descending,
            value => SortType::__Unknown(value),
        }
    }
}

impl StaticType for SortType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sort_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SortType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SortType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SortType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SorterChange {
    Different,
    Inverted,
    LessStrict,
    MoreStrict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SorterChange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SorterChange::{}",
            match *self {
                SorterChange::Different => "Different",
                SorterChange::Inverted => "Inverted",
                SorterChange::LessStrict => "LessStrict",
                SorterChange::MoreStrict => "MoreStrict",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SorterChange {
    type GlibType = ffi::GtkSorterChange;

    fn to_glib(&self) -> ffi::GtkSorterChange {
        match *self {
            SorterChange::Different => ffi::GTK_SORTER_CHANGE_DIFFERENT,
            SorterChange::Inverted => ffi::GTK_SORTER_CHANGE_INVERTED,
            SorterChange::LessStrict => ffi::GTK_SORTER_CHANGE_LESS_STRICT,
            SorterChange::MoreStrict => ffi::GTK_SORTER_CHANGE_MORE_STRICT,
            SorterChange::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSorterChange> for SorterChange {
    fn from_glib(value: ffi::GtkSorterChange) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SorterChange::Different,
            1 => SorterChange::Inverted,
            2 => SorterChange::LessStrict,
            3 => SorterChange::MoreStrict,
            value => SorterChange::__Unknown(value),
        }
    }
}

impl StaticType for SorterChange {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sorter_change_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SorterChange {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SorterChange {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SorterChange {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SorterOrder {
    Partial,
    None,
    Total,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SorterOrder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SorterOrder::{}",
            match *self {
                SorterOrder::Partial => "Partial",
                SorterOrder::None => "None",
                SorterOrder::Total => "Total",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SorterOrder {
    type GlibType = ffi::GtkSorterOrder;

    fn to_glib(&self) -> ffi::GtkSorterOrder {
        match *self {
            SorterOrder::Partial => ffi::GTK_SORTER_ORDER_PARTIAL,
            SorterOrder::None => ffi::GTK_SORTER_ORDER_NONE,
            SorterOrder::Total => ffi::GTK_SORTER_ORDER_TOTAL,
            SorterOrder::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSorterOrder> for SorterOrder {
    fn from_glib(value: ffi::GtkSorterOrder) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SorterOrder::Partial,
            1 => SorterOrder::None,
            2 => SorterOrder::Total,
            value => SorterOrder::__Unknown(value),
        }
    }
}

impl StaticType for SorterOrder {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sorter_order_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SorterOrder {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SorterOrder {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SorterOrder {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SpinButtonUpdatePolicy {
    Always,
    IfValid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SpinButtonUpdatePolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SpinButtonUpdatePolicy::{}",
            match *self {
                SpinButtonUpdatePolicy::Always => "Always",
                SpinButtonUpdatePolicy::IfValid => "IfValid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SpinButtonUpdatePolicy {
    type GlibType = ffi::GtkSpinButtonUpdatePolicy;

    fn to_glib(&self) -> ffi::GtkSpinButtonUpdatePolicy {
        match *self {
            SpinButtonUpdatePolicy::Always => ffi::GTK_UPDATE_ALWAYS,
            SpinButtonUpdatePolicy::IfValid => ffi::GTK_UPDATE_IF_VALID,
            SpinButtonUpdatePolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinButtonUpdatePolicy> for SpinButtonUpdatePolicy {
    fn from_glib(value: ffi::GtkSpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SpinButtonUpdatePolicy::Always,
            1 => SpinButtonUpdatePolicy::IfValid,
            value => SpinButtonUpdatePolicy::__Unknown(value),
        }
    }
}

impl StaticType for SpinButtonUpdatePolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_spin_button_update_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SpinButtonUpdatePolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SpinButtonUpdatePolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SpinButtonUpdatePolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SpinType {
    StepForward,
    StepBackward,
    PageForward,
    PageBackward,
    Home,
    End,
    UserDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SpinType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SpinType::{}",
            match *self {
                SpinType::StepForward => "StepForward",
                SpinType::StepBackward => "StepBackward",
                SpinType::PageForward => "PageForward",
                SpinType::PageBackward => "PageBackward",
                SpinType::Home => "Home",
                SpinType::End => "End",
                SpinType::UserDefined => "UserDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SpinType {
    type GlibType = ffi::GtkSpinType;

    fn to_glib(&self) -> ffi::GtkSpinType {
        match *self {
            SpinType::StepForward => ffi::GTK_SPIN_STEP_FORWARD,
            SpinType::StepBackward => ffi::GTK_SPIN_STEP_BACKWARD,
            SpinType::PageForward => ffi::GTK_SPIN_PAGE_FORWARD,
            SpinType::PageBackward => ffi::GTK_SPIN_PAGE_BACKWARD,
            SpinType::Home => ffi::GTK_SPIN_HOME,
            SpinType::End => ffi::GTK_SPIN_END,
            SpinType::UserDefined => ffi::GTK_SPIN_USER_DEFINED,
            SpinType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinType> for SpinType {
    fn from_glib(value: ffi::GtkSpinType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SpinType::StepForward,
            1 => SpinType::StepBackward,
            2 => SpinType::PageForward,
            3 => SpinType::PageBackward,
            4 => SpinType::Home,
            5 => SpinType::End,
            6 => SpinType::UserDefined,
            value => SpinType::__Unknown(value),
        }
    }
}

impl StaticType for SpinType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_spin_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SpinType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SpinType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SpinType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StackTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    SlideLeftRight,
    SlideUpDown,
    OverUp,
    OverDown,
    OverLeft,
    OverRight,
    UnderUp,
    UnderDown,
    UnderLeft,
    UnderRight,
    OverUpDown,
    OverDownUp,
    OverLeftRight,
    OverRightLeft,
    RotateLeft,
    RotateRight,
    RotateLeftRight,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StackTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StackTransitionType::{}",
            match *self {
                StackTransitionType::None => "None",
                StackTransitionType::Crossfade => "Crossfade",
                StackTransitionType::SlideRight => "SlideRight",
                StackTransitionType::SlideLeft => "SlideLeft",
                StackTransitionType::SlideUp => "SlideUp",
                StackTransitionType::SlideDown => "SlideDown",
                StackTransitionType::SlideLeftRight => "SlideLeftRight",
                StackTransitionType::SlideUpDown => "SlideUpDown",
                StackTransitionType::OverUp => "OverUp",
                StackTransitionType::OverDown => "OverDown",
                StackTransitionType::OverLeft => "OverLeft",
                StackTransitionType::OverRight => "OverRight",
                StackTransitionType::UnderUp => "UnderUp",
                StackTransitionType::UnderDown => "UnderDown",
                StackTransitionType::UnderLeft => "UnderLeft",
                StackTransitionType::UnderRight => "UnderRight",
                StackTransitionType::OverUpDown => "OverUpDown",
                StackTransitionType::OverDownUp => "OverDownUp",
                StackTransitionType::OverLeftRight => "OverLeftRight",
                StackTransitionType::OverRightLeft => "OverRightLeft",
                StackTransitionType::RotateLeft => "RotateLeft",
                StackTransitionType::RotateRight => "RotateRight",
                StackTransitionType::RotateLeftRight => "RotateLeftRight",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StackTransitionType {
    type GlibType = ffi::GtkStackTransitionType;

    fn to_glib(&self) -> ffi::GtkStackTransitionType {
        match *self {
            StackTransitionType::None => ffi::GTK_STACK_TRANSITION_TYPE_NONE,
            StackTransitionType::Crossfade => ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE,
            StackTransitionType::SlideRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT,
            StackTransitionType::SlideLeft => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT,
            StackTransitionType::SlideUp => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP,
            StackTransitionType::SlideDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN,
            StackTransitionType::SlideLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT,
            StackTransitionType::SlideUpDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN,
            StackTransitionType::OverUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP,
            StackTransitionType::OverDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN,
            StackTransitionType::OverLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT,
            StackTransitionType::OverRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT,
            StackTransitionType::UnderUp => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP,
            StackTransitionType::UnderDown => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN,
            StackTransitionType::UnderLeft => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT,
            StackTransitionType::UnderRight => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT,
            StackTransitionType::OverUpDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN,
            StackTransitionType::OverDownUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP,
            StackTransitionType::OverLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT,
            StackTransitionType::OverRightLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT,
            StackTransitionType::RotateLeft => ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT,
            StackTransitionType::RotateRight => ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_RIGHT,
            StackTransitionType::RotateLeftRight => {
                ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT_RIGHT
            }
            StackTransitionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStackTransitionType> for StackTransitionType {
    fn from_glib(value: ffi::GtkStackTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StackTransitionType::None,
            1 => StackTransitionType::Crossfade,
            2 => StackTransitionType::SlideRight,
            3 => StackTransitionType::SlideLeft,
            4 => StackTransitionType::SlideUp,
            5 => StackTransitionType::SlideDown,
            6 => StackTransitionType::SlideLeftRight,
            7 => StackTransitionType::SlideUpDown,
            8 => StackTransitionType::OverUp,
            9 => StackTransitionType::OverDown,
            10 => StackTransitionType::OverLeft,
            11 => StackTransitionType::OverRight,
            12 => StackTransitionType::UnderUp,
            13 => StackTransitionType::UnderDown,
            14 => StackTransitionType::UnderLeft,
            15 => StackTransitionType::UnderRight,
            16 => StackTransitionType::OverUpDown,
            17 => StackTransitionType::OverDownUp,
            18 => StackTransitionType::OverLeftRight,
            19 => StackTransitionType::OverRightLeft,
            20 => StackTransitionType::RotateLeft,
            21 => StackTransitionType::RotateRight,
            22 => StackTransitionType::RotateLeftRight,
            value => StackTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for StackTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_stack_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StackTransitionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StackTransitionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StackTransitionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StringFilterMatchMode {
    Exact,
    Substring,
    Prefix,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StringFilterMatchMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StringFilterMatchMode::{}",
            match *self {
                StringFilterMatchMode::Exact => "Exact",
                StringFilterMatchMode::Substring => "Substring",
                StringFilterMatchMode::Prefix => "Prefix",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StringFilterMatchMode {
    type GlibType = ffi::GtkStringFilterMatchMode;

    fn to_glib(&self) -> ffi::GtkStringFilterMatchMode {
        match *self {
            StringFilterMatchMode::Exact => ffi::GTK_STRING_FILTER_MATCH_MODE_EXACT,
            StringFilterMatchMode::Substring => ffi::GTK_STRING_FILTER_MATCH_MODE_SUBSTRING,
            StringFilterMatchMode::Prefix => ffi::GTK_STRING_FILTER_MATCH_MODE_PREFIX,
            StringFilterMatchMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStringFilterMatchMode> for StringFilterMatchMode {
    fn from_glib(value: ffi::GtkStringFilterMatchMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StringFilterMatchMode::Exact,
            1 => StringFilterMatchMode::Substring,
            2 => StringFilterMatchMode::Prefix,
            value => StringFilterMatchMode::__Unknown(value),
        }
    }
}

impl StaticType for StringFilterMatchMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_string_filter_match_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StringFilterMatchMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StringFilterMatchMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StringFilterMatchMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SystemSetting {
    Dpi,
    FontName,
    FontConfig,
    Display,
    IconTheme,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SystemSetting {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SystemSetting::{}",
            match *self {
                SystemSetting::Dpi => "Dpi",
                SystemSetting::FontName => "FontName",
                SystemSetting::FontConfig => "FontConfig",
                SystemSetting::Display => "Display",
                SystemSetting::IconTheme => "IconTheme",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SystemSetting {
    type GlibType = ffi::GtkSystemSetting;

    fn to_glib(&self) -> ffi::GtkSystemSetting {
        match *self {
            SystemSetting::Dpi => ffi::GTK_SYSTEM_SETTING_DPI,
            SystemSetting::FontName => ffi::GTK_SYSTEM_SETTING_FONT_NAME,
            SystemSetting::FontConfig => ffi::GTK_SYSTEM_SETTING_FONT_CONFIG,
            SystemSetting::Display => ffi::GTK_SYSTEM_SETTING_DISPLAY,
            SystemSetting::IconTheme => ffi::GTK_SYSTEM_SETTING_ICON_THEME,
            SystemSetting::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSystemSetting> for SystemSetting {
    fn from_glib(value: ffi::GtkSystemSetting) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SystemSetting::Dpi,
            1 => SystemSetting::FontName,
            2 => SystemSetting::FontConfig,
            3 => SystemSetting::Display,
            4 => SystemSetting::IconTheme,
            value => SystemSetting::__Unknown(value),
        }
    }
}

impl StaticType for SystemSetting {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_system_setting_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SystemSetting {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SystemSetting {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SystemSetting {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextDirection {
    None,
    Ltr,
    Rtl,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextDirection::{}",
            match *self {
                TextDirection::None => "None",
                TextDirection::Ltr => "Ltr",
                TextDirection::Rtl => "Rtl",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextDirection {
    type GlibType = ffi::GtkTextDirection;

    fn to_glib(&self) -> ffi::GtkTextDirection {
        match *self {
            TextDirection::None => ffi::GTK_TEXT_DIR_NONE,
            TextDirection::Ltr => ffi::GTK_TEXT_DIR_LTR,
            TextDirection::Rtl => ffi::GTK_TEXT_DIR_RTL,
            TextDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextDirection> for TextDirection {
    fn from_glib(value: ffi::GtkTextDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextDirection::None,
            1 => TextDirection::Ltr,
            2 => TextDirection::Rtl,
            value => TextDirection::__Unknown(value),
        }
    }
}

impl StaticType for TextDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextExtendSelection {
    Word,
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextExtendSelection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextExtendSelection::{}",
            match *self {
                TextExtendSelection::Word => "Word",
                TextExtendSelection::Line => "Line",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextExtendSelection {
    type GlibType = ffi::GtkTextExtendSelection;

    fn to_glib(&self) -> ffi::GtkTextExtendSelection {
        match *self {
            TextExtendSelection::Word => ffi::GTK_TEXT_EXTEND_SELECTION_WORD,
            TextExtendSelection::Line => ffi::GTK_TEXT_EXTEND_SELECTION_LINE,
            TextExtendSelection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextExtendSelection> for TextExtendSelection {
    fn from_glib(value: ffi::GtkTextExtendSelection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextExtendSelection::Word,
            1 => TextExtendSelection::Line,
            value => TextExtendSelection::__Unknown(value),
        }
    }
}

impl StaticType for TextExtendSelection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_extend_selection_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextExtendSelection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextExtendSelection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextExtendSelection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextViewLayer {
    BelowText,
    AboveText,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextViewLayer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextViewLayer::{}",
            match *self {
                TextViewLayer::BelowText => "BelowText",
                TextViewLayer::AboveText => "AboveText",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextViewLayer {
    type GlibType = ffi::GtkTextViewLayer;

    fn to_glib(&self) -> ffi::GtkTextViewLayer {
        match *self {
            TextViewLayer::BelowText => ffi::GTK_TEXT_VIEW_LAYER_BELOW_TEXT,
            TextViewLayer::AboveText => ffi::GTK_TEXT_VIEW_LAYER_ABOVE_TEXT,
            TextViewLayer::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextViewLayer> for TextViewLayer {
    fn from_glib(value: ffi::GtkTextViewLayer) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextViewLayer::BelowText,
            1 => TextViewLayer::AboveText,
            value => TextViewLayer::__Unknown(value),
        }
    }
}

impl StaticType for TextViewLayer {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_view_layer_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextViewLayer {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextViewLayer {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextViewLayer {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextWindowType {
    Widget,
    Text,
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextWindowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextWindowType::{}",
            match *self {
                TextWindowType::Widget => "Widget",
                TextWindowType::Text => "Text",
                TextWindowType::Left => "Left",
                TextWindowType::Right => "Right",
                TextWindowType::Top => "Top",
                TextWindowType::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextWindowType {
    type GlibType = ffi::GtkTextWindowType;

    fn to_glib(&self) -> ffi::GtkTextWindowType {
        match *self {
            TextWindowType::Widget => ffi::GTK_TEXT_WINDOW_WIDGET,
            TextWindowType::Text => ffi::GTK_TEXT_WINDOW_TEXT,
            TextWindowType::Left => ffi::GTK_TEXT_WINDOW_LEFT,
            TextWindowType::Right => ffi::GTK_TEXT_WINDOW_RIGHT,
            TextWindowType::Top => ffi::GTK_TEXT_WINDOW_TOP,
            TextWindowType::Bottom => ffi::GTK_TEXT_WINDOW_BOTTOM,
            TextWindowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextWindowType> for TextWindowType {
    fn from_glib(value: ffi::GtkTextWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => TextWindowType::Widget,
            2 => TextWindowType::Text,
            3 => TextWindowType::Left,
            4 => TextWindowType::Right,
            5 => TextWindowType::Top,
            6 => TextWindowType::Bottom,
            value => TextWindowType::__Unknown(value),
        }
    }
}

impl StaticType for TextWindowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_window_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextWindowType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextWindowType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextWindowType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TreeViewColumnSizing {
    GrowOnly,
    Autosize,
    Fixed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewColumnSizing {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewColumnSizing::{}",
            match *self {
                TreeViewColumnSizing::GrowOnly => "GrowOnly",
                TreeViewColumnSizing::Autosize => "Autosize",
                TreeViewColumnSizing::Fixed => "Fixed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewColumnSizing {
    type GlibType = ffi::GtkTreeViewColumnSizing;

    fn to_glib(&self) -> ffi::GtkTreeViewColumnSizing {
        match *self {
            TreeViewColumnSizing::GrowOnly => ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY,
            TreeViewColumnSizing::Autosize => ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE,
            TreeViewColumnSizing::Fixed => ffi::GTK_TREE_VIEW_COLUMN_FIXED,
            TreeViewColumnSizing::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewColumnSizing> for TreeViewColumnSizing {
    fn from_glib(value: ffi::GtkTreeViewColumnSizing) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewColumnSizing::GrowOnly,
            1 => TreeViewColumnSizing::Autosize,
            2 => TreeViewColumnSizing::Fixed,
            value => TreeViewColumnSizing::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewColumnSizing {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_column_sizing_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewColumnSizing {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewColumnSizing {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewColumnSizing {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TreeViewDropPosition {
    Before,
    After,
    IntoOrBefore,
    IntoOrAfter,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewDropPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewDropPosition::{}",
            match *self {
                TreeViewDropPosition::Before => "Before",
                TreeViewDropPosition::After => "After",
                TreeViewDropPosition::IntoOrBefore => "IntoOrBefore",
                TreeViewDropPosition::IntoOrAfter => "IntoOrAfter",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewDropPosition {
    type GlibType = ffi::GtkTreeViewDropPosition;

    fn to_glib(&self) -> ffi::GtkTreeViewDropPosition {
        match *self {
            TreeViewDropPosition::Before => ffi::GTK_TREE_VIEW_DROP_BEFORE,
            TreeViewDropPosition::After => ffi::GTK_TREE_VIEW_DROP_AFTER,
            TreeViewDropPosition::IntoOrBefore => ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
            TreeViewDropPosition::IntoOrAfter => ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER,
            TreeViewDropPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewDropPosition> for TreeViewDropPosition {
    fn from_glib(value: ffi::GtkTreeViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewDropPosition::Before,
            1 => TreeViewDropPosition::After,
            2 => TreeViewDropPosition::IntoOrBefore,
            3 => TreeViewDropPosition::IntoOrAfter,
            value => TreeViewDropPosition::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewDropPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_drop_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewDropPosition {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewDropPosition {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewDropPosition {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TreeViewGridLines {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewGridLines {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewGridLines::{}",
            match *self {
                TreeViewGridLines::None => "None",
                TreeViewGridLines::Horizontal => "Horizontal",
                TreeViewGridLines::Vertical => "Vertical",
                TreeViewGridLines::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewGridLines {
    type GlibType = ffi::GtkTreeViewGridLines;

    fn to_glib(&self) -> ffi::GtkTreeViewGridLines {
        match *self {
            TreeViewGridLines::None => ffi::GTK_TREE_VIEW_GRID_LINES_NONE,
            TreeViewGridLines::Horizontal => ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
            TreeViewGridLines::Vertical => ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL,
            TreeViewGridLines::Both => ffi::GTK_TREE_VIEW_GRID_LINES_BOTH,
            TreeViewGridLines::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewGridLines> for TreeViewGridLines {
    fn from_glib(value: ffi::GtkTreeViewGridLines) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewGridLines::None,
            1 => TreeViewGridLines::Horizontal,
            2 => TreeViewGridLines::Vertical,
            3 => TreeViewGridLines::Both,
            value => TreeViewGridLines::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewGridLines {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_grid_lines_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewGridLines {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewGridLines {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewGridLines {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Unit {
    None,
    Points,
    Inch,
    Mm,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Unit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Unit::{}",
            match *self {
                Unit::None => "None",
                Unit::Points => "Points",
                Unit::Inch => "Inch",
                Unit::Mm => "Mm",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Unit {
    type GlibType = ffi::GtkUnit;

    fn to_glib(&self) -> ffi::GtkUnit {
        match *self {
            Unit::None => ffi::GTK_UNIT_NONE,
            Unit::Points => ffi::GTK_UNIT_POINTS,
            Unit::Inch => ffi::GTK_UNIT_INCH,
            Unit::Mm => ffi::GTK_UNIT_MM,
            Unit::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkUnit> for Unit {
    fn from_glib(value: ffi::GtkUnit) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Unit::None,
            1 => Unit::Points,
            2 => Unit::Inch,
            3 => Unit::Mm,
            value => Unit::__Unknown(value),
        }
    }
}

impl StaticType for Unit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_unit_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Unit {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Unit {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Unit {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WrapMode {
    None,
    Char,
    Word,
    WordChar,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WrapMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WrapMode::{}",
            match *self {
                WrapMode::None => "None",
                WrapMode::Char => "Char",
                WrapMode::Word => "Word",
                WrapMode::WordChar => "WordChar",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WrapMode {
    type GlibType = ffi::GtkWrapMode;

    fn to_glib(&self) -> ffi::GtkWrapMode {
        match *self {
            WrapMode::None => ffi::GTK_WRAP_NONE,
            WrapMode::Char => ffi::GTK_WRAP_CHAR,
            WrapMode::Word => ffi::GTK_WRAP_WORD,
            WrapMode::WordChar => ffi::GTK_WRAP_WORD_CHAR,
            WrapMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWrapMode> for WrapMode {
    fn from_glib(value: ffi::GtkWrapMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WrapMode::None,
            1 => WrapMode::Char,
            2 => WrapMode::Word,
            3 => WrapMode::WordChar,
            value => WrapMode::__Unknown(value),
        }
    }
}

impl StaticType for WrapMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_wrap_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WrapMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WrapMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WrapMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
