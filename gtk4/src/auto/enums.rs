// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::{prelude::*, translate::*};

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleAnnouncementPriority")]
pub enum AccessibleAnnouncementPriority {
    #[doc(alias = "GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_LOW")]
    Low,
    #[doc(alias = "GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_MEDIUM")]
    Medium,
    #[doc(alias = "GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_HIGH")]
    High,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for AccessibleAnnouncementPriority {
    type GlibType = ffi::GtkAccessibleAnnouncementPriority;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleAnnouncementPriority {
        match self {
            Self::Low => ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_LOW,
            Self::Medium => ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_MEDIUM,
            Self::High => ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_HIGH,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleAnnouncementPriority> for AccessibleAnnouncementPriority {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleAnnouncementPriority) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_LOW => Self::Low,
            ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_MEDIUM => Self::Medium,
            ffi::GTK_ACCESSIBLE_ANNOUNCEMENT_PRIORITY_HIGH => Self::High,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for AccessibleAnnouncementPriority {
    #[inline]
    #[doc(alias = "gtk_accessible_announcement_priority_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_announcement_priority_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for AccessibleAnnouncementPriority {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for AccessibleAnnouncementPriority {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for AccessibleAnnouncementPriority {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for AccessibleAnnouncementPriority {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<AccessibleAnnouncementPriority> for glib::Value {
    #[inline]
    fn from(v: AccessibleAnnouncementPriority) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleAutocomplete")]
pub enum AccessibleAutocomplete {
    #[doc(alias = "GTK_ACCESSIBLE_AUTOCOMPLETE_NONE")]
    None,
    #[doc(alias = "GTK_ACCESSIBLE_AUTOCOMPLETE_INLINE")]
    Inline,
    #[doc(alias = "GTK_ACCESSIBLE_AUTOCOMPLETE_LIST")]
    List,
    #[doc(alias = "GTK_ACCESSIBLE_AUTOCOMPLETE_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AccessibleAutocomplete {
    type GlibType = ffi::GtkAccessibleAutocomplete;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleAutocomplete {
        match self {
            Self::None => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_NONE,
            Self::Inline => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_INLINE,
            Self::List => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_LIST,
            Self::Both => ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_BOTH,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleAutocomplete> for AccessibleAutocomplete {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleAutocomplete) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_NONE => Self::None,
            ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_INLINE => Self::Inline,
            ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_LIST => Self::List,
            ffi::GTK_ACCESSIBLE_AUTOCOMPLETE_BOTH => Self::Both,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleAutocomplete {
    #[inline]
    #[doc(alias = "gtk_accessible_autocomplete_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_autocomplete_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleAutocomplete {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleAutocomplete {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleAutocomplete {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleAutocomplete {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleAutocomplete> for glib::Value {
    #[inline]
    fn from(v: AccessibleAutocomplete) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleInvalidState")]
pub enum AccessibleInvalidState {
    #[doc(alias = "GTK_ACCESSIBLE_INVALID_FALSE")]
    False,
    #[doc(alias = "GTK_ACCESSIBLE_INVALID_TRUE")]
    True,
    #[doc(alias = "GTK_ACCESSIBLE_INVALID_GRAMMAR")]
    Grammar,
    #[doc(alias = "GTK_ACCESSIBLE_INVALID_SPELLING")]
    Spelling,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AccessibleInvalidState {
    type GlibType = ffi::GtkAccessibleInvalidState;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleInvalidState {
        match self {
            Self::False => ffi::GTK_ACCESSIBLE_INVALID_FALSE,
            Self::True => ffi::GTK_ACCESSIBLE_INVALID_TRUE,
            Self::Grammar => ffi::GTK_ACCESSIBLE_INVALID_GRAMMAR,
            Self::Spelling => ffi::GTK_ACCESSIBLE_INVALID_SPELLING,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleInvalidState> for AccessibleInvalidState {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleInvalidState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_INVALID_FALSE => Self::False,
            ffi::GTK_ACCESSIBLE_INVALID_TRUE => Self::True,
            ffi::GTK_ACCESSIBLE_INVALID_GRAMMAR => Self::Grammar,
            ffi::GTK_ACCESSIBLE_INVALID_SPELLING => Self::Spelling,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleInvalidState {
    #[inline]
    #[doc(alias = "gtk_accessible_invalid_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_invalid_state_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleInvalidState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleInvalidState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleInvalidState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleInvalidState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleInvalidState> for glib::Value {
    #[inline]
    fn from(v: AccessibleInvalidState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessiblePlatformState")]
pub enum AccessiblePlatformState {
    #[doc(alias = "GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSABLE")]
    Focusable,
    #[doc(alias = "GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSED")]
    Focused,
    #[doc(alias = "GTK_ACCESSIBLE_PLATFORM_STATE_ACTIVE")]
    Active,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl IntoGlib for AccessiblePlatformState {
    type GlibType = ffi::GtkAccessiblePlatformState;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessiblePlatformState {
        match self {
            Self::Focusable => ffi::GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSABLE,
            Self::Focused => ffi::GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSED,
            Self::Active => ffi::GTK_ACCESSIBLE_PLATFORM_STATE_ACTIVE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkAccessiblePlatformState> for AccessiblePlatformState {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessiblePlatformState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSABLE => Self::Focusable,
            ffi::GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSED => Self::Focused,
            ffi::GTK_ACCESSIBLE_PLATFORM_STATE_ACTIVE => Self::Active,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl StaticType for AccessiblePlatformState {
    #[inline]
    #[doc(alias = "gtk_accessible_platform_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_platform_state_get_type()) }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::HasParamSpec for AccessiblePlatformState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::value::ValueType for AccessiblePlatformState {
    type Type = Self;
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for AccessiblePlatformState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl ToValue for AccessiblePlatformState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl From<AccessiblePlatformState> for glib::Value {
    #[inline]
    fn from(v: AccessiblePlatformState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleProperty")]
pub enum AccessibleProperty {
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE")]
    Autocomplete,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_DESCRIPTION")]
    Description,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_HAS_POPUP")]
    HasPopup,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_KEY_SHORTCUTS")]
    KeyShortcuts,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_LABEL")]
    Label,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_LEVEL")]
    Level,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_MODAL")]
    Modal,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_MULTI_LINE")]
    MultiLine,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_MULTI_SELECTABLE")]
    MultiSelectable,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_ORIENTATION")]
    Orientation,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_PLACEHOLDER")]
    Placeholder,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_READ_ONLY")]
    ReadOnly,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_REQUIRED")]
    Required,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_ROLE_DESCRIPTION")]
    RoleDescription,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_SORT")]
    Sort,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_VALUE_MAX")]
    ValueMax,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_VALUE_MIN")]
    ValueMin,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_VALUE_NOW")]
    ValueNow,
    #[doc(alias = "GTK_ACCESSIBLE_PROPERTY_VALUE_TEXT")]
    ValueText,
    #[doc(hidden)]
    __Unknown(i32),
}

impl AccessibleProperty {
    #[doc(alias = "gtk_accessible_property_init_value")]
    pub fn init_value(self, value: &mut glib::Value) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gtk_accessible_property_init_value(self.into_glib(), value.to_glib_none_mut().0);
        }
    }
}

#[doc(hidden)]
impl IntoGlib for AccessibleProperty {
    type GlibType = ffi::GtkAccessibleProperty;

    fn into_glib(self) -> ffi::GtkAccessibleProperty {
        match self {
            Self::Autocomplete => ffi::GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE,
            Self::Description => ffi::GTK_ACCESSIBLE_PROPERTY_DESCRIPTION,
            Self::HasPopup => ffi::GTK_ACCESSIBLE_PROPERTY_HAS_POPUP,
            Self::KeyShortcuts => ffi::GTK_ACCESSIBLE_PROPERTY_KEY_SHORTCUTS,
            Self::Label => ffi::GTK_ACCESSIBLE_PROPERTY_LABEL,
            Self::Level => ffi::GTK_ACCESSIBLE_PROPERTY_LEVEL,
            Self::Modal => ffi::GTK_ACCESSIBLE_PROPERTY_MODAL,
            Self::MultiLine => ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_LINE,
            Self::MultiSelectable => ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_SELECTABLE,
            Self::Orientation => ffi::GTK_ACCESSIBLE_PROPERTY_ORIENTATION,
            Self::Placeholder => ffi::GTK_ACCESSIBLE_PROPERTY_PLACEHOLDER,
            Self::ReadOnly => ffi::GTK_ACCESSIBLE_PROPERTY_READ_ONLY,
            Self::Required => ffi::GTK_ACCESSIBLE_PROPERTY_REQUIRED,
            Self::RoleDescription => ffi::GTK_ACCESSIBLE_PROPERTY_ROLE_DESCRIPTION,
            Self::Sort => ffi::GTK_ACCESSIBLE_PROPERTY_SORT,
            Self::ValueMax => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MAX,
            Self::ValueMin => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MIN,
            Self::ValueNow => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_NOW,
            Self::ValueText => ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_TEXT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleProperty> for AccessibleProperty {
    unsafe fn from_glib(value: ffi::GtkAccessibleProperty) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE => Self::Autocomplete,
            ffi::GTK_ACCESSIBLE_PROPERTY_DESCRIPTION => Self::Description,
            ffi::GTK_ACCESSIBLE_PROPERTY_HAS_POPUP => Self::HasPopup,
            ffi::GTK_ACCESSIBLE_PROPERTY_KEY_SHORTCUTS => Self::KeyShortcuts,
            ffi::GTK_ACCESSIBLE_PROPERTY_LABEL => Self::Label,
            ffi::GTK_ACCESSIBLE_PROPERTY_LEVEL => Self::Level,
            ffi::GTK_ACCESSIBLE_PROPERTY_MODAL => Self::Modal,
            ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_LINE => Self::MultiLine,
            ffi::GTK_ACCESSIBLE_PROPERTY_MULTI_SELECTABLE => Self::MultiSelectable,
            ffi::GTK_ACCESSIBLE_PROPERTY_ORIENTATION => Self::Orientation,
            ffi::GTK_ACCESSIBLE_PROPERTY_PLACEHOLDER => Self::Placeholder,
            ffi::GTK_ACCESSIBLE_PROPERTY_READ_ONLY => Self::ReadOnly,
            ffi::GTK_ACCESSIBLE_PROPERTY_REQUIRED => Self::Required,
            ffi::GTK_ACCESSIBLE_PROPERTY_ROLE_DESCRIPTION => Self::RoleDescription,
            ffi::GTK_ACCESSIBLE_PROPERTY_SORT => Self::Sort,
            ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MAX => Self::ValueMax,
            ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_MIN => Self::ValueMin,
            ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_NOW => Self::ValueNow,
            ffi::GTK_ACCESSIBLE_PROPERTY_VALUE_TEXT => Self::ValueText,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleProperty {
    #[inline]
    #[doc(alias = "gtk_accessible_property_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_property_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleProperty {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleProperty {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleProperty {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleProperty {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleProperty> for glib::Value {
    #[inline]
    fn from(v: AccessibleProperty) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleRelation")]
pub enum AccessibleRelation {
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ACTIVE_DESCENDANT")]
    ActiveDescendant,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_COL_COUNT")]
    ColCount,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_COL_INDEX")]
    ColIndex,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_COL_INDEX_TEXT")]
    ColIndexText,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_COL_SPAN")]
    ColSpan,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_CONTROLS")]
    Controls,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_DESCRIBED_BY")]
    DescribedBy,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_DETAILS")]
    Details,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ERROR_MESSAGE")]
    ErrorMessage,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_FLOW_TO")]
    FlowTo,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_LABELLED_BY")]
    LabelledBy,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_OWNS")]
    Owns,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_POS_IN_SET")]
    PosInSet,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ROW_COUNT")]
    RowCount,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ROW_INDEX")]
    RowIndex,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ROW_INDEX_TEXT")]
    RowIndexText,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_ROW_SPAN")]
    RowSpan,
    #[doc(alias = "GTK_ACCESSIBLE_RELATION_SET_SIZE")]
    SetSize,
    #[doc(hidden)]
    __Unknown(i32),
}

impl AccessibleRelation {
    #[doc(alias = "gtk_accessible_relation_init_value")]
    pub fn init_value(self, value: &mut glib::Value) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gtk_accessible_relation_init_value(self.into_glib(), value.to_glib_none_mut().0);
        }
    }
}

#[doc(hidden)]
impl IntoGlib for AccessibleRelation {
    type GlibType = ffi::GtkAccessibleRelation;

    fn into_glib(self) -> ffi::GtkAccessibleRelation {
        match self {
            Self::ActiveDescendant => ffi::GTK_ACCESSIBLE_RELATION_ACTIVE_DESCENDANT,
            Self::ColCount => ffi::GTK_ACCESSIBLE_RELATION_COL_COUNT,
            Self::ColIndex => ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX,
            Self::ColIndexText => ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX_TEXT,
            Self::ColSpan => ffi::GTK_ACCESSIBLE_RELATION_COL_SPAN,
            Self::Controls => ffi::GTK_ACCESSIBLE_RELATION_CONTROLS,
            Self::DescribedBy => ffi::GTK_ACCESSIBLE_RELATION_DESCRIBED_BY,
            Self::Details => ffi::GTK_ACCESSIBLE_RELATION_DETAILS,
            Self::ErrorMessage => ffi::GTK_ACCESSIBLE_RELATION_ERROR_MESSAGE,
            Self::FlowTo => ffi::GTK_ACCESSIBLE_RELATION_FLOW_TO,
            Self::LabelledBy => ffi::GTK_ACCESSIBLE_RELATION_LABELLED_BY,
            Self::Owns => ffi::GTK_ACCESSIBLE_RELATION_OWNS,
            Self::PosInSet => ffi::GTK_ACCESSIBLE_RELATION_POS_IN_SET,
            Self::RowCount => ffi::GTK_ACCESSIBLE_RELATION_ROW_COUNT,
            Self::RowIndex => ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX,
            Self::RowIndexText => ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX_TEXT,
            Self::RowSpan => ffi::GTK_ACCESSIBLE_RELATION_ROW_SPAN,
            Self::SetSize => ffi::GTK_ACCESSIBLE_RELATION_SET_SIZE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleRelation> for AccessibleRelation {
    unsafe fn from_glib(value: ffi::GtkAccessibleRelation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_RELATION_ACTIVE_DESCENDANT => Self::ActiveDescendant,
            ffi::GTK_ACCESSIBLE_RELATION_COL_COUNT => Self::ColCount,
            ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX => Self::ColIndex,
            ffi::GTK_ACCESSIBLE_RELATION_COL_INDEX_TEXT => Self::ColIndexText,
            ffi::GTK_ACCESSIBLE_RELATION_COL_SPAN => Self::ColSpan,
            ffi::GTK_ACCESSIBLE_RELATION_CONTROLS => Self::Controls,
            ffi::GTK_ACCESSIBLE_RELATION_DESCRIBED_BY => Self::DescribedBy,
            ffi::GTK_ACCESSIBLE_RELATION_DETAILS => Self::Details,
            ffi::GTK_ACCESSIBLE_RELATION_ERROR_MESSAGE => Self::ErrorMessage,
            ffi::GTK_ACCESSIBLE_RELATION_FLOW_TO => Self::FlowTo,
            ffi::GTK_ACCESSIBLE_RELATION_LABELLED_BY => Self::LabelledBy,
            ffi::GTK_ACCESSIBLE_RELATION_OWNS => Self::Owns,
            ffi::GTK_ACCESSIBLE_RELATION_POS_IN_SET => Self::PosInSet,
            ffi::GTK_ACCESSIBLE_RELATION_ROW_COUNT => Self::RowCount,
            ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX => Self::RowIndex,
            ffi::GTK_ACCESSIBLE_RELATION_ROW_INDEX_TEXT => Self::RowIndexText,
            ffi::GTK_ACCESSIBLE_RELATION_ROW_SPAN => Self::RowSpan,
            ffi::GTK_ACCESSIBLE_RELATION_SET_SIZE => Self::SetSize,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleRelation {
    #[inline]
    #[doc(alias = "gtk_accessible_relation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_relation_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleRelation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleRelation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleRelation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleRelation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleRelation> for glib::Value {
    #[inline]
    fn from(v: AccessibleRelation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleRole")]
pub enum AccessibleRole {
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ALERT")]
    Alert,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ALERT_DIALOG")]
    AlertDialog,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_BANNER")]
    Banner,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_BUTTON")]
    Button,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_CAPTION")]
    Caption,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_CELL")]
    Cell,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_CHECKBOX")]
    Checkbox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_COLUMN_HEADER")]
    ColumnHeader,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_COMBO_BOX")]
    ComboBox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_COMMAND")]
    Command,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_COMPOSITE")]
    Composite,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_DIALOG")]
    Dialog,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_DOCUMENT")]
    Document,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_FEED")]
    Feed,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_FORM")]
    Form,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_GENERIC")]
    Generic,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_GRID")]
    Grid,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_GRID_CELL")]
    GridCell,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_GROUP")]
    Group,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_HEADING")]
    Heading,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_IMG")]
    Img,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_INPUT")]
    Input,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LABEL")]
    Label,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LANDMARK")]
    Landmark,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LEGEND")]
    Legend,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LINK")]
    Link,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LIST")]
    List,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LIST_BOX")]
    ListBox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LIST_ITEM")]
    ListItem,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_LOG")]
    Log,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MAIN")]
    Main,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MARQUEE")]
    Marquee,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MATH")]
    Math,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_METER")]
    Meter,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MENU")]
    Menu,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MENU_BAR")]
    MenuBar,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MENU_ITEM")]
    MenuItem,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX")]
    MenuItemCheckbox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO")]
    MenuItemRadio,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_NAVIGATION")]
    Navigation,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_NONE")]
    None,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_NOTE")]
    Note,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_OPTION")]
    Option,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_PRESENTATION")]
    Presentation,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_PROGRESS_BAR")]
    ProgressBar,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_RADIO")]
    Radio,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_RADIO_GROUP")]
    RadioGroup,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_RANGE")]
    Range,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_REGION")]
    Region,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ROW")]
    Row,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ROW_GROUP")]
    RowGroup,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ROW_HEADER")]
    RowHeader,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SCROLLBAR")]
    Scrollbar,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SEARCH")]
    Search,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SEARCH_BOX")]
    SearchBox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SECTION")]
    Section,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SECTION_HEAD")]
    SectionHead,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SELECT")]
    Select,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SEPARATOR")]
    Separator,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SLIDER")]
    Slider,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SPIN_BUTTON")]
    SpinButton,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_STATUS")]
    Status,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_STRUCTURE")]
    Structure,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_SWITCH")]
    Switch,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TAB")]
    Tab,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TABLE")]
    Table,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TAB_LIST")]
    TabList,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TAB_PANEL")]
    TabPanel,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TEXT_BOX")]
    TextBox,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TIME")]
    Time,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TIMER")]
    Timer,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TOOLBAR")]
    Toolbar,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TOOLTIP")]
    Tooltip,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TREE")]
    Tree,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TREE_GRID")]
    TreeGrid,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TREE_ITEM")]
    TreeItem,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_WIDGET")]
    Widget,
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_WINDOW")]
    Window,
    #[cfg(feature = "v4_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TOGGLE_BUTTON")]
    ToggleButton,
    #[cfg(feature = "v4_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_APPLICATION")]
    Application,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_PARAGRAPH")]
    Paragraph,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_BLOCK_QUOTE")]
    BlockQuote,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_ARTICLE")]
    Article,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_COMMENT")]
    Comment,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_ACCESSIBLE_ROLE_TERMINAL")]
    Terminal,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AccessibleRole {
    type GlibType = ffi::GtkAccessibleRole;

    fn into_glib(self) -> ffi::GtkAccessibleRole {
        match self {
            Self::Alert => ffi::GTK_ACCESSIBLE_ROLE_ALERT,
            Self::AlertDialog => ffi::GTK_ACCESSIBLE_ROLE_ALERT_DIALOG,
            Self::Banner => ffi::GTK_ACCESSIBLE_ROLE_BANNER,
            Self::Button => ffi::GTK_ACCESSIBLE_ROLE_BUTTON,
            Self::Caption => ffi::GTK_ACCESSIBLE_ROLE_CAPTION,
            Self::Cell => ffi::GTK_ACCESSIBLE_ROLE_CELL,
            Self::Checkbox => ffi::GTK_ACCESSIBLE_ROLE_CHECKBOX,
            Self::ColumnHeader => ffi::GTK_ACCESSIBLE_ROLE_COLUMN_HEADER,
            Self::ComboBox => ffi::GTK_ACCESSIBLE_ROLE_COMBO_BOX,
            Self::Command => ffi::GTK_ACCESSIBLE_ROLE_COMMAND,
            Self::Composite => ffi::GTK_ACCESSIBLE_ROLE_COMPOSITE,
            Self::Dialog => ffi::GTK_ACCESSIBLE_ROLE_DIALOG,
            Self::Document => ffi::GTK_ACCESSIBLE_ROLE_DOCUMENT,
            Self::Feed => ffi::GTK_ACCESSIBLE_ROLE_FEED,
            Self::Form => ffi::GTK_ACCESSIBLE_ROLE_FORM,
            Self::Generic => ffi::GTK_ACCESSIBLE_ROLE_GENERIC,
            Self::Grid => ffi::GTK_ACCESSIBLE_ROLE_GRID,
            Self::GridCell => ffi::GTK_ACCESSIBLE_ROLE_GRID_CELL,
            Self::Group => ffi::GTK_ACCESSIBLE_ROLE_GROUP,
            Self::Heading => ffi::GTK_ACCESSIBLE_ROLE_HEADING,
            Self::Img => ffi::GTK_ACCESSIBLE_ROLE_IMG,
            Self::Input => ffi::GTK_ACCESSIBLE_ROLE_INPUT,
            Self::Label => ffi::GTK_ACCESSIBLE_ROLE_LABEL,
            Self::Landmark => ffi::GTK_ACCESSIBLE_ROLE_LANDMARK,
            Self::Legend => ffi::GTK_ACCESSIBLE_ROLE_LEGEND,
            Self::Link => ffi::GTK_ACCESSIBLE_ROLE_LINK,
            Self::List => ffi::GTK_ACCESSIBLE_ROLE_LIST,
            Self::ListBox => ffi::GTK_ACCESSIBLE_ROLE_LIST_BOX,
            Self::ListItem => ffi::GTK_ACCESSIBLE_ROLE_LIST_ITEM,
            Self::Log => ffi::GTK_ACCESSIBLE_ROLE_LOG,
            Self::Main => ffi::GTK_ACCESSIBLE_ROLE_MAIN,
            Self::Marquee => ffi::GTK_ACCESSIBLE_ROLE_MARQUEE,
            Self::Math => ffi::GTK_ACCESSIBLE_ROLE_MATH,
            Self::Meter => ffi::GTK_ACCESSIBLE_ROLE_METER,
            Self::Menu => ffi::GTK_ACCESSIBLE_ROLE_MENU,
            Self::MenuBar => ffi::GTK_ACCESSIBLE_ROLE_MENU_BAR,
            Self::MenuItem => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM,
            Self::MenuItemCheckbox => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX,
            Self::MenuItemRadio => ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO,
            Self::Navigation => ffi::GTK_ACCESSIBLE_ROLE_NAVIGATION,
            Self::None => ffi::GTK_ACCESSIBLE_ROLE_NONE,
            Self::Note => ffi::GTK_ACCESSIBLE_ROLE_NOTE,
            Self::Option => ffi::GTK_ACCESSIBLE_ROLE_OPTION,
            Self::Presentation => ffi::GTK_ACCESSIBLE_ROLE_PRESENTATION,
            Self::ProgressBar => ffi::GTK_ACCESSIBLE_ROLE_PROGRESS_BAR,
            Self::Radio => ffi::GTK_ACCESSIBLE_ROLE_RADIO,
            Self::RadioGroup => ffi::GTK_ACCESSIBLE_ROLE_RADIO_GROUP,
            Self::Range => ffi::GTK_ACCESSIBLE_ROLE_RANGE,
            Self::Region => ffi::GTK_ACCESSIBLE_ROLE_REGION,
            Self::Row => ffi::GTK_ACCESSIBLE_ROLE_ROW,
            Self::RowGroup => ffi::GTK_ACCESSIBLE_ROLE_ROW_GROUP,
            Self::RowHeader => ffi::GTK_ACCESSIBLE_ROLE_ROW_HEADER,
            Self::Scrollbar => ffi::GTK_ACCESSIBLE_ROLE_SCROLLBAR,
            Self::Search => ffi::GTK_ACCESSIBLE_ROLE_SEARCH,
            Self::SearchBox => ffi::GTK_ACCESSIBLE_ROLE_SEARCH_BOX,
            Self::Section => ffi::GTK_ACCESSIBLE_ROLE_SECTION,
            Self::SectionHead => ffi::GTK_ACCESSIBLE_ROLE_SECTION_HEAD,
            Self::Select => ffi::GTK_ACCESSIBLE_ROLE_SELECT,
            Self::Separator => ffi::GTK_ACCESSIBLE_ROLE_SEPARATOR,
            Self::Slider => ffi::GTK_ACCESSIBLE_ROLE_SLIDER,
            Self::SpinButton => ffi::GTK_ACCESSIBLE_ROLE_SPIN_BUTTON,
            Self::Status => ffi::GTK_ACCESSIBLE_ROLE_STATUS,
            Self::Structure => ffi::GTK_ACCESSIBLE_ROLE_STRUCTURE,
            Self::Switch => ffi::GTK_ACCESSIBLE_ROLE_SWITCH,
            Self::Tab => ffi::GTK_ACCESSIBLE_ROLE_TAB,
            Self::Table => ffi::GTK_ACCESSIBLE_ROLE_TABLE,
            Self::TabList => ffi::GTK_ACCESSIBLE_ROLE_TAB_LIST,
            Self::TabPanel => ffi::GTK_ACCESSIBLE_ROLE_TAB_PANEL,
            Self::TextBox => ffi::GTK_ACCESSIBLE_ROLE_TEXT_BOX,
            Self::Time => ffi::GTK_ACCESSIBLE_ROLE_TIME,
            Self::Timer => ffi::GTK_ACCESSIBLE_ROLE_TIMER,
            Self::Toolbar => ffi::GTK_ACCESSIBLE_ROLE_TOOLBAR,
            Self::Tooltip => ffi::GTK_ACCESSIBLE_ROLE_TOOLTIP,
            Self::Tree => ffi::GTK_ACCESSIBLE_ROLE_TREE,
            Self::TreeGrid => ffi::GTK_ACCESSIBLE_ROLE_TREE_GRID,
            Self::TreeItem => ffi::GTK_ACCESSIBLE_ROLE_TREE_ITEM,
            Self::Widget => ffi::GTK_ACCESSIBLE_ROLE_WIDGET,
            Self::Window => ffi::GTK_ACCESSIBLE_ROLE_WINDOW,
            #[cfg(feature = "v4_10")]
            Self::ToggleButton => ffi::GTK_ACCESSIBLE_ROLE_TOGGLE_BUTTON,
            #[cfg(feature = "v4_12")]
            Self::Application => ffi::GTK_ACCESSIBLE_ROLE_APPLICATION,
            #[cfg(feature = "v4_14")]
            Self::Paragraph => ffi::GTK_ACCESSIBLE_ROLE_PARAGRAPH,
            #[cfg(feature = "v4_14")]
            Self::BlockQuote => ffi::GTK_ACCESSIBLE_ROLE_BLOCK_QUOTE,
            #[cfg(feature = "v4_14")]
            Self::Article => ffi::GTK_ACCESSIBLE_ROLE_ARTICLE,
            #[cfg(feature = "v4_14")]
            Self::Comment => ffi::GTK_ACCESSIBLE_ROLE_COMMENT,
            #[cfg(feature = "v4_14")]
            Self::Terminal => ffi::GTK_ACCESSIBLE_ROLE_TERMINAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleRole> for AccessibleRole {
    unsafe fn from_glib(value: ffi::GtkAccessibleRole) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_ROLE_ALERT => Self::Alert,
            ffi::GTK_ACCESSIBLE_ROLE_ALERT_DIALOG => Self::AlertDialog,
            ffi::GTK_ACCESSIBLE_ROLE_BANNER => Self::Banner,
            ffi::GTK_ACCESSIBLE_ROLE_BUTTON => Self::Button,
            ffi::GTK_ACCESSIBLE_ROLE_CAPTION => Self::Caption,
            ffi::GTK_ACCESSIBLE_ROLE_CELL => Self::Cell,
            ffi::GTK_ACCESSIBLE_ROLE_CHECKBOX => Self::Checkbox,
            ffi::GTK_ACCESSIBLE_ROLE_COLUMN_HEADER => Self::ColumnHeader,
            ffi::GTK_ACCESSIBLE_ROLE_COMBO_BOX => Self::ComboBox,
            ffi::GTK_ACCESSIBLE_ROLE_COMMAND => Self::Command,
            ffi::GTK_ACCESSIBLE_ROLE_COMPOSITE => Self::Composite,
            ffi::GTK_ACCESSIBLE_ROLE_DIALOG => Self::Dialog,
            ffi::GTK_ACCESSIBLE_ROLE_DOCUMENT => Self::Document,
            ffi::GTK_ACCESSIBLE_ROLE_FEED => Self::Feed,
            ffi::GTK_ACCESSIBLE_ROLE_FORM => Self::Form,
            ffi::GTK_ACCESSIBLE_ROLE_GENERIC => Self::Generic,
            ffi::GTK_ACCESSIBLE_ROLE_GRID => Self::Grid,
            ffi::GTK_ACCESSIBLE_ROLE_GRID_CELL => Self::GridCell,
            ffi::GTK_ACCESSIBLE_ROLE_GROUP => Self::Group,
            ffi::GTK_ACCESSIBLE_ROLE_HEADING => Self::Heading,
            ffi::GTK_ACCESSIBLE_ROLE_IMG => Self::Img,
            ffi::GTK_ACCESSIBLE_ROLE_INPUT => Self::Input,
            ffi::GTK_ACCESSIBLE_ROLE_LABEL => Self::Label,
            ffi::GTK_ACCESSIBLE_ROLE_LANDMARK => Self::Landmark,
            ffi::GTK_ACCESSIBLE_ROLE_LEGEND => Self::Legend,
            ffi::GTK_ACCESSIBLE_ROLE_LINK => Self::Link,
            ffi::GTK_ACCESSIBLE_ROLE_LIST => Self::List,
            ffi::GTK_ACCESSIBLE_ROLE_LIST_BOX => Self::ListBox,
            ffi::GTK_ACCESSIBLE_ROLE_LIST_ITEM => Self::ListItem,
            ffi::GTK_ACCESSIBLE_ROLE_LOG => Self::Log,
            ffi::GTK_ACCESSIBLE_ROLE_MAIN => Self::Main,
            ffi::GTK_ACCESSIBLE_ROLE_MARQUEE => Self::Marquee,
            ffi::GTK_ACCESSIBLE_ROLE_MATH => Self::Math,
            ffi::GTK_ACCESSIBLE_ROLE_METER => Self::Meter,
            ffi::GTK_ACCESSIBLE_ROLE_MENU => Self::Menu,
            ffi::GTK_ACCESSIBLE_ROLE_MENU_BAR => Self::MenuBar,
            ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM => Self::MenuItem,
            ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX => Self::MenuItemCheckbox,
            ffi::GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO => Self::MenuItemRadio,
            ffi::GTK_ACCESSIBLE_ROLE_NAVIGATION => Self::Navigation,
            ffi::GTK_ACCESSIBLE_ROLE_NONE => Self::None,
            ffi::GTK_ACCESSIBLE_ROLE_NOTE => Self::Note,
            ffi::GTK_ACCESSIBLE_ROLE_OPTION => Self::Option,
            ffi::GTK_ACCESSIBLE_ROLE_PRESENTATION => Self::Presentation,
            ffi::GTK_ACCESSIBLE_ROLE_PROGRESS_BAR => Self::ProgressBar,
            ffi::GTK_ACCESSIBLE_ROLE_RADIO => Self::Radio,
            ffi::GTK_ACCESSIBLE_ROLE_RADIO_GROUP => Self::RadioGroup,
            ffi::GTK_ACCESSIBLE_ROLE_RANGE => Self::Range,
            ffi::GTK_ACCESSIBLE_ROLE_REGION => Self::Region,
            ffi::GTK_ACCESSIBLE_ROLE_ROW => Self::Row,
            ffi::GTK_ACCESSIBLE_ROLE_ROW_GROUP => Self::RowGroup,
            ffi::GTK_ACCESSIBLE_ROLE_ROW_HEADER => Self::RowHeader,
            ffi::GTK_ACCESSIBLE_ROLE_SCROLLBAR => Self::Scrollbar,
            ffi::GTK_ACCESSIBLE_ROLE_SEARCH => Self::Search,
            ffi::GTK_ACCESSIBLE_ROLE_SEARCH_BOX => Self::SearchBox,
            ffi::GTK_ACCESSIBLE_ROLE_SECTION => Self::Section,
            ffi::GTK_ACCESSIBLE_ROLE_SECTION_HEAD => Self::SectionHead,
            ffi::GTK_ACCESSIBLE_ROLE_SELECT => Self::Select,
            ffi::GTK_ACCESSIBLE_ROLE_SEPARATOR => Self::Separator,
            ffi::GTK_ACCESSIBLE_ROLE_SLIDER => Self::Slider,
            ffi::GTK_ACCESSIBLE_ROLE_SPIN_BUTTON => Self::SpinButton,
            ffi::GTK_ACCESSIBLE_ROLE_STATUS => Self::Status,
            ffi::GTK_ACCESSIBLE_ROLE_STRUCTURE => Self::Structure,
            ffi::GTK_ACCESSIBLE_ROLE_SWITCH => Self::Switch,
            ffi::GTK_ACCESSIBLE_ROLE_TAB => Self::Tab,
            ffi::GTK_ACCESSIBLE_ROLE_TABLE => Self::Table,
            ffi::GTK_ACCESSIBLE_ROLE_TAB_LIST => Self::TabList,
            ffi::GTK_ACCESSIBLE_ROLE_TAB_PANEL => Self::TabPanel,
            ffi::GTK_ACCESSIBLE_ROLE_TEXT_BOX => Self::TextBox,
            ffi::GTK_ACCESSIBLE_ROLE_TIME => Self::Time,
            ffi::GTK_ACCESSIBLE_ROLE_TIMER => Self::Timer,
            ffi::GTK_ACCESSIBLE_ROLE_TOOLBAR => Self::Toolbar,
            ffi::GTK_ACCESSIBLE_ROLE_TOOLTIP => Self::Tooltip,
            ffi::GTK_ACCESSIBLE_ROLE_TREE => Self::Tree,
            ffi::GTK_ACCESSIBLE_ROLE_TREE_GRID => Self::TreeGrid,
            ffi::GTK_ACCESSIBLE_ROLE_TREE_ITEM => Self::TreeItem,
            ffi::GTK_ACCESSIBLE_ROLE_WIDGET => Self::Widget,
            ffi::GTK_ACCESSIBLE_ROLE_WINDOW => Self::Window,
            #[cfg(feature = "v4_10")]
            ffi::GTK_ACCESSIBLE_ROLE_TOGGLE_BUTTON => Self::ToggleButton,
            #[cfg(feature = "v4_12")]
            ffi::GTK_ACCESSIBLE_ROLE_APPLICATION => Self::Application,
            #[cfg(feature = "v4_14")]
            ffi::GTK_ACCESSIBLE_ROLE_PARAGRAPH => Self::Paragraph,
            #[cfg(feature = "v4_14")]
            ffi::GTK_ACCESSIBLE_ROLE_BLOCK_QUOTE => Self::BlockQuote,
            #[cfg(feature = "v4_14")]
            ffi::GTK_ACCESSIBLE_ROLE_ARTICLE => Self::Article,
            #[cfg(feature = "v4_14")]
            ffi::GTK_ACCESSIBLE_ROLE_COMMENT => Self::Comment,
            #[cfg(feature = "v4_14")]
            ffi::GTK_ACCESSIBLE_ROLE_TERMINAL => Self::Terminal,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleRole {
    #[inline]
    #[doc(alias = "gtk_accessible_role_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_role_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleRole {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleRole {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleRole {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleRole {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleRole> for glib::Value {
    #[inline]
    fn from(v: AccessibleRole) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleSort")]
pub enum AccessibleSort {
    #[doc(alias = "GTK_ACCESSIBLE_SORT_NONE")]
    None,
    #[doc(alias = "GTK_ACCESSIBLE_SORT_ASCENDING")]
    Ascending,
    #[doc(alias = "GTK_ACCESSIBLE_SORT_DESCENDING")]
    Descending,
    #[doc(alias = "GTK_ACCESSIBLE_SORT_OTHER")]
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AccessibleSort {
    type GlibType = ffi::GtkAccessibleSort;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleSort {
        match self {
            Self::None => ffi::GTK_ACCESSIBLE_SORT_NONE,
            Self::Ascending => ffi::GTK_ACCESSIBLE_SORT_ASCENDING,
            Self::Descending => ffi::GTK_ACCESSIBLE_SORT_DESCENDING,
            Self::Other => ffi::GTK_ACCESSIBLE_SORT_OTHER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleSort> for AccessibleSort {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleSort) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_SORT_NONE => Self::None,
            ffi::GTK_ACCESSIBLE_SORT_ASCENDING => Self::Ascending,
            ffi::GTK_ACCESSIBLE_SORT_DESCENDING => Self::Descending,
            ffi::GTK_ACCESSIBLE_SORT_OTHER => Self::Other,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleSort {
    #[inline]
    #[doc(alias = "gtk_accessible_sort_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_sort_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleSort {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleSort {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleSort {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleSort {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleSort> for glib::Value {
    #[inline]
    fn from(v: AccessibleSort) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleState")]
pub enum AccessibleState {
    #[doc(alias = "GTK_ACCESSIBLE_STATE_BUSY")]
    Busy,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_CHECKED")]
    Checked,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_DISABLED")]
    Disabled,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_EXPANDED")]
    Expanded,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_HIDDEN")]
    Hidden,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_INVALID")]
    Invalid,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_PRESSED")]
    Pressed,
    #[doc(alias = "GTK_ACCESSIBLE_STATE_SELECTED")]
    Selected,
    #[cfg(feature = "v4_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
    #[doc(alias = "GTK_ACCESSIBLE_STATE_VISITED")]
    Visited,
    #[doc(hidden)]
    __Unknown(i32),
}

impl AccessibleState {
    #[doc(alias = "gtk_accessible_state_init_value")]
    pub fn init_value(self, value: &mut glib::Value) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gtk_accessible_state_init_value(self.into_glib(), value.to_glib_none_mut().0);
        }
    }
}

#[doc(hidden)]
impl IntoGlib for AccessibleState {
    type GlibType = ffi::GtkAccessibleState;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleState {
        match self {
            Self::Busy => ffi::GTK_ACCESSIBLE_STATE_BUSY,
            Self::Checked => ffi::GTK_ACCESSIBLE_STATE_CHECKED,
            Self::Disabled => ffi::GTK_ACCESSIBLE_STATE_DISABLED,
            Self::Expanded => ffi::GTK_ACCESSIBLE_STATE_EXPANDED,
            Self::Hidden => ffi::GTK_ACCESSIBLE_STATE_HIDDEN,
            Self::Invalid => ffi::GTK_ACCESSIBLE_STATE_INVALID,
            Self::Pressed => ffi::GTK_ACCESSIBLE_STATE_PRESSED,
            Self::Selected => ffi::GTK_ACCESSIBLE_STATE_SELECTED,
            #[cfg(feature = "v4_12")]
            Self::Visited => ffi::GTK_ACCESSIBLE_STATE_VISITED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleState> for AccessibleState {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_STATE_BUSY => Self::Busy,
            ffi::GTK_ACCESSIBLE_STATE_CHECKED => Self::Checked,
            ffi::GTK_ACCESSIBLE_STATE_DISABLED => Self::Disabled,
            ffi::GTK_ACCESSIBLE_STATE_EXPANDED => Self::Expanded,
            ffi::GTK_ACCESSIBLE_STATE_HIDDEN => Self::Hidden,
            ffi::GTK_ACCESSIBLE_STATE_INVALID => Self::Invalid,
            ffi::GTK_ACCESSIBLE_STATE_PRESSED => Self::Pressed,
            ffi::GTK_ACCESSIBLE_STATE_SELECTED => Self::Selected,
            #[cfg(feature = "v4_12")]
            ffi::GTK_ACCESSIBLE_STATE_VISITED => Self::Visited,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleState {
    #[inline]
    #[doc(alias = "gtk_accessible_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_state_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleState> for glib::Value {
    #[inline]
    fn from(v: AccessibleState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAccessibleTristate")]
pub enum AccessibleTristate {
    #[doc(alias = "GTK_ACCESSIBLE_TRISTATE_FALSE")]
    False,
    #[doc(alias = "GTK_ACCESSIBLE_TRISTATE_TRUE")]
    True,
    #[doc(alias = "GTK_ACCESSIBLE_TRISTATE_MIXED")]
    Mixed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AccessibleTristate {
    type GlibType = ffi::GtkAccessibleTristate;

    #[inline]
    fn into_glib(self) -> ffi::GtkAccessibleTristate {
        match self {
            Self::False => ffi::GTK_ACCESSIBLE_TRISTATE_FALSE,
            Self::True => ffi::GTK_ACCESSIBLE_TRISTATE_TRUE,
            Self::Mixed => ffi::GTK_ACCESSIBLE_TRISTATE_MIXED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccessibleTristate> for AccessibleTristate {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAccessibleTristate) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ACCESSIBLE_TRISTATE_FALSE => Self::False,
            ffi::GTK_ACCESSIBLE_TRISTATE_TRUE => Self::True,
            ffi::GTK_ACCESSIBLE_TRISTATE_MIXED => Self::Mixed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AccessibleTristate {
    #[inline]
    #[doc(alias = "gtk_accessible_tristate_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_accessible_tristate_get_type()) }
    }
}

impl glib::HasParamSpec for AccessibleTristate {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AccessibleTristate {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AccessibleTristate {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AccessibleTristate {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AccessibleTristate> for glib::Value {
    #[inline]
    fn from(v: AccessibleTristate) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkArrowType")]
pub enum ArrowType {
    #[doc(alias = "GTK_ARROW_UP")]
    Up,
    #[doc(alias = "GTK_ARROW_DOWN")]
    Down,
    #[doc(alias = "GTK_ARROW_LEFT")]
    Left,
    #[doc(alias = "GTK_ARROW_RIGHT")]
    Right,
    #[doc(alias = "GTK_ARROW_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ArrowType {
    type GlibType = ffi::GtkArrowType;

    #[inline]
    fn into_glib(self) -> ffi::GtkArrowType {
        match self {
            Self::Up => ffi::GTK_ARROW_UP,
            Self::Down => ffi::GTK_ARROW_DOWN,
            Self::Left => ffi::GTK_ARROW_LEFT,
            Self::Right => ffi::GTK_ARROW_RIGHT,
            Self::None => ffi::GTK_ARROW_NONE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkArrowType> for ArrowType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkArrowType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ARROW_UP => Self::Up,
            ffi::GTK_ARROW_DOWN => Self::Down,
            ffi::GTK_ARROW_LEFT => Self::Left,
            ffi::GTK_ARROW_RIGHT => Self::Right,
            ffi::GTK_ARROW_NONE => Self::None,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ArrowType {
    #[inline]
    #[doc(alias = "gtk_arrow_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_arrow_type_get_type()) }
    }
}

impl glib::HasParamSpec for ArrowType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ArrowType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ArrowType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ArrowType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ArrowType> for glib::Value {
    #[inline]
    fn from(v: ArrowType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAssistantPageType")]
pub enum AssistantPageType {
    #[doc(alias = "GTK_ASSISTANT_PAGE_CONTENT")]
    Content,
    #[doc(alias = "GTK_ASSISTANT_PAGE_INTRO")]
    Intro,
    #[doc(alias = "GTK_ASSISTANT_PAGE_CONFIRM")]
    Confirm,
    #[doc(alias = "GTK_ASSISTANT_PAGE_SUMMARY")]
    Summary,
    #[doc(alias = "GTK_ASSISTANT_PAGE_PROGRESS")]
    Progress,
    #[doc(alias = "GTK_ASSISTANT_PAGE_CUSTOM")]
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AssistantPageType {
    type GlibType = ffi::GtkAssistantPageType;

    #[inline]
    fn into_glib(self) -> ffi::GtkAssistantPageType {
        match self {
            Self::Content => ffi::GTK_ASSISTANT_PAGE_CONTENT,
            Self::Intro => ffi::GTK_ASSISTANT_PAGE_INTRO,
            Self::Confirm => ffi::GTK_ASSISTANT_PAGE_CONFIRM,
            Self::Summary => ffi::GTK_ASSISTANT_PAGE_SUMMARY,
            Self::Progress => ffi::GTK_ASSISTANT_PAGE_PROGRESS,
            Self::Custom => ffi::GTK_ASSISTANT_PAGE_CUSTOM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAssistantPageType> for AssistantPageType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkAssistantPageType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ASSISTANT_PAGE_CONTENT => Self::Content,
            ffi::GTK_ASSISTANT_PAGE_INTRO => Self::Intro,
            ffi::GTK_ASSISTANT_PAGE_CONFIRM => Self::Confirm,
            ffi::GTK_ASSISTANT_PAGE_SUMMARY => Self::Summary,
            ffi::GTK_ASSISTANT_PAGE_PROGRESS => Self::Progress,
            ffi::GTK_ASSISTANT_PAGE_CUSTOM => Self::Custom,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AssistantPageType {
    #[inline]
    #[doc(alias = "gtk_assistant_page_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_assistant_page_type_get_type()) }
    }
}

impl glib::HasParamSpec for AssistantPageType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AssistantPageType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AssistantPageType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AssistantPageType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AssistantPageType> for glib::Value {
    #[inline]
    fn from(v: AssistantPageType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBaselinePosition")]
pub enum BaselinePosition {
    #[doc(alias = "GTK_BASELINE_POSITION_TOP")]
    Top,
    #[doc(alias = "GTK_BASELINE_POSITION_CENTER")]
    Center,
    #[doc(alias = "GTK_BASELINE_POSITION_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BaselinePosition {
    type GlibType = ffi::GtkBaselinePosition;

    #[inline]
    fn into_glib(self) -> ffi::GtkBaselinePosition {
        match self {
            Self::Top => ffi::GTK_BASELINE_POSITION_TOP,
            Self::Center => ffi::GTK_BASELINE_POSITION_CENTER,
            Self::Bottom => ffi::GTK_BASELINE_POSITION_BOTTOM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBaselinePosition> for BaselinePosition {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkBaselinePosition) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_BASELINE_POSITION_TOP => Self::Top,
            ffi::GTK_BASELINE_POSITION_CENTER => Self::Center,
            ffi::GTK_BASELINE_POSITION_BOTTOM => Self::Bottom,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BaselinePosition {
    #[inline]
    #[doc(alias = "gtk_baseline_position_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_baseline_position_get_type()) }
    }
}

impl glib::HasParamSpec for BaselinePosition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BaselinePosition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BaselinePosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BaselinePosition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BaselinePosition> for glib::Value {
    #[inline]
    fn from(v: BaselinePosition) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBorderStyle")]
pub enum BorderStyle {
    #[doc(alias = "GTK_BORDER_STYLE_NONE")]
    None,
    #[doc(alias = "GTK_BORDER_STYLE_HIDDEN")]
    Hidden,
    #[doc(alias = "GTK_BORDER_STYLE_SOLID")]
    Solid,
    #[doc(alias = "GTK_BORDER_STYLE_INSET")]
    Inset,
    #[doc(alias = "GTK_BORDER_STYLE_OUTSET")]
    Outset,
    #[doc(alias = "GTK_BORDER_STYLE_DOTTED")]
    Dotted,
    #[doc(alias = "GTK_BORDER_STYLE_DASHED")]
    Dashed,
    #[doc(alias = "GTK_BORDER_STYLE_DOUBLE")]
    Double,
    #[doc(alias = "GTK_BORDER_STYLE_GROOVE")]
    Groove,
    #[doc(alias = "GTK_BORDER_STYLE_RIDGE")]
    Ridge,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BorderStyle {
    type GlibType = ffi::GtkBorderStyle;

    #[inline]
    fn into_glib(self) -> ffi::GtkBorderStyle {
        match self {
            Self::None => ffi::GTK_BORDER_STYLE_NONE,
            Self::Hidden => ffi::GTK_BORDER_STYLE_HIDDEN,
            Self::Solid => ffi::GTK_BORDER_STYLE_SOLID,
            Self::Inset => ffi::GTK_BORDER_STYLE_INSET,
            Self::Outset => ffi::GTK_BORDER_STYLE_OUTSET,
            Self::Dotted => ffi::GTK_BORDER_STYLE_DOTTED,
            Self::Dashed => ffi::GTK_BORDER_STYLE_DASHED,
            Self::Double => ffi::GTK_BORDER_STYLE_DOUBLE,
            Self::Groove => ffi::GTK_BORDER_STYLE_GROOVE,
            Self::Ridge => ffi::GTK_BORDER_STYLE_RIDGE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBorderStyle> for BorderStyle {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkBorderStyle) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_BORDER_STYLE_NONE => Self::None,
            ffi::GTK_BORDER_STYLE_HIDDEN => Self::Hidden,
            ffi::GTK_BORDER_STYLE_SOLID => Self::Solid,
            ffi::GTK_BORDER_STYLE_INSET => Self::Inset,
            ffi::GTK_BORDER_STYLE_OUTSET => Self::Outset,
            ffi::GTK_BORDER_STYLE_DOTTED => Self::Dotted,
            ffi::GTK_BORDER_STYLE_DASHED => Self::Dashed,
            ffi::GTK_BORDER_STYLE_DOUBLE => Self::Double,
            ffi::GTK_BORDER_STYLE_GROOVE => Self::Groove,
            ffi::GTK_BORDER_STYLE_RIDGE => Self::Ridge,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BorderStyle {
    #[inline]
    #[doc(alias = "gtk_border_style_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_border_style_get_type()) }
    }
}

impl glib::HasParamSpec for BorderStyle {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BorderStyle {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BorderStyle {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BorderStyle {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BorderStyle> for glib::Value {
    #[inline]
    fn from(v: BorderStyle) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBuilderError")]
pub enum BuilderError {
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION")]
    InvalidTypeFunction,
    #[doc(alias = "GTK_BUILDER_ERROR_UNHANDLED_TAG")]
    UnhandledTag,
    #[doc(alias = "GTK_BUILDER_ERROR_MISSING_ATTRIBUTE")]
    MissingAttribute,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_ATTRIBUTE")]
    InvalidAttribute,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_TAG")]
    InvalidTag,
    #[doc(alias = "GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE")]
    MissingPropertyValue,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_VALUE")]
    InvalidValue,
    #[doc(alias = "GTK_BUILDER_ERROR_VERSION_MISMATCH")]
    VersionMismatch,
    #[doc(alias = "GTK_BUILDER_ERROR_DUPLICATE_ID")]
    DuplicateId,
    #[doc(alias = "GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED")]
    ObjectTypeRefused,
    #[doc(alias = "GTK_BUILDER_ERROR_TEMPLATE_MISMATCH")]
    TemplateMismatch,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_PROPERTY")]
    InvalidProperty,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_SIGNAL")]
    InvalidSignal,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_ID")]
    InvalidId,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_FUNCTION")]
    InvalidFunction,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BuilderError {
    type GlibType = ffi::GtkBuilderError;

    fn into_glib(self) -> ffi::GtkBuilderError {
        match self {
            Self::InvalidTypeFunction => ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION,
            Self::UnhandledTag => ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG,
            Self::MissingAttribute => ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE,
            Self::InvalidAttribute => ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE,
            Self::InvalidTag => ffi::GTK_BUILDER_ERROR_INVALID_TAG,
            Self::MissingPropertyValue => ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE,
            Self::InvalidValue => ffi::GTK_BUILDER_ERROR_INVALID_VALUE,
            Self::VersionMismatch => ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH,
            Self::DuplicateId => ffi::GTK_BUILDER_ERROR_DUPLICATE_ID,
            Self::ObjectTypeRefused => ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED,
            Self::TemplateMismatch => ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH,
            Self::InvalidProperty => ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY,
            Self::InvalidSignal => ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL,
            Self::InvalidId => ffi::GTK_BUILDER_ERROR_INVALID_ID,
            Self::InvalidFunction => ffi::GTK_BUILDER_ERROR_INVALID_FUNCTION,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderError> for BuilderError {
    unsafe fn from_glib(value: ffi::GtkBuilderError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION => Self::InvalidTypeFunction,
            ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG => Self::UnhandledTag,
            ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE => Self::MissingAttribute,
            ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE => Self::InvalidAttribute,
            ffi::GTK_BUILDER_ERROR_INVALID_TAG => Self::InvalidTag,
            ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE => Self::MissingPropertyValue,
            ffi::GTK_BUILDER_ERROR_INVALID_VALUE => Self::InvalidValue,
            ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH => Self::VersionMismatch,
            ffi::GTK_BUILDER_ERROR_DUPLICATE_ID => Self::DuplicateId,
            ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED => Self::ObjectTypeRefused,
            ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH => Self::TemplateMismatch,
            ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY => Self::InvalidProperty,
            ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL => Self::InvalidSignal,
            ffi::GTK_BUILDER_ERROR_INVALID_ID => Self::InvalidId,
            ffi::GTK_BUILDER_ERROR_INVALID_FUNCTION => Self::InvalidFunction,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for BuilderError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_builder_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for BuilderError {
    #[inline]
    #[doc(alias = "gtk_builder_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_builder_error_get_type()) }
    }
}

impl glib::HasParamSpec for BuilderError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BuilderError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BuilderError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BuilderError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BuilderError> for glib::Value {
    #[inline]
    fn from(v: BuilderError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkButtonsType")]
pub enum ButtonsType {
    #[doc(alias = "GTK_BUTTONS_NONE")]
    None,
    #[doc(alias = "GTK_BUTTONS_OK")]
    Ok,
    #[doc(alias = "GTK_BUTTONS_CLOSE")]
    Close,
    #[doc(alias = "GTK_BUTTONS_CANCEL")]
    Cancel,
    #[doc(alias = "GTK_BUTTONS_YES_NO")]
    YesNo,
    #[doc(alias = "GTK_BUTTONS_OK_CANCEL")]
    OkCancel,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ButtonsType {
    type GlibType = ffi::GtkButtonsType;

    #[inline]
    fn into_glib(self) -> ffi::GtkButtonsType {
        match self {
            Self::None => ffi::GTK_BUTTONS_NONE,
            Self::Ok => ffi::GTK_BUTTONS_OK,
            Self::Close => ffi::GTK_BUTTONS_CLOSE,
            Self::Cancel => ffi::GTK_BUTTONS_CANCEL,
            Self::YesNo => ffi::GTK_BUTTONS_YES_NO,
            Self::OkCancel => ffi::GTK_BUTTONS_OK_CANCEL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonsType> for ButtonsType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkButtonsType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_BUTTONS_NONE => Self::None,
            ffi::GTK_BUTTONS_OK => Self::Ok,
            ffi::GTK_BUTTONS_CLOSE => Self::Close,
            ffi::GTK_BUTTONS_CANCEL => Self::Cancel,
            ffi::GTK_BUTTONS_YES_NO => Self::YesNo,
            ffi::GTK_BUTTONS_OK_CANCEL => Self::OkCancel,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ButtonsType {
    #[inline]
    #[doc(alias = "gtk_buttons_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_buttons_type_get_type()) }
    }
}

impl glib::HasParamSpec for ButtonsType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ButtonsType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ButtonsType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ButtonsType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ButtonsType> for glib::Value {
    #[inline]
    fn from(v: ButtonsType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCellRendererAccelMode")]
pub enum CellRendererAccelMode {
    #[doc(alias = "GTK_CELL_RENDERER_ACCEL_MODE_GTK")]
    Gtk,
    #[doc(alias = "GTK_CELL_RENDERER_ACCEL_MODE_OTHER")]
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CellRendererAccelMode {
    type GlibType = ffi::GtkCellRendererAccelMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkCellRendererAccelMode {
        match self {
            Self::Gtk => ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK,
            Self::Other => ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererAccelMode> for CellRendererAccelMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCellRendererAccelMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK => Self::Gtk,
            ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER => Self::Other,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererAccelMode {
    #[inline]
    #[doc(alias = "gtk_cell_renderer_accel_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_accel_mode_get_type()) }
    }
}

impl glib::HasParamSpec for CellRendererAccelMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CellRendererAccelMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CellRendererAccelMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CellRendererAccelMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CellRendererAccelMode> for glib::Value {
    #[inline]
    fn from(v: CellRendererAccelMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCellRendererMode")]
pub enum CellRendererMode {
    #[doc(alias = "GTK_CELL_RENDERER_MODE_INERT")]
    Inert,
    #[doc(alias = "GTK_CELL_RENDERER_MODE_ACTIVATABLE")]
    Activatable,
    #[doc(alias = "GTK_CELL_RENDERER_MODE_EDITABLE")]
    Editable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CellRendererMode {
    type GlibType = ffi::GtkCellRendererMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkCellRendererMode {
        match self {
            Self::Inert => ffi::GTK_CELL_RENDERER_MODE_INERT,
            Self::Activatable => ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE,
            Self::Editable => ffi::GTK_CELL_RENDERER_MODE_EDITABLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererMode> for CellRendererMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCellRendererMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CELL_RENDERER_MODE_INERT => Self::Inert,
            ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE => Self::Activatable,
            ffi::GTK_CELL_RENDERER_MODE_EDITABLE => Self::Editable,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererMode {
    #[inline]
    #[doc(alias = "gtk_cell_renderer_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_mode_get_type()) }
    }
}

impl glib::HasParamSpec for CellRendererMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CellRendererMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CellRendererMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CellRendererMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CellRendererMode> for glib::Value {
    #[inline]
    fn from(v: CellRendererMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCollation")]
pub enum Collation {
    #[doc(alias = "GTK_COLLATION_NONE")]
    None,
    #[doc(alias = "GTK_COLLATION_UNICODE")]
    Unicode,
    #[doc(alias = "GTK_COLLATION_FILENAME")]
    Filename,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl IntoGlib for Collation {
    type GlibType = ffi::GtkCollation;

    #[inline]
    fn into_glib(self) -> ffi::GtkCollation {
        match self {
            Self::None => ffi::GTK_COLLATION_NONE,
            Self::Unicode => ffi::GTK_COLLATION_UNICODE,
            Self::Filename => ffi::GTK_COLLATION_FILENAME,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkCollation> for Collation {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCollation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_COLLATION_NONE => Self::None,
            ffi::GTK_COLLATION_UNICODE => Self::Unicode,
            ffi::GTK_COLLATION_FILENAME => Self::Filename,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl StaticType for Collation {
    #[inline]
    #[doc(alias = "gtk_collation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_collation_get_type()) }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::HasParamSpec for Collation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::value::ValueType for Collation {
    type Type = Self;
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for Collation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl ToValue for Collation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl From<Collation> for glib::Value {
    #[inline]
    fn from(v: Collation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkConstraintAttribute")]
pub enum ConstraintAttribute {
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_NONE")]
    None,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_LEFT")]
    Left,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_RIGHT")]
    Right,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_TOP")]
    Top,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_BOTTOM")]
    Bottom,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_START")]
    Start,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_END")]
    End,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_WIDTH")]
    Width,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_HEIGHT")]
    Height,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_CENTER_X")]
    CenterX,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_CENTER_Y")]
    CenterY,
    #[doc(alias = "GTK_CONSTRAINT_ATTRIBUTE_BASELINE")]
    Baseline,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConstraintAttribute {
    type GlibType = ffi::GtkConstraintAttribute;

    #[inline]
    fn into_glib(self) -> ffi::GtkConstraintAttribute {
        match self {
            Self::None => ffi::GTK_CONSTRAINT_ATTRIBUTE_NONE,
            Self::Left => ffi::GTK_CONSTRAINT_ATTRIBUTE_LEFT,
            Self::Right => ffi::GTK_CONSTRAINT_ATTRIBUTE_RIGHT,
            Self::Top => ffi::GTK_CONSTRAINT_ATTRIBUTE_TOP,
            Self::Bottom => ffi::GTK_CONSTRAINT_ATTRIBUTE_BOTTOM,
            Self::Start => ffi::GTK_CONSTRAINT_ATTRIBUTE_START,
            Self::End => ffi::GTK_CONSTRAINT_ATTRIBUTE_END,
            Self::Width => ffi::GTK_CONSTRAINT_ATTRIBUTE_WIDTH,
            Self::Height => ffi::GTK_CONSTRAINT_ATTRIBUTE_HEIGHT,
            Self::CenterX => ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_X,
            Self::CenterY => ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_Y,
            Self::Baseline => ffi::GTK_CONSTRAINT_ATTRIBUTE_BASELINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintAttribute> for ConstraintAttribute {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkConstraintAttribute) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CONSTRAINT_ATTRIBUTE_NONE => Self::None,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_LEFT => Self::Left,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_RIGHT => Self::Right,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_TOP => Self::Top,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_BOTTOM => Self::Bottom,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_START => Self::Start,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_END => Self::End,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_WIDTH => Self::Width,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_HEIGHT => Self::Height,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_X => Self::CenterX,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_CENTER_Y => Self::CenterY,
            ffi::GTK_CONSTRAINT_ATTRIBUTE_BASELINE => Self::Baseline,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintAttribute {
    #[inline]
    #[doc(alias = "gtk_constraint_attribute_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_constraint_attribute_get_type()) }
    }
}

impl glib::HasParamSpec for ConstraintAttribute {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConstraintAttribute {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConstraintAttribute {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConstraintAttribute {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConstraintAttribute> for glib::Value {
    #[inline]
    fn from(v: ConstraintAttribute) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkConstraintRelation")]
pub enum ConstraintRelation {
    #[doc(alias = "GTK_CONSTRAINT_RELATION_LE")]
    Le,
    #[doc(alias = "GTK_CONSTRAINT_RELATION_EQ")]
    Eq,
    #[doc(alias = "GTK_CONSTRAINT_RELATION_GE")]
    Ge,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConstraintRelation {
    type GlibType = ffi::GtkConstraintRelation;

    #[inline]
    fn into_glib(self) -> ffi::GtkConstraintRelation {
        match self {
            Self::Le => ffi::GTK_CONSTRAINT_RELATION_LE,
            Self::Eq => ffi::GTK_CONSTRAINT_RELATION_EQ,
            Self::Ge => ffi::GTK_CONSTRAINT_RELATION_GE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintRelation> for ConstraintRelation {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkConstraintRelation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CONSTRAINT_RELATION_LE => Self::Le,
            ffi::GTK_CONSTRAINT_RELATION_EQ => Self::Eq,
            ffi::GTK_CONSTRAINT_RELATION_GE => Self::Ge,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintRelation {
    #[inline]
    #[doc(alias = "gtk_constraint_relation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_constraint_relation_get_type()) }
    }
}

impl glib::HasParamSpec for ConstraintRelation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConstraintRelation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConstraintRelation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConstraintRelation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConstraintRelation> for glib::Value {
    #[inline]
    fn from(v: ConstraintRelation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkConstraintStrength")]
pub enum ConstraintStrength {
    #[doc(alias = "GTK_CONSTRAINT_STRENGTH_REQUIRED")]
    Required,
    #[doc(alias = "GTK_CONSTRAINT_STRENGTH_STRONG")]
    Strong,
    #[doc(alias = "GTK_CONSTRAINT_STRENGTH_MEDIUM")]
    Medium,
    #[doc(alias = "GTK_CONSTRAINT_STRENGTH_WEAK")]
    Weak,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConstraintStrength {
    type GlibType = ffi::GtkConstraintStrength;

    #[inline]
    fn into_glib(self) -> ffi::GtkConstraintStrength {
        match self {
            Self::Required => ffi::GTK_CONSTRAINT_STRENGTH_REQUIRED,
            Self::Strong => ffi::GTK_CONSTRAINT_STRENGTH_STRONG,
            Self::Medium => ffi::GTK_CONSTRAINT_STRENGTH_MEDIUM,
            Self::Weak => ffi::GTK_CONSTRAINT_STRENGTH_WEAK,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintStrength> for ConstraintStrength {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkConstraintStrength) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CONSTRAINT_STRENGTH_REQUIRED => Self::Required,
            ffi::GTK_CONSTRAINT_STRENGTH_STRONG => Self::Strong,
            ffi::GTK_CONSTRAINT_STRENGTH_MEDIUM => Self::Medium,
            ffi::GTK_CONSTRAINT_STRENGTH_WEAK => Self::Weak,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConstraintStrength {
    #[inline]
    #[doc(alias = "gtk_constraint_strength_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_constraint_strength_get_type()) }
    }
}

impl glib::HasParamSpec for ConstraintStrength {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConstraintStrength {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConstraintStrength {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConstraintStrength {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConstraintStrength> for glib::Value {
    #[inline]
    fn from(v: ConstraintStrength) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkConstraintVflParserError")]
pub enum ConstraintVflParserError {
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_SYMBOL")]
    Symbol,
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_ATTRIBUTE")]
    Attribute,
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_VIEW")]
    View,
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_METRIC")]
    Metric,
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_PRIORITY")]
    Priority,
    #[doc(alias = "GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_RELATION")]
    Relation,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConstraintVflParserError {
    type GlibType = ffi::GtkConstraintVflParserError;

    #[inline]
    fn into_glib(self) -> ffi::GtkConstraintVflParserError {
        match self {
            Self::Symbol => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_SYMBOL,
            Self::Attribute => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_ATTRIBUTE,
            Self::View => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_VIEW,
            Self::Metric => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_METRIC,
            Self::Priority => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_PRIORITY,
            Self::Relation => ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_RELATION,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkConstraintVflParserError> for ConstraintVflParserError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkConstraintVflParserError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_SYMBOL => Self::Symbol,
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_ATTRIBUTE => Self::Attribute,
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_VIEW => Self::View,
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_METRIC => Self::Metric,
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_PRIORITY => Self::Priority,
            ffi::GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_RELATION => Self::Relation,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for ConstraintVflParserError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_constraint_vfl_parser_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for ConstraintVflParserError {
    #[inline]
    #[doc(alias = "gtk_constraint_vfl_parser_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_constraint_vfl_parser_error_get_type()) }
    }
}

impl glib::HasParamSpec for ConstraintVflParserError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConstraintVflParserError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConstraintVflParserError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConstraintVflParserError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConstraintVflParserError> for glib::Value {
    #[inline]
    fn from(v: ConstraintVflParserError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkContentFit")]
pub enum ContentFit {
    #[doc(alias = "GTK_CONTENT_FIT_FILL")]
    Fill,
    #[doc(alias = "GTK_CONTENT_FIT_CONTAIN")]
    Contain,
    #[doc(alias = "GTK_CONTENT_FIT_COVER")]
    Cover,
    #[doc(alias = "GTK_CONTENT_FIT_SCALE_DOWN")]
    ScaleDown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[doc(hidden)]
impl IntoGlib for ContentFit {
    type GlibType = ffi::GtkContentFit;

    #[inline]
    fn into_glib(self) -> ffi::GtkContentFit {
        match self {
            Self::Fill => ffi::GTK_CONTENT_FIT_FILL,
            Self::Contain => ffi::GTK_CONTENT_FIT_CONTAIN,
            Self::Cover => ffi::GTK_CONTENT_FIT_COVER,
            Self::ScaleDown => ffi::GTK_CONTENT_FIT_SCALE_DOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkContentFit> for ContentFit {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkContentFit) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CONTENT_FIT_FILL => Self::Fill,
            ffi::GTK_CONTENT_FIT_CONTAIN => Self::Contain,
            ffi::GTK_CONTENT_FIT_COVER => Self::Cover,
            ffi::GTK_CONTENT_FIT_SCALE_DOWN => Self::ScaleDown,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl StaticType for ContentFit {
    #[inline]
    #[doc(alias = "gtk_content_fit_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_content_fit_get_type()) }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl glib::HasParamSpec for ContentFit {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl glib::value::ValueType for ContentFit {
    type Type = Self;
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
unsafe impl<'a> glib::value::FromValue<'a> for ContentFit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl ToValue for ContentFit {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl From<ContentFit> for glib::Value {
    #[inline]
    fn from(v: ContentFit) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCornerType")]
pub enum CornerType {
    #[doc(alias = "GTK_CORNER_TOP_LEFT")]
    TopLeft,
    #[doc(alias = "GTK_CORNER_BOTTOM_LEFT")]
    BottomLeft,
    #[doc(alias = "GTK_CORNER_TOP_RIGHT")]
    TopRight,
    #[doc(alias = "GTK_CORNER_BOTTOM_RIGHT")]
    BottomRight,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CornerType {
    type GlibType = ffi::GtkCornerType;

    #[inline]
    fn into_glib(self) -> ffi::GtkCornerType {
        match self {
            Self::TopLeft => ffi::GTK_CORNER_TOP_LEFT,
            Self::BottomLeft => ffi::GTK_CORNER_BOTTOM_LEFT,
            Self::TopRight => ffi::GTK_CORNER_TOP_RIGHT,
            Self::BottomRight => ffi::GTK_CORNER_BOTTOM_RIGHT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCornerType> for CornerType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCornerType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CORNER_TOP_LEFT => Self::TopLeft,
            ffi::GTK_CORNER_BOTTOM_LEFT => Self::BottomLeft,
            ffi::GTK_CORNER_TOP_RIGHT => Self::TopRight,
            ffi::GTK_CORNER_BOTTOM_RIGHT => Self::BottomRight,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CornerType {
    #[inline]
    #[doc(alias = "gtk_corner_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_corner_type_get_type()) }
    }
}

impl glib::HasParamSpec for CornerType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CornerType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CornerType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CornerType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CornerType> for glib::Value {
    #[inline]
    fn from(v: CornerType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCssParserError")]
pub enum CssParserError {
    #[doc(alias = "GTK_CSS_PARSER_ERROR_FAILED")]
    Failed,
    #[doc(alias = "GTK_CSS_PARSER_ERROR_SYNTAX")]
    Syntax,
    #[doc(alias = "GTK_CSS_PARSER_ERROR_IMPORT")]
    Import,
    #[doc(alias = "GTK_CSS_PARSER_ERROR_NAME")]
    Name,
    #[doc(alias = "GTK_CSS_PARSER_ERROR_UNKNOWN_VALUE")]
    UnknownValue,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CssParserError {
    type GlibType = ffi::GtkCssParserError;

    #[inline]
    fn into_glib(self) -> ffi::GtkCssParserError {
        match self {
            Self::Failed => ffi::GTK_CSS_PARSER_ERROR_FAILED,
            Self::Syntax => ffi::GTK_CSS_PARSER_ERROR_SYNTAX,
            Self::Import => ffi::GTK_CSS_PARSER_ERROR_IMPORT,
            Self::Name => ffi::GTK_CSS_PARSER_ERROR_NAME,
            Self::UnknownValue => ffi::GTK_CSS_PARSER_ERROR_UNKNOWN_VALUE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssParserError> for CssParserError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCssParserError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CSS_PARSER_ERROR_FAILED => Self::Failed,
            ffi::GTK_CSS_PARSER_ERROR_SYNTAX => Self::Syntax,
            ffi::GTK_CSS_PARSER_ERROR_IMPORT => Self::Import,
            ffi::GTK_CSS_PARSER_ERROR_NAME => Self::Name,
            ffi::GTK_CSS_PARSER_ERROR_UNKNOWN_VALUE => Self::UnknownValue,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for CssParserError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_css_parser_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCssParserWarning")]
pub enum CssParserWarning {
    #[doc(alias = "GTK_CSS_PARSER_WARNING_DEPRECATED")]
    Deprecated,
    #[doc(alias = "GTK_CSS_PARSER_WARNING_SYNTAX")]
    Syntax,
    #[doc(alias = "GTK_CSS_PARSER_WARNING_UNIMPLEMENTED")]
    Unimplemented,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CssParserWarning {
    type GlibType = ffi::GtkCssParserWarning;

    #[inline]
    fn into_glib(self) -> ffi::GtkCssParserWarning {
        match self {
            Self::Deprecated => ffi::GTK_CSS_PARSER_WARNING_DEPRECATED,
            Self::Syntax => ffi::GTK_CSS_PARSER_WARNING_SYNTAX,
            Self::Unimplemented => ffi::GTK_CSS_PARSER_WARNING_UNIMPLEMENTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssParserWarning> for CssParserWarning {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkCssParserWarning) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_CSS_PARSER_WARNING_DEPRECATED => Self::Deprecated,
            ffi::GTK_CSS_PARSER_WARNING_SYNTAX => Self::Syntax,
            ffi::GTK_CSS_PARSER_WARNING_UNIMPLEMENTED => Self::Unimplemented,
            value => Self::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDeleteType")]
pub enum DeleteType {
    #[doc(alias = "GTK_DELETE_CHARS")]
    Chars,
    #[doc(alias = "GTK_DELETE_WORD_ENDS")]
    WordEnds,
    #[doc(alias = "GTK_DELETE_WORDS")]
    Words,
    #[doc(alias = "GTK_DELETE_DISPLAY_LINES")]
    DisplayLines,
    #[doc(alias = "GTK_DELETE_DISPLAY_LINE_ENDS")]
    DisplayLineEnds,
    #[doc(alias = "GTK_DELETE_PARAGRAPH_ENDS")]
    ParagraphEnds,
    #[doc(alias = "GTK_DELETE_PARAGRAPHS")]
    Paragraphs,
    #[doc(alias = "GTK_DELETE_WHITESPACE")]
    Whitespace,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeleteType {
    type GlibType = ffi::GtkDeleteType;

    #[inline]
    fn into_glib(self) -> ffi::GtkDeleteType {
        match self {
            Self::Chars => ffi::GTK_DELETE_CHARS,
            Self::WordEnds => ffi::GTK_DELETE_WORD_ENDS,
            Self::Words => ffi::GTK_DELETE_WORDS,
            Self::DisplayLines => ffi::GTK_DELETE_DISPLAY_LINES,
            Self::DisplayLineEnds => ffi::GTK_DELETE_DISPLAY_LINE_ENDS,
            Self::ParagraphEnds => ffi::GTK_DELETE_PARAGRAPH_ENDS,
            Self::Paragraphs => ffi::GTK_DELETE_PARAGRAPHS,
            Self::Whitespace => ffi::GTK_DELETE_WHITESPACE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDeleteType> for DeleteType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkDeleteType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_DELETE_CHARS => Self::Chars,
            ffi::GTK_DELETE_WORD_ENDS => Self::WordEnds,
            ffi::GTK_DELETE_WORDS => Self::Words,
            ffi::GTK_DELETE_DISPLAY_LINES => Self::DisplayLines,
            ffi::GTK_DELETE_DISPLAY_LINE_ENDS => Self::DisplayLineEnds,
            ffi::GTK_DELETE_PARAGRAPH_ENDS => Self::ParagraphEnds,
            ffi::GTK_DELETE_PARAGRAPHS => Self::Paragraphs,
            ffi::GTK_DELETE_WHITESPACE => Self::Whitespace,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeleteType {
    #[inline]
    #[doc(alias = "gtk_delete_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_delete_type_get_type()) }
    }
}

impl glib::HasParamSpec for DeleteType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DeleteType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeleteType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeleteType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeleteType> for glib::Value {
    #[inline]
    fn from(v: DeleteType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDialogError")]
pub enum DialogError {
    #[doc(alias = "GTK_DIALOG_ERROR_FAILED")]
    Failed,
    #[doc(alias = "GTK_DIALOG_ERROR_CANCELLED")]
    Cancelled,
    #[doc(alias = "GTK_DIALOG_ERROR_DISMISSED")]
    Dismissed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl IntoGlib for DialogError {
    type GlibType = ffi::GtkDialogError;

    #[inline]
    fn into_glib(self) -> ffi::GtkDialogError {
        match self {
            Self::Failed => ffi::GTK_DIALOG_ERROR_FAILED,
            Self::Cancelled => ffi::GTK_DIALOG_ERROR_CANCELLED,
            Self::Dismissed => ffi::GTK_DIALOG_ERROR_DISMISSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkDialogError> for DialogError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkDialogError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_DIALOG_ERROR_FAILED => Self::Failed,
            ffi::GTK_DIALOG_ERROR_CANCELLED => Self::Cancelled,
            ffi::GTK_DIALOG_ERROR_DISMISSED => Self::Dismissed,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::error::ErrorDomain for DialogError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_dialog_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl StaticType for DialogError {
    #[inline]
    #[doc(alias = "gtk_dialog_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_dialog_error_get_type()) }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::HasParamSpec for DialogError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::value::ValueType for DialogError {
    type Type = Self;
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for DialogError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl ToValue for DialogError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl From<DialogError> for glib::Value {
    #[inline]
    fn from(v: DialogError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDirectionType")]
pub enum DirectionType {
    #[doc(alias = "GTK_DIR_TAB_FORWARD")]
    TabForward,
    #[doc(alias = "GTK_DIR_TAB_BACKWARD")]
    TabBackward,
    #[doc(alias = "GTK_DIR_UP")]
    Up,
    #[doc(alias = "GTK_DIR_DOWN")]
    Down,
    #[doc(alias = "GTK_DIR_LEFT")]
    Left,
    #[doc(alias = "GTK_DIR_RIGHT")]
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DirectionType {
    type GlibType = ffi::GtkDirectionType;

    #[inline]
    fn into_glib(self) -> ffi::GtkDirectionType {
        match self {
            Self::TabForward => ffi::GTK_DIR_TAB_FORWARD,
            Self::TabBackward => ffi::GTK_DIR_TAB_BACKWARD,
            Self::Up => ffi::GTK_DIR_UP,
            Self::Down => ffi::GTK_DIR_DOWN,
            Self::Left => ffi::GTK_DIR_LEFT,
            Self::Right => ffi::GTK_DIR_RIGHT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDirectionType> for DirectionType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkDirectionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_DIR_TAB_FORWARD => Self::TabForward,
            ffi::GTK_DIR_TAB_BACKWARD => Self::TabBackward,
            ffi::GTK_DIR_UP => Self::Up,
            ffi::GTK_DIR_DOWN => Self::Down,
            ffi::GTK_DIR_LEFT => Self::Left,
            ffi::GTK_DIR_RIGHT => Self::Right,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DirectionType {
    #[inline]
    #[doc(alias = "gtk_direction_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_direction_type_get_type()) }
    }
}

impl glib::HasParamSpec for DirectionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DirectionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DirectionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DirectionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DirectionType> for glib::Value {
    #[inline]
    fn from(v: DirectionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkEditableProperties")]
pub enum EditableProperties {
    #[doc(alias = "GTK_EDITABLE_PROP_TEXT")]
    PropText,
    #[doc(alias = "GTK_EDITABLE_PROP_CURSOR_POSITION")]
    PropCursorPosition,
    #[doc(alias = "GTK_EDITABLE_PROP_SELECTION_BOUND")]
    PropSelectionBound,
    #[doc(alias = "GTK_EDITABLE_PROP_EDITABLE")]
    PropEditable,
    #[doc(alias = "GTK_EDITABLE_PROP_WIDTH_CHARS")]
    PropWidthChars,
    #[doc(alias = "GTK_EDITABLE_PROP_MAX_WIDTH_CHARS")]
    PropMaxWidthChars,
    #[doc(alias = "GTK_EDITABLE_PROP_XALIGN")]
    PropXalign,
    #[doc(alias = "GTK_EDITABLE_PROP_ENABLE_UNDO")]
    PropEnableUndo,
    #[doc(alias = "GTK_EDITABLE_NUM_PROPERTIES")]
    NumProperties,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EditableProperties {
    type GlibType = ffi::GtkEditableProperties;

    #[inline]
    fn into_glib(self) -> ffi::GtkEditableProperties {
        match self {
            Self::PropText => ffi::GTK_EDITABLE_PROP_TEXT,
            Self::PropCursorPosition => ffi::GTK_EDITABLE_PROP_CURSOR_POSITION,
            Self::PropSelectionBound => ffi::GTK_EDITABLE_PROP_SELECTION_BOUND,
            Self::PropEditable => ffi::GTK_EDITABLE_PROP_EDITABLE,
            Self::PropWidthChars => ffi::GTK_EDITABLE_PROP_WIDTH_CHARS,
            Self::PropMaxWidthChars => ffi::GTK_EDITABLE_PROP_MAX_WIDTH_CHARS,
            Self::PropXalign => ffi::GTK_EDITABLE_PROP_XALIGN,
            Self::PropEnableUndo => ffi::GTK_EDITABLE_PROP_ENABLE_UNDO,
            Self::NumProperties => ffi::GTK_EDITABLE_NUM_PROPERTIES,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEditableProperties> for EditableProperties {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkEditableProperties) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_EDITABLE_PROP_TEXT => Self::PropText,
            ffi::GTK_EDITABLE_PROP_CURSOR_POSITION => Self::PropCursorPosition,
            ffi::GTK_EDITABLE_PROP_SELECTION_BOUND => Self::PropSelectionBound,
            ffi::GTK_EDITABLE_PROP_EDITABLE => Self::PropEditable,
            ffi::GTK_EDITABLE_PROP_WIDTH_CHARS => Self::PropWidthChars,
            ffi::GTK_EDITABLE_PROP_MAX_WIDTH_CHARS => Self::PropMaxWidthChars,
            ffi::GTK_EDITABLE_PROP_XALIGN => Self::PropXalign,
            ffi::GTK_EDITABLE_PROP_ENABLE_UNDO => Self::PropEnableUndo,
            ffi::GTK_EDITABLE_NUM_PROPERTIES => Self::NumProperties,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EditableProperties {
    #[inline]
    #[doc(alias = "gtk_editable_properties_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_editable_properties_get_type()) }
    }
}

impl glib::HasParamSpec for EditableProperties {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for EditableProperties {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EditableProperties {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EditableProperties {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EditableProperties> for glib::Value {
    #[inline]
    fn from(v: EditableProperties) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkEntryIconPosition")]
pub enum EntryIconPosition {
    #[doc(alias = "GTK_ENTRY_ICON_PRIMARY")]
    Primary,
    #[doc(alias = "GTK_ENTRY_ICON_SECONDARY")]
    Secondary,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EntryIconPosition {
    type GlibType = ffi::GtkEntryIconPosition;

    #[inline]
    fn into_glib(self) -> ffi::GtkEntryIconPosition {
        match self {
            Self::Primary => ffi::GTK_ENTRY_ICON_PRIMARY,
            Self::Secondary => ffi::GTK_ENTRY_ICON_SECONDARY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEntryIconPosition> for EntryIconPosition {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkEntryIconPosition) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ENTRY_ICON_PRIMARY => Self::Primary,
            ffi::GTK_ENTRY_ICON_SECONDARY => Self::Secondary,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EntryIconPosition {
    #[inline]
    #[doc(alias = "gtk_entry_icon_position_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_entry_icon_position_get_type()) }
    }
}

impl glib::HasParamSpec for EntryIconPosition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for EntryIconPosition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EntryIconPosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EntryIconPosition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EntryIconPosition> for glib::Value {
    #[inline]
    fn from(v: EntryIconPosition) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkEventSequenceState")]
pub enum EventSequenceState {
    #[doc(alias = "GTK_EVENT_SEQUENCE_NONE")]
    None,
    #[doc(alias = "GTK_EVENT_SEQUENCE_CLAIMED")]
    Claimed,
    #[doc(alias = "GTK_EVENT_SEQUENCE_DENIED")]
    Denied,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EventSequenceState {
    type GlibType = ffi::GtkEventSequenceState;

    #[inline]
    fn into_glib(self) -> ffi::GtkEventSequenceState {
        match self {
            Self::None => ffi::GTK_EVENT_SEQUENCE_NONE,
            Self::Claimed => ffi::GTK_EVENT_SEQUENCE_CLAIMED,
            Self::Denied => ffi::GTK_EVENT_SEQUENCE_DENIED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEventSequenceState> for EventSequenceState {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkEventSequenceState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_EVENT_SEQUENCE_NONE => Self::None,
            ffi::GTK_EVENT_SEQUENCE_CLAIMED => Self::Claimed,
            ffi::GTK_EVENT_SEQUENCE_DENIED => Self::Denied,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EventSequenceState {
    #[inline]
    #[doc(alias = "gtk_event_sequence_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_event_sequence_state_get_type()) }
    }
}

impl glib::HasParamSpec for EventSequenceState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for EventSequenceState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EventSequenceState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EventSequenceState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EventSequenceState> for glib::Value {
    #[inline]
    fn from(v: EventSequenceState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFileChooserAction")]
pub enum FileChooserAction {
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_OPEN")]
    Open,
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_SAVE")]
    Save,
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER")]
    SelectFolder,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FileChooserAction {
    type GlibType = ffi::GtkFileChooserAction;

    #[inline]
    fn into_glib(self) -> ffi::GtkFileChooserAction {
        match self {
            Self::Open => ffi::GTK_FILE_CHOOSER_ACTION_OPEN,
            Self::Save => ffi::GTK_FILE_CHOOSER_ACTION_SAVE,
            Self::SelectFolder => ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserAction> for FileChooserAction {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFileChooserAction) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_FILE_CHOOSER_ACTION_OPEN => Self::Open,
            ffi::GTK_FILE_CHOOSER_ACTION_SAVE => Self::Save,
            ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER => Self::SelectFolder,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FileChooserAction {
    #[inline]
    #[doc(alias = "gtk_file_chooser_action_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_file_chooser_action_get_type()) }
    }
}

impl glib::HasParamSpec for FileChooserAction {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FileChooserAction {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FileChooserAction {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileChooserAction {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FileChooserAction> for glib::Value {
    #[inline]
    fn from(v: FileChooserAction) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFileChooserError")]
pub enum FileChooserError {
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_NONEXISTENT")]
    Nonexistent,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_BAD_FILENAME")]
    BadFilename,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS")]
    AlreadyExists,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME")]
    IncompleteHostname,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FileChooserError {
    type GlibType = ffi::GtkFileChooserError;

    #[inline]
    fn into_glib(self) -> ffi::GtkFileChooserError {
        match self {
            Self::Nonexistent => ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT,
            Self::BadFilename => ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME,
            Self::AlreadyExists => ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS,
            Self::IncompleteHostname => ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserError> for FileChooserError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFileChooserError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT => Self::Nonexistent,
            ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME => Self::BadFilename,
            ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS => Self::AlreadyExists,
            ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME => Self::IncompleteHostname,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for FileChooserError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_file_chooser_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for FileChooserError {
    #[inline]
    #[doc(alias = "gtk_file_chooser_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_file_chooser_error_get_type()) }
    }
}

impl glib::HasParamSpec for FileChooserError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FileChooserError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FileChooserError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileChooserError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FileChooserError> for glib::Value {
    #[inline]
    fn from(v: FileChooserError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFilterChange")]
pub enum FilterChange {
    #[doc(alias = "GTK_FILTER_CHANGE_DIFFERENT")]
    Different,
    #[doc(alias = "GTK_FILTER_CHANGE_LESS_STRICT")]
    LessStrict,
    #[doc(alias = "GTK_FILTER_CHANGE_MORE_STRICT")]
    MoreStrict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FilterChange {
    type GlibType = ffi::GtkFilterChange;

    #[inline]
    fn into_glib(self) -> ffi::GtkFilterChange {
        match self {
            Self::Different => ffi::GTK_FILTER_CHANGE_DIFFERENT,
            Self::LessStrict => ffi::GTK_FILTER_CHANGE_LESS_STRICT,
            Self::MoreStrict => ffi::GTK_FILTER_CHANGE_MORE_STRICT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFilterChange> for FilterChange {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFilterChange) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_FILTER_CHANGE_DIFFERENT => Self::Different,
            ffi::GTK_FILTER_CHANGE_LESS_STRICT => Self::LessStrict,
            ffi::GTK_FILTER_CHANGE_MORE_STRICT => Self::MoreStrict,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FilterChange {
    #[inline]
    #[doc(alias = "gtk_filter_change_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_filter_change_get_type()) }
    }
}

impl glib::HasParamSpec for FilterChange {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FilterChange {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FilterChange {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FilterChange {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FilterChange> for glib::Value {
    #[inline]
    fn from(v: FilterChange) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFilterMatch")]
pub enum FilterMatch {
    #[doc(alias = "GTK_FILTER_MATCH_SOME")]
    Some,
    #[doc(alias = "GTK_FILTER_MATCH_NONE")]
    None,
    #[doc(alias = "GTK_FILTER_MATCH_ALL")]
    All,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FilterMatch {
    type GlibType = ffi::GtkFilterMatch;

    #[inline]
    fn into_glib(self) -> ffi::GtkFilterMatch {
        match self {
            Self::Some => ffi::GTK_FILTER_MATCH_SOME,
            Self::None => ffi::GTK_FILTER_MATCH_NONE,
            Self::All => ffi::GTK_FILTER_MATCH_ALL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFilterMatch> for FilterMatch {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFilterMatch) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_FILTER_MATCH_SOME => Self::Some,
            ffi::GTK_FILTER_MATCH_NONE => Self::None,
            ffi::GTK_FILTER_MATCH_ALL => Self::All,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FilterMatch {
    #[inline]
    #[doc(alias = "gtk_filter_match_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_filter_match_get_type()) }
    }
}

impl glib::HasParamSpec for FilterMatch {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FilterMatch {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FilterMatch {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FilterMatch {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FilterMatch> for glib::Value {
    #[inline]
    fn from(v: FilterMatch) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFontLevel")]
pub enum FontLevel {
    #[doc(alias = "GTK_FONT_LEVEL_FAMILY")]
    Family,
    #[doc(alias = "GTK_FONT_LEVEL_FACE")]
    Face,
    #[doc(alias = "GTK_FONT_LEVEL_FONT")]
    Font,
    #[doc(alias = "GTK_FONT_LEVEL_FEATURES")]
    Features,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl IntoGlib for FontLevel {
    type GlibType = ffi::GtkFontLevel;

    #[inline]
    fn into_glib(self) -> ffi::GtkFontLevel {
        match self {
            Self::Family => ffi::GTK_FONT_LEVEL_FAMILY,
            Self::Face => ffi::GTK_FONT_LEVEL_FACE,
            Self::Font => ffi::GTK_FONT_LEVEL_FONT,
            Self::Features => ffi::GTK_FONT_LEVEL_FEATURES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkFontLevel> for FontLevel {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkFontLevel) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_FONT_LEVEL_FAMILY => Self::Family,
            ffi::GTK_FONT_LEVEL_FACE => Self::Face,
            ffi::GTK_FONT_LEVEL_FONT => Self::Font,
            ffi::GTK_FONT_LEVEL_FEATURES => Self::Features,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl StaticType for FontLevel {
    #[inline]
    #[doc(alias = "gtk_font_level_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_font_level_get_type()) }
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::HasParamSpec for FontLevel {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl glib::value::ValueType for FontLevel {
    type Type = Self;
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for FontLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl ToValue for FontLevel {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_10")))]
impl From<FontLevel> for glib::Value {
    #[inline]
    fn from(v: FontLevel) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkGraphicsOffloadEnabled")]
pub enum GraphicsOffloadEnabled {
    #[doc(alias = "GTK_GRAPHICS_OFFLOAD_ENABLED")]
    Enabled,
    #[doc(alias = "GTK_GRAPHICS_OFFLOAD_DISABLED")]
    Disabled,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl IntoGlib for GraphicsOffloadEnabled {
    type GlibType = ffi::GtkGraphicsOffloadEnabled;

    #[inline]
    fn into_glib(self) -> ffi::GtkGraphicsOffloadEnabled {
        match self {
            Self::Enabled => ffi::GTK_GRAPHICS_OFFLOAD_ENABLED,
            Self::Disabled => ffi::GTK_GRAPHICS_OFFLOAD_DISABLED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkGraphicsOffloadEnabled> for GraphicsOffloadEnabled {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkGraphicsOffloadEnabled) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_GRAPHICS_OFFLOAD_ENABLED => Self::Enabled,
            ffi::GTK_GRAPHICS_OFFLOAD_DISABLED => Self::Disabled,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl StaticType for GraphicsOffloadEnabled {
    #[inline]
    #[doc(alias = "gtk_graphics_offload_enabled_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_graphics_offload_enabled_get_type()) }
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::HasParamSpec for GraphicsOffloadEnabled {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl glib::value::ValueType for GraphicsOffloadEnabled {
    type Type = Self;
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for GraphicsOffloadEnabled {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl ToValue for GraphicsOffloadEnabled {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
impl From<GraphicsOffloadEnabled> for glib::Value {
    #[inline]
    fn from(v: GraphicsOffloadEnabled) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconSize")]
pub enum IconSize {
    #[doc(alias = "GTK_ICON_SIZE_INHERIT")]
    Inherit,
    #[doc(alias = "GTK_ICON_SIZE_NORMAL")]
    Normal,
    #[doc(alias = "GTK_ICON_SIZE_LARGE")]
    Large,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for IconSize {
    type GlibType = ffi::GtkIconSize;

    #[inline]
    fn into_glib(self) -> ffi::GtkIconSize {
        match self {
            Self::Inherit => ffi::GTK_ICON_SIZE_INHERIT,
            Self::Normal => ffi::GTK_ICON_SIZE_NORMAL,
            Self::Large => ffi::GTK_ICON_SIZE_LARGE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconSize> for IconSize {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkIconSize) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ICON_SIZE_INHERIT => Self::Inherit,
            ffi::GTK_ICON_SIZE_NORMAL => Self::Normal,
            ffi::GTK_ICON_SIZE_LARGE => Self::Large,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for IconSize {
    #[inline]
    #[doc(alias = "gtk_icon_size_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_icon_size_get_type()) }
    }
}

impl glib::HasParamSpec for IconSize {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for IconSize {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for IconSize {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for IconSize {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<IconSize> for glib::Value {
    #[inline]
    fn from(v: IconSize) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconThemeError")]
pub enum IconThemeError {
    #[doc(alias = "GTK_ICON_THEME_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_ICON_THEME_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for IconThemeError {
    type GlibType = ffi::GtkIconThemeError;

    #[inline]
    fn into_glib(self) -> ffi::GtkIconThemeError {
        match self {
            Self::NotFound => ffi::GTK_ICON_THEME_NOT_FOUND,
            Self::Failed => ffi::GTK_ICON_THEME_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconThemeError> for IconThemeError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkIconThemeError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ICON_THEME_NOT_FOUND => Self::NotFound,
            ffi::GTK_ICON_THEME_FAILED => Self::Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for IconThemeError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_icon_theme_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for IconThemeError {
    #[inline]
    #[doc(alias = "gtk_icon_theme_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_icon_theme_error_get_type()) }
    }
}

impl glib::HasParamSpec for IconThemeError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for IconThemeError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for IconThemeError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for IconThemeError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<IconThemeError> for glib::Value {
    #[inline]
    fn from(v: IconThemeError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconViewDropPosition")]
pub enum IconViewDropPosition {
    #[doc(alias = "GTK_ICON_VIEW_NO_DROP")]
    NoDrop,
    #[doc(alias = "GTK_ICON_VIEW_DROP_INTO")]
    DropInto,
    #[doc(alias = "GTK_ICON_VIEW_DROP_LEFT")]
    DropLeft,
    #[doc(alias = "GTK_ICON_VIEW_DROP_RIGHT")]
    DropRight,
    #[doc(alias = "GTK_ICON_VIEW_DROP_ABOVE")]
    DropAbove,
    #[doc(alias = "GTK_ICON_VIEW_DROP_BELOW")]
    DropBelow,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for IconViewDropPosition {
    type GlibType = ffi::GtkIconViewDropPosition;

    #[inline]
    fn into_glib(self) -> ffi::GtkIconViewDropPosition {
        match self {
            Self::NoDrop => ffi::GTK_ICON_VIEW_NO_DROP,
            Self::DropInto => ffi::GTK_ICON_VIEW_DROP_INTO,
            Self::DropLeft => ffi::GTK_ICON_VIEW_DROP_LEFT,
            Self::DropRight => ffi::GTK_ICON_VIEW_DROP_RIGHT,
            Self::DropAbove => ffi::GTK_ICON_VIEW_DROP_ABOVE,
            Self::DropBelow => ffi::GTK_ICON_VIEW_DROP_BELOW,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconViewDropPosition> for IconViewDropPosition {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkIconViewDropPosition) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ICON_VIEW_NO_DROP => Self::NoDrop,
            ffi::GTK_ICON_VIEW_DROP_INTO => Self::DropInto,
            ffi::GTK_ICON_VIEW_DROP_LEFT => Self::DropLeft,
            ffi::GTK_ICON_VIEW_DROP_RIGHT => Self::DropRight,
            ffi::GTK_ICON_VIEW_DROP_ABOVE => Self::DropAbove,
            ffi::GTK_ICON_VIEW_DROP_BELOW => Self::DropBelow,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for IconViewDropPosition {
    #[inline]
    #[doc(alias = "gtk_icon_view_drop_position_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_icon_view_drop_position_get_type()) }
    }
}

impl glib::HasParamSpec for IconViewDropPosition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for IconViewDropPosition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for IconViewDropPosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for IconViewDropPosition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<IconViewDropPosition> for glib::Value {
    #[inline]
    fn from(v: IconViewDropPosition) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkImageType")]
pub enum ImageType {
    #[doc(alias = "GTK_IMAGE_EMPTY")]
    Empty,
    #[doc(alias = "GTK_IMAGE_ICON_NAME")]
    IconName,
    #[doc(alias = "GTK_IMAGE_GICON")]
    Gicon,
    #[doc(alias = "GTK_IMAGE_PAINTABLE")]
    Paintable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ImageType {
    type GlibType = ffi::GtkImageType;

    #[inline]
    fn into_glib(self) -> ffi::GtkImageType {
        match self {
            Self::Empty => ffi::GTK_IMAGE_EMPTY,
            Self::IconName => ffi::GTK_IMAGE_ICON_NAME,
            Self::Gicon => ffi::GTK_IMAGE_GICON,
            Self::Paintable => ffi::GTK_IMAGE_PAINTABLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkImageType> for ImageType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkImageType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_IMAGE_EMPTY => Self::Empty,
            ffi::GTK_IMAGE_ICON_NAME => Self::IconName,
            ffi::GTK_IMAGE_GICON => Self::Gicon,
            ffi::GTK_IMAGE_PAINTABLE => Self::Paintable,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ImageType {
    #[inline]
    #[doc(alias = "gtk_image_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_image_type_get_type()) }
    }
}

impl glib::HasParamSpec for ImageType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ImageType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ImageType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ImageType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ImageType> for glib::Value {
    #[inline]
    fn from(v: ImageType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkInputPurpose")]
pub enum InputPurpose {
    #[doc(alias = "GTK_INPUT_PURPOSE_FREE_FORM")]
    FreeForm,
    #[doc(alias = "GTK_INPUT_PURPOSE_ALPHA")]
    Alpha,
    #[doc(alias = "GTK_INPUT_PURPOSE_DIGITS")]
    Digits,
    #[doc(alias = "GTK_INPUT_PURPOSE_NUMBER")]
    Number,
    #[doc(alias = "GTK_INPUT_PURPOSE_PHONE")]
    Phone,
    #[doc(alias = "GTK_INPUT_PURPOSE_URL")]
    Url,
    #[doc(alias = "GTK_INPUT_PURPOSE_EMAIL")]
    Email,
    #[doc(alias = "GTK_INPUT_PURPOSE_NAME")]
    Name,
    #[doc(alias = "GTK_INPUT_PURPOSE_PASSWORD")]
    Password,
    #[doc(alias = "GTK_INPUT_PURPOSE_PIN")]
    Pin,
    #[doc(alias = "GTK_INPUT_PURPOSE_TERMINAL")]
    Terminal,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for InputPurpose {
    type GlibType = ffi::GtkInputPurpose;

    #[inline]
    fn into_glib(self) -> ffi::GtkInputPurpose {
        match self {
            Self::FreeForm => ffi::GTK_INPUT_PURPOSE_FREE_FORM,
            Self::Alpha => ffi::GTK_INPUT_PURPOSE_ALPHA,
            Self::Digits => ffi::GTK_INPUT_PURPOSE_DIGITS,
            Self::Number => ffi::GTK_INPUT_PURPOSE_NUMBER,
            Self::Phone => ffi::GTK_INPUT_PURPOSE_PHONE,
            Self::Url => ffi::GTK_INPUT_PURPOSE_URL,
            Self::Email => ffi::GTK_INPUT_PURPOSE_EMAIL,
            Self::Name => ffi::GTK_INPUT_PURPOSE_NAME,
            Self::Password => ffi::GTK_INPUT_PURPOSE_PASSWORD,
            Self::Pin => ffi::GTK_INPUT_PURPOSE_PIN,
            Self::Terminal => ffi::GTK_INPUT_PURPOSE_TERMINAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkInputPurpose> for InputPurpose {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkInputPurpose) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_INPUT_PURPOSE_FREE_FORM => Self::FreeForm,
            ffi::GTK_INPUT_PURPOSE_ALPHA => Self::Alpha,
            ffi::GTK_INPUT_PURPOSE_DIGITS => Self::Digits,
            ffi::GTK_INPUT_PURPOSE_NUMBER => Self::Number,
            ffi::GTK_INPUT_PURPOSE_PHONE => Self::Phone,
            ffi::GTK_INPUT_PURPOSE_URL => Self::Url,
            ffi::GTK_INPUT_PURPOSE_EMAIL => Self::Email,
            ffi::GTK_INPUT_PURPOSE_NAME => Self::Name,
            ffi::GTK_INPUT_PURPOSE_PASSWORD => Self::Password,
            ffi::GTK_INPUT_PURPOSE_PIN => Self::Pin,
            ffi::GTK_INPUT_PURPOSE_TERMINAL => Self::Terminal,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for InputPurpose {
    #[inline]
    #[doc(alias = "gtk_input_purpose_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_input_purpose_get_type()) }
    }
}

impl glib::HasParamSpec for InputPurpose {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for InputPurpose {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for InputPurpose {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for InputPurpose {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<InputPurpose> for glib::Value {
    #[inline]
    fn from(v: InputPurpose) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkInscriptionOverflow")]
pub enum InscriptionOverflow {
    #[doc(alias = "GTK_INSCRIPTION_OVERFLOW_CLIP")]
    Clip,
    #[doc(alias = "GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_START")]
    EllipsizeStart,
    #[doc(alias = "GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_MIDDLE")]
    EllipsizeMiddle,
    #[doc(alias = "GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_END")]
    EllipsizeEnd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[doc(hidden)]
impl IntoGlib for InscriptionOverflow {
    type GlibType = ffi::GtkInscriptionOverflow;

    #[inline]
    fn into_glib(self) -> ffi::GtkInscriptionOverflow {
        match self {
            Self::Clip => ffi::GTK_INSCRIPTION_OVERFLOW_CLIP,
            Self::EllipsizeStart => ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_START,
            Self::EllipsizeMiddle => ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_MIDDLE,
            Self::EllipsizeEnd => ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkInscriptionOverflow> for InscriptionOverflow {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkInscriptionOverflow) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_INSCRIPTION_OVERFLOW_CLIP => Self::Clip,
            ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_START => Self::EllipsizeStart,
            ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_MIDDLE => Self::EllipsizeMiddle,
            ffi::GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_END => Self::EllipsizeEnd,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl StaticType for InscriptionOverflow {
    #[inline]
    #[doc(alias = "gtk_inscription_overflow_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_inscription_overflow_get_type()) }
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl glib::HasParamSpec for InscriptionOverflow {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl glib::value::ValueType for InscriptionOverflow {
    type Type = Self;
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
unsafe impl<'a> glib::value::FromValue<'a> for InscriptionOverflow {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl ToValue for InscriptionOverflow {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_8")))]
impl From<InscriptionOverflow> for glib::Value {
    #[inline]
    fn from(v: InscriptionOverflow) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkJustification")]
pub enum Justification {
    #[doc(alias = "GTK_JUSTIFY_LEFT")]
    Left,
    #[doc(alias = "GTK_JUSTIFY_RIGHT")]
    Right,
    #[doc(alias = "GTK_JUSTIFY_CENTER")]
    Center,
    #[doc(alias = "GTK_JUSTIFY_FILL")]
    Fill,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Justification {
    type GlibType = ffi::GtkJustification;

    #[inline]
    fn into_glib(self) -> ffi::GtkJustification {
        match self {
            Self::Left => ffi::GTK_JUSTIFY_LEFT,
            Self::Right => ffi::GTK_JUSTIFY_RIGHT,
            Self::Center => ffi::GTK_JUSTIFY_CENTER,
            Self::Fill => ffi::GTK_JUSTIFY_FILL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJustification> for Justification {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkJustification) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_JUSTIFY_LEFT => Self::Left,
            ffi::GTK_JUSTIFY_RIGHT => Self::Right,
            ffi::GTK_JUSTIFY_CENTER => Self::Center,
            ffi::GTK_JUSTIFY_FILL => Self::Fill,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Justification {
    #[inline]
    #[doc(alias = "gtk_justification_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_justification_get_type()) }
    }
}

impl glib::HasParamSpec for Justification {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Justification {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Justification {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Justification {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Justification> for glib::Value {
    #[inline]
    fn from(v: Justification) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkLevelBarMode")]
pub enum LevelBarMode {
    #[doc(alias = "GTK_LEVEL_BAR_MODE_CONTINUOUS")]
    Continuous,
    #[doc(alias = "GTK_LEVEL_BAR_MODE_DISCRETE")]
    Discrete,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for LevelBarMode {
    type GlibType = ffi::GtkLevelBarMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkLevelBarMode {
        match self {
            Self::Continuous => ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS,
            Self::Discrete => ffi::GTK_LEVEL_BAR_MODE_DISCRETE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLevelBarMode> for LevelBarMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkLevelBarMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS => Self::Continuous,
            ffi::GTK_LEVEL_BAR_MODE_DISCRETE => Self::Discrete,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LevelBarMode {
    #[inline]
    #[doc(alias = "gtk_level_bar_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_level_bar_mode_get_type()) }
    }
}

impl glib::HasParamSpec for LevelBarMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for LevelBarMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for LevelBarMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LevelBarMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LevelBarMode> for glib::Value {
    #[inline]
    fn from(v: LevelBarMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkLicense")]
pub enum License {
    #[doc(alias = "GTK_LICENSE_UNKNOWN")]
    Unknown,
    #[doc(alias = "GTK_LICENSE_CUSTOM")]
    Custom,
    #[doc(alias = "GTK_LICENSE_GPL_2_0")]
    Gpl20,
    #[doc(alias = "GTK_LICENSE_GPL_3_0")]
    Gpl30,
    #[doc(alias = "GTK_LICENSE_LGPL_2_1")]
    Lgpl21,
    #[doc(alias = "GTK_LICENSE_LGPL_3_0")]
    Lgpl30,
    #[doc(alias = "GTK_LICENSE_BSD")]
    Bsd,
    #[doc(alias = "GTK_LICENSE_MIT_X11")]
    MitX11,
    #[doc(alias = "GTK_LICENSE_ARTISTIC")]
    Artistic,
    #[doc(alias = "GTK_LICENSE_GPL_2_0_ONLY")]
    Gpl20Only,
    #[doc(alias = "GTK_LICENSE_GPL_3_0_ONLY")]
    Gpl30Only,
    #[doc(alias = "GTK_LICENSE_LGPL_2_1_ONLY")]
    Lgpl21Only,
    #[doc(alias = "GTK_LICENSE_LGPL_3_0_ONLY")]
    Lgpl30Only,
    #[doc(alias = "GTK_LICENSE_AGPL_3_0")]
    Agpl30,
    #[doc(alias = "GTK_LICENSE_AGPL_3_0_ONLY")]
    Agpl30Only,
    #[doc(alias = "GTK_LICENSE_BSD_3")]
    Bsd3,
    #[doc(alias = "GTK_LICENSE_APACHE_2_0")]
    Apache20,
    #[doc(alias = "GTK_LICENSE_MPL_2_0")]
    Mpl20,
    #[cfg(feature = "v4_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v4_14")))]
    #[doc(alias = "GTK_LICENSE_0BSD")]
    _0bsd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for License {
    type GlibType = ffi::GtkLicense;

    fn into_glib(self) -> ffi::GtkLicense {
        match self {
            Self::Unknown => ffi::GTK_LICENSE_UNKNOWN,
            Self::Custom => ffi::GTK_LICENSE_CUSTOM,
            Self::Gpl20 => ffi::GTK_LICENSE_GPL_2_0,
            Self::Gpl30 => ffi::GTK_LICENSE_GPL_3_0,
            Self::Lgpl21 => ffi::GTK_LICENSE_LGPL_2_1,
            Self::Lgpl30 => ffi::GTK_LICENSE_LGPL_3_0,
            Self::Bsd => ffi::GTK_LICENSE_BSD,
            Self::MitX11 => ffi::GTK_LICENSE_MIT_X11,
            Self::Artistic => ffi::GTK_LICENSE_ARTISTIC,
            Self::Gpl20Only => ffi::GTK_LICENSE_GPL_2_0_ONLY,
            Self::Gpl30Only => ffi::GTK_LICENSE_GPL_3_0_ONLY,
            Self::Lgpl21Only => ffi::GTK_LICENSE_LGPL_2_1_ONLY,
            Self::Lgpl30Only => ffi::GTK_LICENSE_LGPL_3_0_ONLY,
            Self::Agpl30 => ffi::GTK_LICENSE_AGPL_3_0,
            Self::Agpl30Only => ffi::GTK_LICENSE_AGPL_3_0_ONLY,
            Self::Bsd3 => ffi::GTK_LICENSE_BSD_3,
            Self::Apache20 => ffi::GTK_LICENSE_APACHE_2_0,
            Self::Mpl20 => ffi::GTK_LICENSE_MPL_2_0,
            #[cfg(feature = "v4_14")]
            Self::_0bsd => ffi::GTK_LICENSE_0BSD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLicense> for License {
    unsafe fn from_glib(value: ffi::GtkLicense) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_LICENSE_UNKNOWN => Self::Unknown,
            ffi::GTK_LICENSE_CUSTOM => Self::Custom,
            ffi::GTK_LICENSE_GPL_2_0 => Self::Gpl20,
            ffi::GTK_LICENSE_GPL_3_0 => Self::Gpl30,
            ffi::GTK_LICENSE_LGPL_2_1 => Self::Lgpl21,
            ffi::GTK_LICENSE_LGPL_3_0 => Self::Lgpl30,
            ffi::GTK_LICENSE_BSD => Self::Bsd,
            ffi::GTK_LICENSE_MIT_X11 => Self::MitX11,
            ffi::GTK_LICENSE_ARTISTIC => Self::Artistic,
            ffi::GTK_LICENSE_GPL_2_0_ONLY => Self::Gpl20Only,
            ffi::GTK_LICENSE_GPL_3_0_ONLY => Self::Gpl30Only,
            ffi::GTK_LICENSE_LGPL_2_1_ONLY => Self::Lgpl21Only,
            ffi::GTK_LICENSE_LGPL_3_0_ONLY => Self::Lgpl30Only,
            ffi::GTK_LICENSE_AGPL_3_0 => Self::Agpl30,
            ffi::GTK_LICENSE_AGPL_3_0_ONLY => Self::Agpl30Only,
            ffi::GTK_LICENSE_BSD_3 => Self::Bsd3,
            ffi::GTK_LICENSE_APACHE_2_0 => Self::Apache20,
            ffi::GTK_LICENSE_MPL_2_0 => Self::Mpl20,
            #[cfg(feature = "v4_14")]
            ffi::GTK_LICENSE_0BSD => Self::_0bsd,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for License {
    #[inline]
    #[doc(alias = "gtk_license_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_license_get_type()) }
    }
}

impl glib::HasParamSpec for License {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for License {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for License {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for License {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<License> for glib::Value {
    #[inline]
    fn from(v: License) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkListTabBehavior")]
pub enum ListTabBehavior {
    #[doc(alias = "GTK_LIST_TAB_ALL")]
    All,
    #[doc(alias = "GTK_LIST_TAB_ITEM")]
    Item,
    #[doc(alias = "GTK_LIST_TAB_CELL")]
    Cell,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
#[doc(hidden)]
impl IntoGlib for ListTabBehavior {
    type GlibType = ffi::GtkListTabBehavior;

    #[inline]
    fn into_glib(self) -> ffi::GtkListTabBehavior {
        match self {
            Self::All => ffi::GTK_LIST_TAB_ALL,
            Self::Item => ffi::GTK_LIST_TAB_ITEM,
            Self::Cell => ffi::GTK_LIST_TAB_CELL,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkListTabBehavior> for ListTabBehavior {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkListTabBehavior) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_LIST_TAB_ALL => Self::All,
            ffi::GTK_LIST_TAB_ITEM => Self::Item,
            ffi::GTK_LIST_TAB_CELL => Self::Cell,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
impl StaticType for ListTabBehavior {
    #[inline]
    #[doc(alias = "gtk_list_tab_behavior_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_list_tab_behavior_get_type()) }
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
impl glib::HasParamSpec for ListTabBehavior {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
impl glib::value::ValueType for ListTabBehavior {
    type Type = Self;
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for ListTabBehavior {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
impl ToValue for ListTabBehavior {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_12")))]
impl From<ListTabBehavior> for glib::Value {
    #[inline]
    fn from(v: ListTabBehavior) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkMessageType")]
pub enum MessageType {
    #[doc(alias = "GTK_MESSAGE_INFO")]
    Info,
    #[doc(alias = "GTK_MESSAGE_WARNING")]
    Warning,
    #[doc(alias = "GTK_MESSAGE_QUESTION")]
    Question,
    #[doc(alias = "GTK_MESSAGE_ERROR")]
    Error,
    #[doc(alias = "GTK_MESSAGE_OTHER")]
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MessageType {
    type GlibType = ffi::GtkMessageType;

    #[inline]
    fn into_glib(self) -> ffi::GtkMessageType {
        match self {
            Self::Info => ffi::GTK_MESSAGE_INFO,
            Self::Warning => ffi::GTK_MESSAGE_WARNING,
            Self::Question => ffi::GTK_MESSAGE_QUESTION,
            Self::Error => ffi::GTK_MESSAGE_ERROR,
            Self::Other => ffi::GTK_MESSAGE_OTHER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMessageType> for MessageType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkMessageType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_MESSAGE_INFO => Self::Info,
            ffi::GTK_MESSAGE_WARNING => Self::Warning,
            ffi::GTK_MESSAGE_QUESTION => Self::Question,
            ffi::GTK_MESSAGE_ERROR => Self::Error,
            ffi::GTK_MESSAGE_OTHER => Self::Other,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MessageType {
    #[inline]
    #[doc(alias = "gtk_message_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_message_type_get_type()) }
    }
}

impl glib::HasParamSpec for MessageType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MessageType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MessageType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MessageType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MessageType> for glib::Value {
    #[inline]
    fn from(v: MessageType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkMovementStep")]
pub enum MovementStep {
    #[doc(alias = "GTK_MOVEMENT_LOGICAL_POSITIONS")]
    LogicalPositions,
    #[doc(alias = "GTK_MOVEMENT_VISUAL_POSITIONS")]
    VisualPositions,
    #[doc(alias = "GTK_MOVEMENT_WORDS")]
    Words,
    #[doc(alias = "GTK_MOVEMENT_DISPLAY_LINES")]
    DisplayLines,
    #[doc(alias = "GTK_MOVEMENT_DISPLAY_LINE_ENDS")]
    DisplayLineEnds,
    #[doc(alias = "GTK_MOVEMENT_PARAGRAPHS")]
    Paragraphs,
    #[doc(alias = "GTK_MOVEMENT_PARAGRAPH_ENDS")]
    ParagraphEnds,
    #[doc(alias = "GTK_MOVEMENT_PAGES")]
    Pages,
    #[doc(alias = "GTK_MOVEMENT_BUFFER_ENDS")]
    BufferEnds,
    #[doc(alias = "GTK_MOVEMENT_HORIZONTAL_PAGES")]
    HorizontalPages,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MovementStep {
    type GlibType = ffi::GtkMovementStep;

    #[inline]
    fn into_glib(self) -> ffi::GtkMovementStep {
        match self {
            Self::LogicalPositions => ffi::GTK_MOVEMENT_LOGICAL_POSITIONS,
            Self::VisualPositions => ffi::GTK_MOVEMENT_VISUAL_POSITIONS,
            Self::Words => ffi::GTK_MOVEMENT_WORDS,
            Self::DisplayLines => ffi::GTK_MOVEMENT_DISPLAY_LINES,
            Self::DisplayLineEnds => ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS,
            Self::Paragraphs => ffi::GTK_MOVEMENT_PARAGRAPHS,
            Self::ParagraphEnds => ffi::GTK_MOVEMENT_PARAGRAPH_ENDS,
            Self::Pages => ffi::GTK_MOVEMENT_PAGES,
            Self::BufferEnds => ffi::GTK_MOVEMENT_BUFFER_ENDS,
            Self::HorizontalPages => ffi::GTK_MOVEMENT_HORIZONTAL_PAGES,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMovementStep> for MovementStep {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkMovementStep) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_MOVEMENT_LOGICAL_POSITIONS => Self::LogicalPositions,
            ffi::GTK_MOVEMENT_VISUAL_POSITIONS => Self::VisualPositions,
            ffi::GTK_MOVEMENT_WORDS => Self::Words,
            ffi::GTK_MOVEMENT_DISPLAY_LINES => Self::DisplayLines,
            ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS => Self::DisplayLineEnds,
            ffi::GTK_MOVEMENT_PARAGRAPHS => Self::Paragraphs,
            ffi::GTK_MOVEMENT_PARAGRAPH_ENDS => Self::ParagraphEnds,
            ffi::GTK_MOVEMENT_PAGES => Self::Pages,
            ffi::GTK_MOVEMENT_BUFFER_ENDS => Self::BufferEnds,
            ffi::GTK_MOVEMENT_HORIZONTAL_PAGES => Self::HorizontalPages,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MovementStep {
    #[inline]
    #[doc(alias = "gtk_movement_step_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_movement_step_get_type()) }
    }
}

impl glib::HasParamSpec for MovementStep {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MovementStep {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MovementStep {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MovementStep {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MovementStep> for glib::Value {
    #[inline]
    fn from(v: MovementStep) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkNaturalWrapMode")]
pub enum NaturalWrapMode {
    #[doc(alias = "GTK_NATURAL_WRAP_INHERIT")]
    Inherit,
    #[doc(alias = "GTK_NATURAL_WRAP_NONE")]
    None,
    #[doc(alias = "GTK_NATURAL_WRAP_WORD")]
    Word,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[doc(hidden)]
impl IntoGlib for NaturalWrapMode {
    type GlibType = ffi::GtkNaturalWrapMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkNaturalWrapMode {
        match self {
            Self::Inherit => ffi::GTK_NATURAL_WRAP_INHERIT,
            Self::None => ffi::GTK_NATURAL_WRAP_NONE,
            Self::Word => ffi::GTK_NATURAL_WRAP_WORD,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkNaturalWrapMode> for NaturalWrapMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkNaturalWrapMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_NATURAL_WRAP_INHERIT => Self::Inherit,
            ffi::GTK_NATURAL_WRAP_NONE => Self::None,
            ffi::GTK_NATURAL_WRAP_WORD => Self::Word,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl StaticType for NaturalWrapMode {
    #[inline]
    #[doc(alias = "gtk_natural_wrap_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_natural_wrap_mode_get_type()) }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl glib::HasParamSpec for NaturalWrapMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl glib::value::ValueType for NaturalWrapMode {
    type Type = Self;
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for NaturalWrapMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl ToValue for NaturalWrapMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl From<NaturalWrapMode> for glib::Value {
    #[inline]
    fn from(v: NaturalWrapMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkNotebookTab")]
pub enum NotebookTab {
    #[doc(alias = "GTK_NOTEBOOK_TAB_FIRST")]
    First,
    #[doc(alias = "GTK_NOTEBOOK_TAB_LAST")]
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for NotebookTab {
    type GlibType = ffi::GtkNotebookTab;

    #[inline]
    fn into_glib(self) -> ffi::GtkNotebookTab {
        match self {
            Self::First => ffi::GTK_NOTEBOOK_TAB_FIRST,
            Self::Last => ffi::GTK_NOTEBOOK_TAB_LAST,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNotebookTab> for NotebookTab {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkNotebookTab) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_NOTEBOOK_TAB_FIRST => Self::First,
            ffi::GTK_NOTEBOOK_TAB_LAST => Self::Last,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NotebookTab {
    #[inline]
    #[doc(alias = "gtk_notebook_tab_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_notebook_tab_get_type()) }
    }
}

impl glib::HasParamSpec for NotebookTab {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for NotebookTab {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NotebookTab {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NotebookTab {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NotebookTab> for glib::Value {
    #[inline]
    fn from(v: NotebookTab) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkNumberUpLayout")]
pub enum NumberUpLayout {
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM")]
    Lrtb,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP")]
    Lrbt,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM")]
    Rltb,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP")]
    Rlbt,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT")]
    Tblr,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT")]
    Tbrl,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT")]
    Btlr,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT")]
    Btrl,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for NumberUpLayout {
    type GlibType = ffi::GtkNumberUpLayout;

    #[inline]
    fn into_glib(self) -> ffi::GtkNumberUpLayout {
        match self {
            Self::Lrtb => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM,
            Self::Lrbt => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP,
            Self::Rltb => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM,
            Self::Rlbt => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP,
            Self::Tblr => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT,
            Self::Tbrl => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT,
            Self::Btlr => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT,
            Self::Btrl => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNumberUpLayout> for NumberUpLayout {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkNumberUpLayout) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM => Self::Lrtb,
            ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP => Self::Lrbt,
            ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM => Self::Rltb,
            ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP => Self::Rlbt,
            ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT => Self::Tblr,
            ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT => Self::Tbrl,
            ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT => Self::Btlr,
            ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT => Self::Btrl,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NumberUpLayout {
    #[inline]
    #[doc(alias = "gtk_number_up_layout_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_number_up_layout_get_type()) }
    }
}

impl glib::HasParamSpec for NumberUpLayout {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for NumberUpLayout {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NumberUpLayout {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NumberUpLayout {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NumberUpLayout> for glib::Value {
    #[inline]
    fn from(v: NumberUpLayout) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkOrdering")]
pub enum Ordering {
    #[doc(alias = "GTK_ORDERING_SMALLER")]
    Smaller,
    #[doc(alias = "GTK_ORDERING_EQUAL")]
    Equal,
    #[doc(alias = "GTK_ORDERING_LARGER")]
    Larger,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Ordering {
    type GlibType = ffi::GtkOrdering;

    #[inline]
    fn into_glib(self) -> ffi::GtkOrdering {
        match self {
            Self::Smaller => ffi::GTK_ORDERING_SMALLER,
            Self::Equal => ffi::GTK_ORDERING_EQUAL,
            Self::Larger => ffi::GTK_ORDERING_LARGER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrdering> for Ordering {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkOrdering) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ORDERING_SMALLER => Self::Smaller,
            ffi::GTK_ORDERING_EQUAL => Self::Equal,
            ffi::GTK_ORDERING_LARGER => Self::Larger,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Ordering {
    #[inline]
    #[doc(alias = "gtk_ordering_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_ordering_get_type()) }
    }
}

impl glib::HasParamSpec for Ordering {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Ordering {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Ordering {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Ordering {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Ordering> for glib::Value {
    #[inline]
    fn from(v: Ordering) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkOrientation")]
pub enum Orientation {
    #[doc(alias = "GTK_ORIENTATION_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_ORIENTATION_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Orientation {
    type GlibType = ffi::GtkOrientation;

    #[inline]
    fn into_glib(self) -> ffi::GtkOrientation {
        match self {
            Self::Horizontal => ffi::GTK_ORIENTATION_HORIZONTAL,
            Self::Vertical => ffi::GTK_ORIENTATION_VERTICAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrientation> for Orientation {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkOrientation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_ORIENTATION_HORIZONTAL => Self::Horizontal,
            ffi::GTK_ORIENTATION_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Orientation {
    #[inline]
    #[doc(alias = "gtk_orientation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_orientation_get_type()) }
    }
}

impl glib::HasParamSpec for Orientation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Orientation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Orientation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Orientation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Orientation> for glib::Value {
    #[inline]
    fn from(v: Orientation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkOverflow")]
pub enum Overflow {
    #[doc(alias = "GTK_OVERFLOW_VISIBLE")]
    Visible,
    #[doc(alias = "GTK_OVERFLOW_HIDDEN")]
    Hidden,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Overflow {
    type GlibType = ffi::GtkOverflow;

    #[inline]
    fn into_glib(self) -> ffi::GtkOverflow {
        match self {
            Self::Visible => ffi::GTK_OVERFLOW_VISIBLE,
            Self::Hidden => ffi::GTK_OVERFLOW_HIDDEN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOverflow> for Overflow {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkOverflow) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_OVERFLOW_VISIBLE => Self::Visible,
            ffi::GTK_OVERFLOW_HIDDEN => Self::Hidden,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Overflow {
    #[inline]
    #[doc(alias = "gtk_overflow_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_overflow_get_type()) }
    }
}

impl glib::HasParamSpec for Overflow {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Overflow {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Overflow {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Overflow {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Overflow> for glib::Value {
    #[inline]
    fn from(v: Overflow) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPackType")]
pub enum PackType {
    #[doc(alias = "GTK_PACK_START")]
    Start,
    #[doc(alias = "GTK_PACK_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PackType {
    type GlibType = ffi::GtkPackType;

    #[inline]
    fn into_glib(self) -> ffi::GtkPackType {
        match self {
            Self::Start => ffi::GTK_PACK_START,
            Self::End => ffi::GTK_PACK_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackType> for PackType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPackType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PACK_START => Self::Start,
            ffi::GTK_PACK_END => Self::End,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PackType {
    #[inline]
    #[doc(alias = "gtk_pack_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_pack_type_get_type()) }
    }
}

impl glib::HasParamSpec for PackType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PackType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PackType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PackType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PackType> for glib::Value {
    #[inline]
    fn from(v: PackType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPadActionType")]
pub enum PadActionType {
    #[doc(alias = "GTK_PAD_ACTION_BUTTON")]
    Button,
    #[doc(alias = "GTK_PAD_ACTION_RING")]
    Ring,
    #[doc(alias = "GTK_PAD_ACTION_STRIP")]
    Strip,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PadActionType {
    type GlibType = ffi::GtkPadActionType;

    #[inline]
    fn into_glib(self) -> ffi::GtkPadActionType {
        match self {
            Self::Button => ffi::GTK_PAD_ACTION_BUTTON,
            Self::Ring => ffi::GTK_PAD_ACTION_RING,
            Self::Strip => ffi::GTK_PAD_ACTION_STRIP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPadActionType> for PadActionType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPadActionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PAD_ACTION_BUTTON => Self::Button,
            ffi::GTK_PAD_ACTION_RING => Self::Ring,
            ffi::GTK_PAD_ACTION_STRIP => Self::Strip,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PadActionType {
    #[inline]
    #[doc(alias = "gtk_pad_action_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_pad_action_type_get_type()) }
    }
}

impl glib::HasParamSpec for PadActionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PadActionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PadActionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PadActionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PadActionType> for glib::Value {
    #[inline]
    fn from(v: PadActionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPageOrientation")]
pub enum PageOrientation {
    #[doc(alias = "GTK_PAGE_ORIENTATION_PORTRAIT")]
    Portrait,
    #[doc(alias = "GTK_PAGE_ORIENTATION_LANDSCAPE")]
    Landscape,
    #[doc(alias = "GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT")]
    ReversePortrait,
    #[doc(alias = "GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE")]
    ReverseLandscape,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PageOrientation {
    type GlibType = ffi::GtkPageOrientation;

    #[inline]
    fn into_glib(self) -> ffi::GtkPageOrientation {
        match self {
            Self::Portrait => ffi::GTK_PAGE_ORIENTATION_PORTRAIT,
            Self::Landscape => ffi::GTK_PAGE_ORIENTATION_LANDSCAPE,
            Self::ReversePortrait => ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
            Self::ReverseLandscape => ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageOrientation> for PageOrientation {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPageOrientation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PAGE_ORIENTATION_PORTRAIT => Self::Portrait,
            ffi::GTK_PAGE_ORIENTATION_LANDSCAPE => Self::Landscape,
            ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT => Self::ReversePortrait,
            ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE => Self::ReverseLandscape,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PageOrientation {
    #[inline]
    #[doc(alias = "gtk_page_orientation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_page_orientation_get_type()) }
    }
}

impl glib::HasParamSpec for PageOrientation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PageOrientation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PageOrientation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PageOrientation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PageOrientation> for glib::Value {
    #[inline]
    fn from(v: PageOrientation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPageSet")]
pub enum PageSet {
    #[doc(alias = "GTK_PAGE_SET_ALL")]
    All,
    #[doc(alias = "GTK_PAGE_SET_EVEN")]
    Even,
    #[doc(alias = "GTK_PAGE_SET_ODD")]
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PageSet {
    type GlibType = ffi::GtkPageSet;

    #[inline]
    fn into_glib(self) -> ffi::GtkPageSet {
        match self {
            Self::All => ffi::GTK_PAGE_SET_ALL,
            Self::Even => ffi::GTK_PAGE_SET_EVEN,
            Self::Odd => ffi::GTK_PAGE_SET_ODD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageSet> for PageSet {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPageSet) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PAGE_SET_ALL => Self::All,
            ffi::GTK_PAGE_SET_EVEN => Self::Even,
            ffi::GTK_PAGE_SET_ODD => Self::Odd,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PageSet {
    #[inline]
    #[doc(alias = "gtk_page_set_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_page_set_get_type()) }
    }
}

impl glib::HasParamSpec for PageSet {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PageSet {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PageSet {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PageSet {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PageSet> for glib::Value {
    #[inline]
    fn from(v: PageSet) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPanDirection")]
pub enum PanDirection {
    #[doc(alias = "GTK_PAN_DIRECTION_LEFT")]
    Left,
    #[doc(alias = "GTK_PAN_DIRECTION_RIGHT")]
    Right,
    #[doc(alias = "GTK_PAN_DIRECTION_UP")]
    Up,
    #[doc(alias = "GTK_PAN_DIRECTION_DOWN")]
    Down,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PanDirection {
    type GlibType = ffi::GtkPanDirection;

    #[inline]
    fn into_glib(self) -> ffi::GtkPanDirection {
        match self {
            Self::Left => ffi::GTK_PAN_DIRECTION_LEFT,
            Self::Right => ffi::GTK_PAN_DIRECTION_RIGHT,
            Self::Up => ffi::GTK_PAN_DIRECTION_UP,
            Self::Down => ffi::GTK_PAN_DIRECTION_DOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPanDirection> for PanDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPanDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PAN_DIRECTION_LEFT => Self::Left,
            ffi::GTK_PAN_DIRECTION_RIGHT => Self::Right,
            ffi::GTK_PAN_DIRECTION_UP => Self::Up,
            ffi::GTK_PAN_DIRECTION_DOWN => Self::Down,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PanDirection {
    #[inline]
    #[doc(alias = "gtk_pan_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_pan_direction_get_type()) }
    }
}

impl glib::HasParamSpec for PanDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PanDirection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PanDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PanDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PanDirection> for glib::Value {
    #[inline]
    fn from(v: PanDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPolicyType")]
pub enum PolicyType {
    #[doc(alias = "GTK_POLICY_ALWAYS")]
    Always,
    #[doc(alias = "GTK_POLICY_AUTOMATIC")]
    Automatic,
    #[doc(alias = "GTK_POLICY_NEVER")]
    Never,
    #[doc(alias = "GTK_POLICY_EXTERNAL")]
    External,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PolicyType {
    type GlibType = ffi::GtkPolicyType;

    #[inline]
    fn into_glib(self) -> ffi::GtkPolicyType {
        match self {
            Self::Always => ffi::GTK_POLICY_ALWAYS,
            Self::Automatic => ffi::GTK_POLICY_AUTOMATIC,
            Self::Never => ffi::GTK_POLICY_NEVER,
            Self::External => ffi::GTK_POLICY_EXTERNAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPolicyType> for PolicyType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPolicyType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_POLICY_ALWAYS => Self::Always,
            ffi::GTK_POLICY_AUTOMATIC => Self::Automatic,
            ffi::GTK_POLICY_NEVER => Self::Never,
            ffi::GTK_POLICY_EXTERNAL => Self::External,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PolicyType {
    #[inline]
    #[doc(alias = "gtk_policy_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_policy_type_get_type()) }
    }
}

impl glib::HasParamSpec for PolicyType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PolicyType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PolicyType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PolicyType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PolicyType> for glib::Value {
    #[inline]
    fn from(v: PolicyType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPositionType")]
pub enum PositionType {
    #[doc(alias = "GTK_POS_LEFT")]
    Left,
    #[doc(alias = "GTK_POS_RIGHT")]
    Right,
    #[doc(alias = "GTK_POS_TOP")]
    Top,
    #[doc(alias = "GTK_POS_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PositionType {
    type GlibType = ffi::GtkPositionType;

    #[inline]
    fn into_glib(self) -> ffi::GtkPositionType {
        match self {
            Self::Left => ffi::GTK_POS_LEFT,
            Self::Right => ffi::GTK_POS_RIGHT,
            Self::Top => ffi::GTK_POS_TOP,
            Self::Bottom => ffi::GTK_POS_BOTTOM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPositionType> for PositionType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPositionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_POS_LEFT => Self::Left,
            ffi::GTK_POS_RIGHT => Self::Right,
            ffi::GTK_POS_TOP => Self::Top,
            ffi::GTK_POS_BOTTOM => Self::Bottom,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PositionType {
    #[inline]
    #[doc(alias = "gtk_position_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_position_type_get_type()) }
    }
}

impl glib::HasParamSpec for PositionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PositionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PositionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PositionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PositionType> for glib::Value {
    #[inline]
    fn from(v: PositionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintDuplex")]
pub enum PrintDuplex {
    #[doc(alias = "GTK_PRINT_DUPLEX_SIMPLEX")]
    Simplex,
    #[doc(alias = "GTK_PRINT_DUPLEX_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_PRINT_DUPLEX_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintDuplex {
    type GlibType = ffi::GtkPrintDuplex;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintDuplex {
        match self {
            Self::Simplex => ffi::GTK_PRINT_DUPLEX_SIMPLEX,
            Self::Horizontal => ffi::GTK_PRINT_DUPLEX_HORIZONTAL,
            Self::Vertical => ffi::GTK_PRINT_DUPLEX_VERTICAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintDuplex> for PrintDuplex {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintDuplex) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_DUPLEX_SIMPLEX => Self::Simplex,
            ffi::GTK_PRINT_DUPLEX_HORIZONTAL => Self::Horizontal,
            ffi::GTK_PRINT_DUPLEX_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintDuplex {
    #[inline]
    #[doc(alias = "gtk_print_duplex_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_duplex_get_type()) }
    }
}

impl glib::HasParamSpec for PrintDuplex {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintDuplex {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintDuplex {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintDuplex {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintDuplex> for glib::Value {
    #[inline]
    fn from(v: PrintDuplex) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintError")]
pub enum PrintError {
    #[doc(alias = "GTK_PRINT_ERROR_GENERAL")]
    General,
    #[doc(alias = "GTK_PRINT_ERROR_INTERNAL_ERROR")]
    InternalError,
    #[doc(alias = "GTK_PRINT_ERROR_NOMEM")]
    Nomem,
    #[doc(alias = "GTK_PRINT_ERROR_INVALID_FILE")]
    InvalidFile,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintError {
    type GlibType = ffi::GtkPrintError;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintError {
        match self {
            Self::General => ffi::GTK_PRINT_ERROR_GENERAL,
            Self::InternalError => ffi::GTK_PRINT_ERROR_INTERNAL_ERROR,
            Self::Nomem => ffi::GTK_PRINT_ERROR_NOMEM,
            Self::InvalidFile => ffi::GTK_PRINT_ERROR_INVALID_FILE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintError> for PrintError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_ERROR_GENERAL => Self::General,
            ffi::GTK_PRINT_ERROR_INTERNAL_ERROR => Self::InternalError,
            ffi::GTK_PRINT_ERROR_NOMEM => Self::Nomem,
            ffi::GTK_PRINT_ERROR_INVALID_FILE => Self::InvalidFile,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for PrintError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_print_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for PrintError {
    #[inline]
    #[doc(alias = "gtk_print_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_error_get_type()) }
    }
}

impl glib::HasParamSpec for PrintError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintError> for glib::Value {
    #[inline]
    fn from(v: PrintError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintOperationAction")]
pub enum PrintOperationAction {
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG")]
    PrintDialog,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PRINT")]
    Print,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PREVIEW")]
    Preview,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_EXPORT")]
    Export,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintOperationAction {
    type GlibType = ffi::GtkPrintOperationAction;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintOperationAction {
        match self {
            Self::PrintDialog => ffi::GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
            Self::Print => ffi::GTK_PRINT_OPERATION_ACTION_PRINT,
            Self::Preview => ffi::GTK_PRINT_OPERATION_ACTION_PREVIEW,
            Self::Export => ffi::GTK_PRINT_OPERATION_ACTION_EXPORT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationAction> for PrintOperationAction {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintOperationAction) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG => Self::PrintDialog,
            ffi::GTK_PRINT_OPERATION_ACTION_PRINT => Self::Print,
            ffi::GTK_PRINT_OPERATION_ACTION_PREVIEW => Self::Preview,
            ffi::GTK_PRINT_OPERATION_ACTION_EXPORT => Self::Export,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationAction {
    #[inline]
    #[doc(alias = "gtk_print_operation_action_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_operation_action_get_type()) }
    }
}

impl glib::HasParamSpec for PrintOperationAction {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintOperationAction {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintOperationAction {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintOperationAction {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintOperationAction> for glib::Value {
    #[inline]
    fn from(v: PrintOperationAction) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintOperationResult")]
pub enum PrintOperationResult {
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_ERROR")]
    Error,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_APPLY")]
    Apply,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_CANCEL")]
    Cancel,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_IN_PROGRESS")]
    InProgress,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintOperationResult {
    type GlibType = ffi::GtkPrintOperationResult;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintOperationResult {
        match self {
            Self::Error => ffi::GTK_PRINT_OPERATION_RESULT_ERROR,
            Self::Apply => ffi::GTK_PRINT_OPERATION_RESULT_APPLY,
            Self::Cancel => ffi::GTK_PRINT_OPERATION_RESULT_CANCEL,
            Self::InProgress => ffi::GTK_PRINT_OPERATION_RESULT_IN_PROGRESS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationResult> for PrintOperationResult {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintOperationResult) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_OPERATION_RESULT_ERROR => Self::Error,
            ffi::GTK_PRINT_OPERATION_RESULT_APPLY => Self::Apply,
            ffi::GTK_PRINT_OPERATION_RESULT_CANCEL => Self::Cancel,
            ffi::GTK_PRINT_OPERATION_RESULT_IN_PROGRESS => Self::InProgress,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResult {
    #[inline]
    #[doc(alias = "gtk_print_operation_result_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_operation_result_get_type()) }
    }
}

impl glib::HasParamSpec for PrintOperationResult {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintOperationResult {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintOperationResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintOperationResult {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintOperationResult> for glib::Value {
    #[inline]
    fn from(v: PrintOperationResult) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintPages")]
pub enum PrintPages {
    #[doc(alias = "GTK_PRINT_PAGES_ALL")]
    All,
    #[doc(alias = "GTK_PRINT_PAGES_CURRENT")]
    Current,
    #[doc(alias = "GTK_PRINT_PAGES_RANGES")]
    Ranges,
    #[doc(alias = "GTK_PRINT_PAGES_SELECTION")]
    Selection,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintPages {
    type GlibType = ffi::GtkPrintPages;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintPages {
        match self {
            Self::All => ffi::GTK_PRINT_PAGES_ALL,
            Self::Current => ffi::GTK_PRINT_PAGES_CURRENT,
            Self::Ranges => ffi::GTK_PRINT_PAGES_RANGES,
            Self::Selection => ffi::GTK_PRINT_PAGES_SELECTION,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintPages> for PrintPages {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintPages) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_PAGES_ALL => Self::All,
            ffi::GTK_PRINT_PAGES_CURRENT => Self::Current,
            ffi::GTK_PRINT_PAGES_RANGES => Self::Ranges,
            ffi::GTK_PRINT_PAGES_SELECTION => Self::Selection,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintPages {
    #[inline]
    #[doc(alias = "gtk_print_pages_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_pages_get_type()) }
    }
}

impl glib::HasParamSpec for PrintPages {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintPages {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintPages {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintPages {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintPages> for glib::Value {
    #[inline]
    fn from(v: PrintPages) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintQuality")]
pub enum PrintQuality {
    #[doc(alias = "GTK_PRINT_QUALITY_LOW")]
    Low,
    #[doc(alias = "GTK_PRINT_QUALITY_NORMAL")]
    Normal,
    #[doc(alias = "GTK_PRINT_QUALITY_HIGH")]
    High,
    #[doc(alias = "GTK_PRINT_QUALITY_DRAFT")]
    Draft,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintQuality {
    type GlibType = ffi::GtkPrintQuality;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintQuality {
        match self {
            Self::Low => ffi::GTK_PRINT_QUALITY_LOW,
            Self::Normal => ffi::GTK_PRINT_QUALITY_NORMAL,
            Self::High => ffi::GTK_PRINT_QUALITY_HIGH,
            Self::Draft => ffi::GTK_PRINT_QUALITY_DRAFT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintQuality> for PrintQuality {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintQuality) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_QUALITY_LOW => Self::Low,
            ffi::GTK_PRINT_QUALITY_NORMAL => Self::Normal,
            ffi::GTK_PRINT_QUALITY_HIGH => Self::High,
            ffi::GTK_PRINT_QUALITY_DRAFT => Self::Draft,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintQuality {
    #[inline]
    #[doc(alias = "gtk_print_quality_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_quality_get_type()) }
    }
}

impl glib::HasParamSpec for PrintQuality {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintQuality {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintQuality {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintQuality {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintQuality> for glib::Value {
    #[inline]
    fn from(v: PrintQuality) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintStatus")]
pub enum PrintStatus {
    #[doc(alias = "GTK_PRINT_STATUS_INITIAL")]
    Initial,
    #[doc(alias = "GTK_PRINT_STATUS_PREPARING")]
    Preparing,
    #[doc(alias = "GTK_PRINT_STATUS_GENERATING_DATA")]
    GeneratingData,
    #[doc(alias = "GTK_PRINT_STATUS_SENDING_DATA")]
    SendingData,
    #[doc(alias = "GTK_PRINT_STATUS_PENDING")]
    Pending,
    #[doc(alias = "GTK_PRINT_STATUS_PENDING_ISSUE")]
    PendingIssue,
    #[doc(alias = "GTK_PRINT_STATUS_PRINTING")]
    Printing,
    #[doc(alias = "GTK_PRINT_STATUS_FINISHED")]
    Finished,
    #[doc(alias = "GTK_PRINT_STATUS_FINISHED_ABORTED")]
    FinishedAborted,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintStatus {
    type GlibType = ffi::GtkPrintStatus;

    #[inline]
    fn into_glib(self) -> ffi::GtkPrintStatus {
        match self {
            Self::Initial => ffi::GTK_PRINT_STATUS_INITIAL,
            Self::Preparing => ffi::GTK_PRINT_STATUS_PREPARING,
            Self::GeneratingData => ffi::GTK_PRINT_STATUS_GENERATING_DATA,
            Self::SendingData => ffi::GTK_PRINT_STATUS_SENDING_DATA,
            Self::Pending => ffi::GTK_PRINT_STATUS_PENDING,
            Self::PendingIssue => ffi::GTK_PRINT_STATUS_PENDING_ISSUE,
            Self::Printing => ffi::GTK_PRINT_STATUS_PRINTING,
            Self::Finished => ffi::GTK_PRINT_STATUS_FINISHED,
            Self::FinishedAborted => ffi::GTK_PRINT_STATUS_FINISHED_ABORTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintStatus> for PrintStatus {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPrintStatus) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PRINT_STATUS_INITIAL => Self::Initial,
            ffi::GTK_PRINT_STATUS_PREPARING => Self::Preparing,
            ffi::GTK_PRINT_STATUS_GENERATING_DATA => Self::GeneratingData,
            ffi::GTK_PRINT_STATUS_SENDING_DATA => Self::SendingData,
            ffi::GTK_PRINT_STATUS_PENDING => Self::Pending,
            ffi::GTK_PRINT_STATUS_PENDING_ISSUE => Self::PendingIssue,
            ffi::GTK_PRINT_STATUS_PRINTING => Self::Printing,
            ffi::GTK_PRINT_STATUS_FINISHED => Self::Finished,
            ffi::GTK_PRINT_STATUS_FINISHED_ABORTED => Self::FinishedAborted,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PrintStatus {
    #[inline]
    #[doc(alias = "gtk_print_status_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_print_status_get_type()) }
    }
}

impl glib::HasParamSpec for PrintStatus {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PrintStatus {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintStatus {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PrintStatus {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PrintStatus> for glib::Value {
    #[inline]
    fn from(v: PrintStatus) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPropagationLimit")]
pub enum PropagationLimit {
    #[doc(alias = "GTK_LIMIT_NONE")]
    None,
    #[doc(alias = "GTK_LIMIT_SAME_NATIVE")]
    SameNative,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PropagationLimit {
    type GlibType = ffi::GtkPropagationLimit;

    #[inline]
    fn into_glib(self) -> ffi::GtkPropagationLimit {
        match self {
            Self::None => ffi::GTK_LIMIT_NONE,
            Self::SameNative => ffi::GTK_LIMIT_SAME_NATIVE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationLimit> for PropagationLimit {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPropagationLimit) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_LIMIT_NONE => Self::None,
            ffi::GTK_LIMIT_SAME_NATIVE => Self::SameNative,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PropagationLimit {
    #[inline]
    #[doc(alias = "gtk_propagation_limit_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_propagation_limit_get_type()) }
    }
}

impl glib::HasParamSpec for PropagationLimit {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PropagationLimit {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PropagationLimit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PropagationLimit {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PropagationLimit> for glib::Value {
    #[inline]
    fn from(v: PropagationLimit) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPropagationPhase")]
pub enum PropagationPhase {
    #[doc(alias = "GTK_PHASE_NONE")]
    None,
    #[doc(alias = "GTK_PHASE_CAPTURE")]
    Capture,
    #[doc(alias = "GTK_PHASE_BUBBLE")]
    Bubble,
    #[doc(alias = "GTK_PHASE_TARGET")]
    Target,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PropagationPhase {
    type GlibType = ffi::GtkPropagationPhase;

    #[inline]
    fn into_glib(self) -> ffi::GtkPropagationPhase {
        match self {
            Self::None => ffi::GTK_PHASE_NONE,
            Self::Capture => ffi::GTK_PHASE_CAPTURE,
            Self::Bubble => ffi::GTK_PHASE_BUBBLE,
            Self::Target => ffi::GTK_PHASE_TARGET,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationPhase> for PropagationPhase {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkPropagationPhase) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_PHASE_NONE => Self::None,
            ffi::GTK_PHASE_CAPTURE => Self::Capture,
            ffi::GTK_PHASE_BUBBLE => Self::Bubble,
            ffi::GTK_PHASE_TARGET => Self::Target,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PropagationPhase {
    #[inline]
    #[doc(alias = "gtk_propagation_phase_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_propagation_phase_get_type()) }
    }
}

impl glib::HasParamSpec for PropagationPhase {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PropagationPhase {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PropagationPhase {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PropagationPhase {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PropagationPhase> for glib::Value {
    #[inline]
    fn from(v: PropagationPhase) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRecentManagerError")]
pub enum RecentManagerError {
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_INVALID_URI")]
    InvalidUri,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING")]
    InvalidEncoding,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED")]
    NotRegistered,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_READ")]
    Read,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_WRITE")]
    Write,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_UNKNOWN")]
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RecentManagerError {
    type GlibType = ffi::GtkRecentManagerError;

    #[inline]
    fn into_glib(self) -> ffi::GtkRecentManagerError {
        match self {
            Self::NotFound => ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
            Self::InvalidUri => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI,
            Self::InvalidEncoding => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
            Self::NotRegistered => ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
            Self::Read => ffi::GTK_RECENT_MANAGER_ERROR_READ,
            Self::Write => ffi::GTK_RECENT_MANAGER_ERROR_WRITE,
            Self::Unknown => ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentManagerError> for RecentManagerError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkRecentManagerError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND => Self::NotFound,
            ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI => Self::InvalidUri,
            ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING => Self::InvalidEncoding,
            ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED => Self::NotRegistered,
            ffi::GTK_RECENT_MANAGER_ERROR_READ => Self::Read,
            ffi::GTK_RECENT_MANAGER_ERROR_WRITE => Self::Write,
            ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN => Self::Unknown,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for RecentManagerError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_recent_manager_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for RecentManagerError {
    #[inline]
    #[doc(alias = "gtk_recent_manager_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_recent_manager_error_get_type()) }
    }
}

impl glib::HasParamSpec for RecentManagerError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for RecentManagerError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RecentManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RecentManagerError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RecentManagerError> for glib::Value {
    #[inline]
    fn from(v: RecentManagerError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRevealerTransitionType")]
pub enum RevealerTransitionType {
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT")]
    SlideRight,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT")]
    SlideLeft,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP")]
    SlideUp,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN")]
    SlideDown,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SWING_RIGHT")]
    SwingRight,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SWING_LEFT")]
    SwingLeft,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SWING_UP")]
    SwingUp,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SWING_DOWN")]
    SwingDown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RevealerTransitionType {
    type GlibType = ffi::GtkRevealerTransitionType;

    #[inline]
    fn into_glib(self) -> ffi::GtkRevealerTransitionType {
        match self {
            Self::None => ffi::GTK_REVEALER_TRANSITION_TYPE_NONE,
            Self::Crossfade => ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE,
            Self::SlideRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT,
            Self::SlideLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT,
            Self::SlideUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP,
            Self::SlideDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN,
            Self::SwingRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_RIGHT,
            Self::SwingLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_LEFT,
            Self::SwingUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_UP,
            Self::SwingDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_DOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRevealerTransitionType> for RevealerTransitionType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkRevealerTransitionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_REVEALER_TRANSITION_TYPE_NONE => Self::None,
            ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE => Self::Crossfade,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT => Self::SlideRight,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT => Self::SlideLeft,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP => Self::SlideUp,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN => Self::SlideDown,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_RIGHT => Self::SwingRight,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_LEFT => Self::SwingLeft,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_UP => Self::SwingUp,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SWING_DOWN => Self::SwingDown,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for RevealerTransitionType {
    #[inline]
    #[doc(alias = "gtk_revealer_transition_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_revealer_transition_type_get_type()) }
    }
}

impl glib::HasParamSpec for RevealerTransitionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for RevealerTransitionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RevealerTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RevealerTransitionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RevealerTransitionType> for glib::Value {
    #[inline]
    fn from(v: RevealerTransitionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollStep")]
pub enum ScrollStep {
    #[doc(alias = "GTK_SCROLL_STEPS")]
    Steps,
    #[doc(alias = "GTK_SCROLL_PAGES")]
    Pages,
    #[doc(alias = "GTK_SCROLL_ENDS")]
    Ends,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_STEPS")]
    HorizontalSteps,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_PAGES")]
    HorizontalPages,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_ENDS")]
    HorizontalEnds,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ScrollStep {
    type GlibType = ffi::GtkScrollStep;

    #[inline]
    fn into_glib(self) -> ffi::GtkScrollStep {
        match self {
            Self::Steps => ffi::GTK_SCROLL_STEPS,
            Self::Pages => ffi::GTK_SCROLL_PAGES,
            Self::Ends => ffi::GTK_SCROLL_ENDS,
            Self::HorizontalSteps => ffi::GTK_SCROLL_HORIZONTAL_STEPS,
            Self::HorizontalPages => ffi::GTK_SCROLL_HORIZONTAL_PAGES,
            Self::HorizontalEnds => ffi::GTK_SCROLL_HORIZONTAL_ENDS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollStep> for ScrollStep {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkScrollStep) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SCROLL_STEPS => Self::Steps,
            ffi::GTK_SCROLL_PAGES => Self::Pages,
            ffi::GTK_SCROLL_ENDS => Self::Ends,
            ffi::GTK_SCROLL_HORIZONTAL_STEPS => Self::HorizontalSteps,
            ffi::GTK_SCROLL_HORIZONTAL_PAGES => Self::HorizontalPages,
            ffi::GTK_SCROLL_HORIZONTAL_ENDS => Self::HorizontalEnds,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ScrollStep {
    #[inline]
    #[doc(alias = "gtk_scroll_step_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_scroll_step_get_type()) }
    }
}

impl glib::HasParamSpec for ScrollStep {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ScrollStep {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ScrollStep {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ScrollStep {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ScrollStep> for glib::Value {
    #[inline]
    fn from(v: ScrollStep) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollType")]
pub enum ScrollType {
    #[doc(alias = "GTK_SCROLL_NONE")]
    None,
    #[doc(alias = "GTK_SCROLL_JUMP")]
    Jump,
    #[doc(alias = "GTK_SCROLL_STEP_BACKWARD")]
    StepBackward,
    #[doc(alias = "GTK_SCROLL_STEP_FORWARD")]
    StepForward,
    #[doc(alias = "GTK_SCROLL_PAGE_BACKWARD")]
    PageBackward,
    #[doc(alias = "GTK_SCROLL_PAGE_FORWARD")]
    PageForward,
    #[doc(alias = "GTK_SCROLL_STEP_UP")]
    StepUp,
    #[doc(alias = "GTK_SCROLL_STEP_DOWN")]
    StepDown,
    #[doc(alias = "GTK_SCROLL_PAGE_UP")]
    PageUp,
    #[doc(alias = "GTK_SCROLL_PAGE_DOWN")]
    PageDown,
    #[doc(alias = "GTK_SCROLL_STEP_LEFT")]
    StepLeft,
    #[doc(alias = "GTK_SCROLL_STEP_RIGHT")]
    StepRight,
    #[doc(alias = "GTK_SCROLL_PAGE_LEFT")]
    PageLeft,
    #[doc(alias = "GTK_SCROLL_PAGE_RIGHT")]
    PageRight,
    #[doc(alias = "GTK_SCROLL_START")]
    Start,
    #[doc(alias = "GTK_SCROLL_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ScrollType {
    type GlibType = ffi::GtkScrollType;

    fn into_glib(self) -> ffi::GtkScrollType {
        match self {
            Self::None => ffi::GTK_SCROLL_NONE,
            Self::Jump => ffi::GTK_SCROLL_JUMP,
            Self::StepBackward => ffi::GTK_SCROLL_STEP_BACKWARD,
            Self::StepForward => ffi::GTK_SCROLL_STEP_FORWARD,
            Self::PageBackward => ffi::GTK_SCROLL_PAGE_BACKWARD,
            Self::PageForward => ffi::GTK_SCROLL_PAGE_FORWARD,
            Self::StepUp => ffi::GTK_SCROLL_STEP_UP,
            Self::StepDown => ffi::GTK_SCROLL_STEP_DOWN,
            Self::PageUp => ffi::GTK_SCROLL_PAGE_UP,
            Self::PageDown => ffi::GTK_SCROLL_PAGE_DOWN,
            Self::StepLeft => ffi::GTK_SCROLL_STEP_LEFT,
            Self::StepRight => ffi::GTK_SCROLL_STEP_RIGHT,
            Self::PageLeft => ffi::GTK_SCROLL_PAGE_LEFT,
            Self::PageRight => ffi::GTK_SCROLL_PAGE_RIGHT,
            Self::Start => ffi::GTK_SCROLL_START,
            Self::End => ffi::GTK_SCROLL_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollType> for ScrollType {
    unsafe fn from_glib(value: ffi::GtkScrollType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SCROLL_NONE => Self::None,
            ffi::GTK_SCROLL_JUMP => Self::Jump,
            ffi::GTK_SCROLL_STEP_BACKWARD => Self::StepBackward,
            ffi::GTK_SCROLL_STEP_FORWARD => Self::StepForward,
            ffi::GTK_SCROLL_PAGE_BACKWARD => Self::PageBackward,
            ffi::GTK_SCROLL_PAGE_FORWARD => Self::PageForward,
            ffi::GTK_SCROLL_STEP_UP => Self::StepUp,
            ffi::GTK_SCROLL_STEP_DOWN => Self::StepDown,
            ffi::GTK_SCROLL_PAGE_UP => Self::PageUp,
            ffi::GTK_SCROLL_PAGE_DOWN => Self::PageDown,
            ffi::GTK_SCROLL_STEP_LEFT => Self::StepLeft,
            ffi::GTK_SCROLL_STEP_RIGHT => Self::StepRight,
            ffi::GTK_SCROLL_PAGE_LEFT => Self::PageLeft,
            ffi::GTK_SCROLL_PAGE_RIGHT => Self::PageRight,
            ffi::GTK_SCROLL_START => Self::Start,
            ffi::GTK_SCROLL_END => Self::End,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ScrollType {
    #[inline]
    #[doc(alias = "gtk_scroll_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_scroll_type_get_type()) }
    }
}

impl glib::HasParamSpec for ScrollType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ScrollType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ScrollType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ScrollType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ScrollType> for glib::Value {
    #[inline]
    fn from(v: ScrollType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollablePolicy")]
pub enum ScrollablePolicy {
    #[doc(alias = "GTK_SCROLL_MINIMUM")]
    Minimum,
    #[doc(alias = "GTK_SCROLL_NATURAL")]
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ScrollablePolicy {
    type GlibType = ffi::GtkScrollablePolicy;

    #[inline]
    fn into_glib(self) -> ffi::GtkScrollablePolicy {
        match self {
            Self::Minimum => ffi::GTK_SCROLL_MINIMUM,
            Self::Natural => ffi::GTK_SCROLL_NATURAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollablePolicy> for ScrollablePolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkScrollablePolicy) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SCROLL_MINIMUM => Self::Minimum,
            ffi::GTK_SCROLL_NATURAL => Self::Natural,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ScrollablePolicy {
    #[inline]
    #[doc(alias = "gtk_scrollable_policy_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_scrollable_policy_get_type()) }
    }
}

impl glib::HasParamSpec for ScrollablePolicy {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ScrollablePolicy {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ScrollablePolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ScrollablePolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ScrollablePolicy> for glib::Value {
    #[inline]
    fn from(v: ScrollablePolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSelectionMode")]
pub enum SelectionMode {
    #[doc(alias = "GTK_SELECTION_NONE")]
    None,
    #[doc(alias = "GTK_SELECTION_SINGLE")]
    Single,
    #[doc(alias = "GTK_SELECTION_BROWSE")]
    Browse,
    #[doc(alias = "GTK_SELECTION_MULTIPLE")]
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SelectionMode {
    type GlibType = ffi::GtkSelectionMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkSelectionMode {
        match self {
            Self::None => ffi::GTK_SELECTION_NONE,
            Self::Single => ffi::GTK_SELECTION_SINGLE,
            Self::Browse => ffi::GTK_SELECTION_BROWSE,
            Self::Multiple => ffi::GTK_SELECTION_MULTIPLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSelectionMode> for SelectionMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSelectionMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SELECTION_NONE => Self::None,
            ffi::GTK_SELECTION_SINGLE => Self::Single,
            ffi::GTK_SELECTION_BROWSE => Self::Browse,
            ffi::GTK_SELECTION_MULTIPLE => Self::Multiple,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SelectionMode {
    #[inline]
    #[doc(alias = "gtk_selection_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_selection_mode_get_type()) }
    }
}

impl glib::HasParamSpec for SelectionMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SelectionMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SelectionMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SelectionMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SelectionMode> for glib::Value {
    #[inline]
    fn from(v: SelectionMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSensitivityType")]
pub enum SensitivityType {
    #[doc(alias = "GTK_SENSITIVITY_AUTO")]
    Auto,
    #[doc(alias = "GTK_SENSITIVITY_ON")]
    On,
    #[doc(alias = "GTK_SENSITIVITY_OFF")]
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SensitivityType {
    type GlibType = ffi::GtkSensitivityType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSensitivityType {
        match self {
            Self::Auto => ffi::GTK_SENSITIVITY_AUTO,
            Self::On => ffi::GTK_SENSITIVITY_ON,
            Self::Off => ffi::GTK_SENSITIVITY_OFF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSensitivityType> for SensitivityType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSensitivityType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SENSITIVITY_AUTO => Self::Auto,
            ffi::GTK_SENSITIVITY_ON => Self::On,
            ffi::GTK_SENSITIVITY_OFF => Self::Off,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SensitivityType {
    #[inline]
    #[doc(alias = "gtk_sensitivity_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_sensitivity_type_get_type()) }
    }
}

impl glib::HasParamSpec for SensitivityType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SensitivityType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SensitivityType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SensitivityType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SensitivityType> for glib::Value {
    #[inline]
    fn from(v: SensitivityType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkShortcutScope")]
pub enum ShortcutScope {
    #[doc(alias = "GTK_SHORTCUT_SCOPE_LOCAL")]
    Local,
    #[doc(alias = "GTK_SHORTCUT_SCOPE_MANAGED")]
    Managed,
    #[doc(alias = "GTK_SHORTCUT_SCOPE_GLOBAL")]
    Global,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ShortcutScope {
    type GlibType = ffi::GtkShortcutScope;

    #[inline]
    fn into_glib(self) -> ffi::GtkShortcutScope {
        match self {
            Self::Local => ffi::GTK_SHORTCUT_SCOPE_LOCAL,
            Self::Managed => ffi::GTK_SHORTCUT_SCOPE_MANAGED,
            Self::Global => ffi::GTK_SHORTCUT_SCOPE_GLOBAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutScope> for ShortcutScope {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkShortcutScope) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SHORTCUT_SCOPE_LOCAL => Self::Local,
            ffi::GTK_SHORTCUT_SCOPE_MANAGED => Self::Managed,
            ffi::GTK_SHORTCUT_SCOPE_GLOBAL => Self::Global,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ShortcutScope {
    #[inline]
    #[doc(alias = "gtk_shortcut_scope_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_shortcut_scope_get_type()) }
    }
}

impl glib::HasParamSpec for ShortcutScope {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ShortcutScope {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ShortcutScope {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ShortcutScope {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ShortcutScope> for glib::Value {
    #[inline]
    fn from(v: ShortcutScope) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkShortcutType")]
pub enum ShortcutType {
    #[doc(alias = "GTK_SHORTCUT_ACCELERATOR")]
    Accelerator,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_PINCH")]
    GesturePinch,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_STRETCH")]
    GestureStretch,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE")]
    GestureRotateClockwise,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE")]
    GestureRotateCounterclockwise,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT")]
    GestureTwoFingerSwipeLeft,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT")]
    GestureTwoFingerSwipeRight,
    #[doc(alias = "GTK_SHORTCUT_GESTURE")]
    Gesture,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_SWIPE_LEFT")]
    GestureSwipeLeft,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_SWIPE_RIGHT")]
    GestureSwipeRight,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ShortcutType {
    type GlibType = ffi::GtkShortcutType;

    #[inline]
    fn into_glib(self) -> ffi::GtkShortcutType {
        match self {
            Self::Accelerator => ffi::GTK_SHORTCUT_ACCELERATOR,
            Self::GesturePinch => ffi::GTK_SHORTCUT_GESTURE_PINCH,
            Self::GestureStretch => ffi::GTK_SHORTCUT_GESTURE_STRETCH,
            Self::GestureRotateClockwise => ffi::GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE,
            Self::GestureRotateCounterclockwise => {
                ffi::GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE
            }
            Self::GestureTwoFingerSwipeLeft => ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT,
            Self::GestureTwoFingerSwipeRight => ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT,
            Self::Gesture => ffi::GTK_SHORTCUT_GESTURE,
            Self::GestureSwipeLeft => ffi::GTK_SHORTCUT_GESTURE_SWIPE_LEFT,
            Self::GestureSwipeRight => ffi::GTK_SHORTCUT_GESTURE_SWIPE_RIGHT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutType> for ShortcutType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkShortcutType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SHORTCUT_ACCELERATOR => Self::Accelerator,
            ffi::GTK_SHORTCUT_GESTURE_PINCH => Self::GesturePinch,
            ffi::GTK_SHORTCUT_GESTURE_STRETCH => Self::GestureStretch,
            ffi::GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE => Self::GestureRotateClockwise,
            ffi::GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE => {
                Self::GestureRotateCounterclockwise
            }
            ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT => Self::GestureTwoFingerSwipeLeft,
            ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT => Self::GestureTwoFingerSwipeRight,
            ffi::GTK_SHORTCUT_GESTURE => Self::Gesture,
            ffi::GTK_SHORTCUT_GESTURE_SWIPE_LEFT => Self::GestureSwipeLeft,
            ffi::GTK_SHORTCUT_GESTURE_SWIPE_RIGHT => Self::GestureSwipeRight,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ShortcutType {
    #[inline]
    #[doc(alias = "gtk_shortcut_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_shortcut_type_get_type()) }
    }
}

impl glib::HasParamSpec for ShortcutType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ShortcutType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ShortcutType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ShortcutType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ShortcutType> for glib::Value {
    #[inline]
    fn from(v: ShortcutType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSizeGroupMode")]
pub enum SizeGroupMode {
    #[doc(alias = "GTK_SIZE_GROUP_NONE")]
    None,
    #[doc(alias = "GTK_SIZE_GROUP_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_SIZE_GROUP_VERTICAL")]
    Vertical,
    #[doc(alias = "GTK_SIZE_GROUP_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SizeGroupMode {
    type GlibType = ffi::GtkSizeGroupMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkSizeGroupMode {
        match self {
            Self::None => ffi::GTK_SIZE_GROUP_NONE,
            Self::Horizontal => ffi::GTK_SIZE_GROUP_HORIZONTAL,
            Self::Vertical => ffi::GTK_SIZE_GROUP_VERTICAL,
            Self::Both => ffi::GTK_SIZE_GROUP_BOTH,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeGroupMode> for SizeGroupMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSizeGroupMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SIZE_GROUP_NONE => Self::None,
            ffi::GTK_SIZE_GROUP_HORIZONTAL => Self::Horizontal,
            ffi::GTK_SIZE_GROUP_VERTICAL => Self::Vertical,
            ffi::GTK_SIZE_GROUP_BOTH => Self::Both,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SizeGroupMode {
    #[inline]
    #[doc(alias = "gtk_size_group_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_size_group_mode_get_type()) }
    }
}

impl glib::HasParamSpec for SizeGroupMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SizeGroupMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SizeGroupMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SizeGroupMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SizeGroupMode> for glib::Value {
    #[inline]
    fn from(v: SizeGroupMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSizeRequestMode")]
pub enum SizeRequestMode {
    #[doc(alias = "GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH")]
    HeightForWidth,
    #[doc(alias = "GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT")]
    WidthForHeight,
    #[doc(alias = "GTK_SIZE_REQUEST_CONSTANT_SIZE")]
    ConstantSize,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SizeRequestMode {
    type GlibType = ffi::GtkSizeRequestMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkSizeRequestMode {
        match self {
            Self::HeightForWidth => ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH,
            Self::WidthForHeight => ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT,
            Self::ConstantSize => ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeRequestMode> for SizeRequestMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSizeRequestMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH => Self::HeightForWidth,
            ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT => Self::WidthForHeight,
            ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE => Self::ConstantSize,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SizeRequestMode {
    #[inline]
    #[doc(alias = "gtk_size_request_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_size_request_mode_get_type()) }
    }
}

impl glib::HasParamSpec for SizeRequestMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SizeRequestMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SizeRequestMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SizeRequestMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SizeRequestMode> for glib::Value {
    #[inline]
    fn from(v: SizeRequestMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSortType")]
pub enum SortType {
    #[doc(alias = "GTK_SORT_ASCENDING")]
    Ascending,
    #[doc(alias = "GTK_SORT_DESCENDING")]
    Descending,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SortType {
    type GlibType = ffi::GtkSortType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSortType {
        match self {
            Self::Ascending => ffi::GTK_SORT_ASCENDING,
            Self::Descending => ffi::GTK_SORT_DESCENDING,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSortType> for SortType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSortType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SORT_ASCENDING => Self::Ascending,
            ffi::GTK_SORT_DESCENDING => Self::Descending,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SortType {
    #[inline]
    #[doc(alias = "gtk_sort_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_sort_type_get_type()) }
    }
}

impl glib::HasParamSpec for SortType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SortType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SortType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SortType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SortType> for glib::Value {
    #[inline]
    fn from(v: SortType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSorterChange")]
pub enum SorterChange {
    #[doc(alias = "GTK_SORTER_CHANGE_DIFFERENT")]
    Different,
    #[doc(alias = "GTK_SORTER_CHANGE_INVERTED")]
    Inverted,
    #[doc(alias = "GTK_SORTER_CHANGE_LESS_STRICT")]
    LessStrict,
    #[doc(alias = "GTK_SORTER_CHANGE_MORE_STRICT")]
    MoreStrict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SorterChange {
    type GlibType = ffi::GtkSorterChange;

    #[inline]
    fn into_glib(self) -> ffi::GtkSorterChange {
        match self {
            Self::Different => ffi::GTK_SORTER_CHANGE_DIFFERENT,
            Self::Inverted => ffi::GTK_SORTER_CHANGE_INVERTED,
            Self::LessStrict => ffi::GTK_SORTER_CHANGE_LESS_STRICT,
            Self::MoreStrict => ffi::GTK_SORTER_CHANGE_MORE_STRICT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSorterChange> for SorterChange {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSorterChange) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SORTER_CHANGE_DIFFERENT => Self::Different,
            ffi::GTK_SORTER_CHANGE_INVERTED => Self::Inverted,
            ffi::GTK_SORTER_CHANGE_LESS_STRICT => Self::LessStrict,
            ffi::GTK_SORTER_CHANGE_MORE_STRICT => Self::MoreStrict,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SorterChange {
    #[inline]
    #[doc(alias = "gtk_sorter_change_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_sorter_change_get_type()) }
    }
}

impl glib::HasParamSpec for SorterChange {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SorterChange {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SorterChange {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SorterChange {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SorterChange> for glib::Value {
    #[inline]
    fn from(v: SorterChange) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSorterOrder")]
pub enum SorterOrder {
    #[doc(alias = "GTK_SORTER_ORDER_PARTIAL")]
    Partial,
    #[doc(alias = "GTK_SORTER_ORDER_NONE")]
    None,
    #[doc(alias = "GTK_SORTER_ORDER_TOTAL")]
    Total,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SorterOrder {
    type GlibType = ffi::GtkSorterOrder;

    #[inline]
    fn into_glib(self) -> ffi::GtkSorterOrder {
        match self {
            Self::Partial => ffi::GTK_SORTER_ORDER_PARTIAL,
            Self::None => ffi::GTK_SORTER_ORDER_NONE,
            Self::Total => ffi::GTK_SORTER_ORDER_TOTAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSorterOrder> for SorterOrder {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSorterOrder) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SORTER_ORDER_PARTIAL => Self::Partial,
            ffi::GTK_SORTER_ORDER_NONE => Self::None,
            ffi::GTK_SORTER_ORDER_TOTAL => Self::Total,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SorterOrder {
    #[inline]
    #[doc(alias = "gtk_sorter_order_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_sorter_order_get_type()) }
    }
}

impl glib::HasParamSpec for SorterOrder {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SorterOrder {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SorterOrder {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SorterOrder {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SorterOrder> for glib::Value {
    #[inline]
    fn from(v: SorterOrder) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSpinButtonUpdatePolicy")]
pub enum SpinButtonUpdatePolicy {
    #[doc(alias = "GTK_UPDATE_ALWAYS")]
    Always,
    #[doc(alias = "GTK_UPDATE_IF_VALID")]
    IfValid,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SpinButtonUpdatePolicy {
    type GlibType = ffi::GtkSpinButtonUpdatePolicy;

    #[inline]
    fn into_glib(self) -> ffi::GtkSpinButtonUpdatePolicy {
        match self {
            Self::Always => ffi::GTK_UPDATE_ALWAYS,
            Self::IfValid => ffi::GTK_UPDATE_IF_VALID,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinButtonUpdatePolicy> for SpinButtonUpdatePolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_UPDATE_ALWAYS => Self::Always,
            ffi::GTK_UPDATE_IF_VALID => Self::IfValid,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SpinButtonUpdatePolicy {
    #[inline]
    #[doc(alias = "gtk_spin_button_update_policy_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_spin_button_update_policy_get_type()) }
    }
}

impl glib::HasParamSpec for SpinButtonUpdatePolicy {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SpinButtonUpdatePolicy {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SpinButtonUpdatePolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SpinButtonUpdatePolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SpinButtonUpdatePolicy> for glib::Value {
    #[inline]
    fn from(v: SpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSpinType")]
pub enum SpinType {
    #[doc(alias = "GTK_SPIN_STEP_FORWARD")]
    StepForward,
    #[doc(alias = "GTK_SPIN_STEP_BACKWARD")]
    StepBackward,
    #[doc(alias = "GTK_SPIN_PAGE_FORWARD")]
    PageForward,
    #[doc(alias = "GTK_SPIN_PAGE_BACKWARD")]
    PageBackward,
    #[doc(alias = "GTK_SPIN_HOME")]
    Home,
    #[doc(alias = "GTK_SPIN_END")]
    End,
    #[doc(alias = "GTK_SPIN_USER_DEFINED")]
    UserDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SpinType {
    type GlibType = ffi::GtkSpinType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSpinType {
        match self {
            Self::StepForward => ffi::GTK_SPIN_STEP_FORWARD,
            Self::StepBackward => ffi::GTK_SPIN_STEP_BACKWARD,
            Self::PageForward => ffi::GTK_SPIN_PAGE_FORWARD,
            Self::PageBackward => ffi::GTK_SPIN_PAGE_BACKWARD,
            Self::Home => ffi::GTK_SPIN_HOME,
            Self::End => ffi::GTK_SPIN_END,
            Self::UserDefined => ffi::GTK_SPIN_USER_DEFINED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinType> for SpinType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSpinType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SPIN_STEP_FORWARD => Self::StepForward,
            ffi::GTK_SPIN_STEP_BACKWARD => Self::StepBackward,
            ffi::GTK_SPIN_PAGE_FORWARD => Self::PageForward,
            ffi::GTK_SPIN_PAGE_BACKWARD => Self::PageBackward,
            ffi::GTK_SPIN_HOME => Self::Home,
            ffi::GTK_SPIN_END => Self::End,
            ffi::GTK_SPIN_USER_DEFINED => Self::UserDefined,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SpinType {
    #[inline]
    #[doc(alias = "gtk_spin_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_spin_type_get_type()) }
    }
}

impl glib::HasParamSpec for SpinType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SpinType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SpinType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SpinType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SpinType> for glib::Value {
    #[inline]
    fn from(v: SpinType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkStackTransitionType")]
pub enum StackTransitionType {
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT")]
    SlideRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT")]
    SlideLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_UP")]
    SlideUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN")]
    SlideDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT")]
    SlideLeftRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN")]
    SlideUpDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_UP")]
    OverUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_DOWN")]
    OverDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_LEFT")]
    OverLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_RIGHT")]
    OverRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_UP")]
    UnderUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_DOWN")]
    UnderDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_LEFT")]
    UnderLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT")]
    UnderRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN")]
    OverUpDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP")]
    OverDownUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT")]
    OverLeftRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT")]
    OverRightLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT")]
    RotateLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_ROTATE_RIGHT")]
    RotateRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT_RIGHT")]
    RotateLeftRight,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for StackTransitionType {
    type GlibType = ffi::GtkStackTransitionType;

    fn into_glib(self) -> ffi::GtkStackTransitionType {
        match self {
            Self::None => ffi::GTK_STACK_TRANSITION_TYPE_NONE,
            Self::Crossfade => ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE,
            Self::SlideRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT,
            Self::SlideLeft => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT,
            Self::SlideUp => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP,
            Self::SlideDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN,
            Self::SlideLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT,
            Self::SlideUpDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN,
            Self::OverUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP,
            Self::OverDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN,
            Self::OverLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT,
            Self::OverRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT,
            Self::UnderUp => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP,
            Self::UnderDown => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN,
            Self::UnderLeft => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT,
            Self::UnderRight => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT,
            Self::OverUpDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN,
            Self::OverDownUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP,
            Self::OverLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT,
            Self::OverRightLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT,
            Self::RotateLeft => ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT,
            Self::RotateRight => ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_RIGHT,
            Self::RotateLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT_RIGHT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStackTransitionType> for StackTransitionType {
    unsafe fn from_glib(value: ffi::GtkStackTransitionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_STACK_TRANSITION_TYPE_NONE => Self::None,
            ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE => Self::Crossfade,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT => Self::SlideRight,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT => Self::SlideLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP => Self::SlideUp,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN => Self::SlideDown,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT => Self::SlideLeftRight,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN => Self::SlideUpDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP => Self::OverUp,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN => Self::OverDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT => Self::OverLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT => Self::OverRight,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP => Self::UnderUp,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN => Self::UnderDown,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT => Self::UnderLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT => Self::UnderRight,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN => Self::OverUpDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP => Self::OverDownUp,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT => Self::OverLeftRight,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT => Self::OverRightLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT => Self::RotateLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_RIGHT => Self::RotateRight,
            ffi::GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT_RIGHT => Self::RotateLeftRight,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for StackTransitionType {
    #[inline]
    #[doc(alias = "gtk_stack_transition_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_stack_transition_type_get_type()) }
    }
}

impl glib::HasParamSpec for StackTransitionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for StackTransitionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StackTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for StackTransitionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StackTransitionType> for glib::Value {
    #[inline]
    fn from(v: StackTransitionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkStringFilterMatchMode")]
pub enum StringFilterMatchMode {
    #[doc(alias = "GTK_STRING_FILTER_MATCH_MODE_EXACT")]
    Exact,
    #[doc(alias = "GTK_STRING_FILTER_MATCH_MODE_SUBSTRING")]
    Substring,
    #[doc(alias = "GTK_STRING_FILTER_MATCH_MODE_PREFIX")]
    Prefix,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for StringFilterMatchMode {
    type GlibType = ffi::GtkStringFilterMatchMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkStringFilterMatchMode {
        match self {
            Self::Exact => ffi::GTK_STRING_FILTER_MATCH_MODE_EXACT,
            Self::Substring => ffi::GTK_STRING_FILTER_MATCH_MODE_SUBSTRING,
            Self::Prefix => ffi::GTK_STRING_FILTER_MATCH_MODE_PREFIX,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStringFilterMatchMode> for StringFilterMatchMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkStringFilterMatchMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_STRING_FILTER_MATCH_MODE_EXACT => Self::Exact,
            ffi::GTK_STRING_FILTER_MATCH_MODE_SUBSTRING => Self::Substring,
            ffi::GTK_STRING_FILTER_MATCH_MODE_PREFIX => Self::Prefix,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for StringFilterMatchMode {
    #[inline]
    #[doc(alias = "gtk_string_filter_match_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_string_filter_match_mode_get_type()) }
    }
}

impl glib::HasParamSpec for StringFilterMatchMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for StringFilterMatchMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StringFilterMatchMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for StringFilterMatchMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StringFilterMatchMode> for glib::Value {
    #[inline]
    fn from(v: StringFilterMatchMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSymbolicColor")]
pub enum SymbolicColor {
    #[doc(alias = "GTK_SYMBOLIC_COLOR_FOREGROUND")]
    Foreground,
    #[doc(alias = "GTK_SYMBOLIC_COLOR_ERROR")]
    Error,
    #[doc(alias = "GTK_SYMBOLIC_COLOR_WARNING")]
    Warning,
    #[doc(alias = "GTK_SYMBOLIC_COLOR_SUCCESS")]
    Success,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[doc(hidden)]
impl IntoGlib for SymbolicColor {
    type GlibType = ffi::GtkSymbolicColor;

    #[inline]
    fn into_glib(self) -> ffi::GtkSymbolicColor {
        match self {
            Self::Foreground => ffi::GTK_SYMBOLIC_COLOR_FOREGROUND,
            Self::Error => ffi::GTK_SYMBOLIC_COLOR_ERROR,
            Self::Warning => ffi::GTK_SYMBOLIC_COLOR_WARNING,
            Self::Success => ffi::GTK_SYMBOLIC_COLOR_SUCCESS,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkSymbolicColor> for SymbolicColor {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSymbolicColor) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SYMBOLIC_COLOR_FOREGROUND => Self::Foreground,
            ffi::GTK_SYMBOLIC_COLOR_ERROR => Self::Error,
            ffi::GTK_SYMBOLIC_COLOR_WARNING => Self::Warning,
            ffi::GTK_SYMBOLIC_COLOR_SUCCESS => Self::Success,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl StaticType for SymbolicColor {
    #[inline]
    #[doc(alias = "gtk_symbolic_color_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_symbolic_color_get_type()) }
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl glib::HasParamSpec for SymbolicColor {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl glib::value::ValueType for SymbolicColor {
    type Type = Self;
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for SymbolicColor {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl ToValue for SymbolicColor {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v4_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v4_6")))]
impl From<SymbolicColor> for glib::Value {
    #[inline]
    fn from(v: SymbolicColor) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSystemSetting")]
pub enum SystemSetting {
    #[doc(alias = "GTK_SYSTEM_SETTING_DPI")]
    Dpi,
    #[doc(alias = "GTK_SYSTEM_SETTING_FONT_NAME")]
    FontName,
    #[doc(alias = "GTK_SYSTEM_SETTING_FONT_CONFIG")]
    FontConfig,
    #[doc(alias = "GTK_SYSTEM_SETTING_DISPLAY")]
    Display,
    #[doc(alias = "GTK_SYSTEM_SETTING_ICON_THEME")]
    IconTheme,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SystemSetting {
    type GlibType = ffi::GtkSystemSetting;

    #[inline]
    fn into_glib(self) -> ffi::GtkSystemSetting {
        match self {
            Self::Dpi => ffi::GTK_SYSTEM_SETTING_DPI,
            Self::FontName => ffi::GTK_SYSTEM_SETTING_FONT_NAME,
            Self::FontConfig => ffi::GTK_SYSTEM_SETTING_FONT_CONFIG,
            Self::Display => ffi::GTK_SYSTEM_SETTING_DISPLAY,
            Self::IconTheme => ffi::GTK_SYSTEM_SETTING_ICON_THEME,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSystemSetting> for SystemSetting {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSystemSetting) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SYSTEM_SETTING_DPI => Self::Dpi,
            ffi::GTK_SYSTEM_SETTING_FONT_NAME => Self::FontName,
            ffi::GTK_SYSTEM_SETTING_FONT_CONFIG => Self::FontConfig,
            ffi::GTK_SYSTEM_SETTING_DISPLAY => Self::Display,
            ffi::GTK_SYSTEM_SETTING_ICON_THEME => Self::IconTheme,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SystemSetting {
    #[inline]
    #[doc(alias = "gtk_system_setting_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_system_setting_get_type()) }
    }
}

impl glib::HasParamSpec for SystemSetting {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SystemSetting {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SystemSetting {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SystemSetting {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SystemSetting> for glib::Value {
    #[inline]
    fn from(v: SystemSetting) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextDirection")]
pub enum TextDirection {
    #[doc(alias = "GTK_TEXT_DIR_NONE")]
    None,
    #[doc(alias = "GTK_TEXT_DIR_LTR")]
    Ltr,
    #[doc(alias = "GTK_TEXT_DIR_RTL")]
    Rtl,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TextDirection {
    type GlibType = ffi::GtkTextDirection;

    #[inline]
    fn into_glib(self) -> ffi::GtkTextDirection {
        match self {
            Self::None => ffi::GTK_TEXT_DIR_NONE,
            Self::Ltr => ffi::GTK_TEXT_DIR_LTR,
            Self::Rtl => ffi::GTK_TEXT_DIR_RTL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextDirection> for TextDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTextDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TEXT_DIR_NONE => Self::None,
            ffi::GTK_TEXT_DIR_LTR => Self::Ltr,
            ffi::GTK_TEXT_DIR_RTL => Self::Rtl,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TextDirection {
    #[inline]
    #[doc(alias = "gtk_text_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_text_direction_get_type()) }
    }
}

impl glib::HasParamSpec for TextDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TextDirection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TextDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TextDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextDirection> for glib::Value {
    #[inline]
    fn from(v: TextDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextExtendSelection")]
pub enum TextExtendSelection {
    #[doc(alias = "GTK_TEXT_EXTEND_SELECTION_WORD")]
    Word,
    #[doc(alias = "GTK_TEXT_EXTEND_SELECTION_LINE")]
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TextExtendSelection {
    type GlibType = ffi::GtkTextExtendSelection;

    #[inline]
    fn into_glib(self) -> ffi::GtkTextExtendSelection {
        match self {
            Self::Word => ffi::GTK_TEXT_EXTEND_SELECTION_WORD,
            Self::Line => ffi::GTK_TEXT_EXTEND_SELECTION_LINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextExtendSelection> for TextExtendSelection {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTextExtendSelection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TEXT_EXTEND_SELECTION_WORD => Self::Word,
            ffi::GTK_TEXT_EXTEND_SELECTION_LINE => Self::Line,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TextExtendSelection {
    #[inline]
    #[doc(alias = "gtk_text_extend_selection_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_text_extend_selection_get_type()) }
    }
}

impl glib::HasParamSpec for TextExtendSelection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TextExtendSelection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TextExtendSelection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TextExtendSelection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextExtendSelection> for glib::Value {
    #[inline]
    fn from(v: TextExtendSelection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextViewLayer")]
pub enum TextViewLayer {
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_BELOW_TEXT")]
    BelowText,
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_ABOVE_TEXT")]
    AboveText,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TextViewLayer {
    type GlibType = ffi::GtkTextViewLayer;

    #[inline]
    fn into_glib(self) -> ffi::GtkTextViewLayer {
        match self {
            Self::BelowText => ffi::GTK_TEXT_VIEW_LAYER_BELOW_TEXT,
            Self::AboveText => ffi::GTK_TEXT_VIEW_LAYER_ABOVE_TEXT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextViewLayer> for TextViewLayer {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTextViewLayer) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TEXT_VIEW_LAYER_BELOW_TEXT => Self::BelowText,
            ffi::GTK_TEXT_VIEW_LAYER_ABOVE_TEXT => Self::AboveText,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TextViewLayer {
    #[inline]
    #[doc(alias = "gtk_text_view_layer_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_text_view_layer_get_type()) }
    }
}

impl glib::HasParamSpec for TextViewLayer {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TextViewLayer {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TextViewLayer {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TextViewLayer {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextViewLayer> for glib::Value {
    #[inline]
    fn from(v: TextViewLayer) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextWindowType")]
pub enum TextWindowType {
    #[doc(alias = "GTK_TEXT_WINDOW_WIDGET")]
    Widget,
    #[doc(alias = "GTK_TEXT_WINDOW_TEXT")]
    Text,
    #[doc(alias = "GTK_TEXT_WINDOW_LEFT")]
    Left,
    #[doc(alias = "GTK_TEXT_WINDOW_RIGHT")]
    Right,
    #[doc(alias = "GTK_TEXT_WINDOW_TOP")]
    Top,
    #[doc(alias = "GTK_TEXT_WINDOW_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TextWindowType {
    type GlibType = ffi::GtkTextWindowType;

    #[inline]
    fn into_glib(self) -> ffi::GtkTextWindowType {
        match self {
            Self::Widget => ffi::GTK_TEXT_WINDOW_WIDGET,
            Self::Text => ffi::GTK_TEXT_WINDOW_TEXT,
            Self::Left => ffi::GTK_TEXT_WINDOW_LEFT,
            Self::Right => ffi::GTK_TEXT_WINDOW_RIGHT,
            Self::Top => ffi::GTK_TEXT_WINDOW_TOP,
            Self::Bottom => ffi::GTK_TEXT_WINDOW_BOTTOM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextWindowType> for TextWindowType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTextWindowType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TEXT_WINDOW_WIDGET => Self::Widget,
            ffi::GTK_TEXT_WINDOW_TEXT => Self::Text,
            ffi::GTK_TEXT_WINDOW_LEFT => Self::Left,
            ffi::GTK_TEXT_WINDOW_RIGHT => Self::Right,
            ffi::GTK_TEXT_WINDOW_TOP => Self::Top,
            ffi::GTK_TEXT_WINDOW_BOTTOM => Self::Bottom,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TextWindowType {
    #[inline]
    #[doc(alias = "gtk_text_window_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_text_window_type_get_type()) }
    }
}

impl glib::HasParamSpec for TextWindowType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TextWindowType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TextWindowType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TextWindowType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextWindowType> for glib::Value {
    #[inline]
    fn from(v: TextWindowType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewColumnSizing")]
pub enum TreeViewColumnSizing {
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_GROW_ONLY")]
    GrowOnly,
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_AUTOSIZE")]
    Autosize,
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_FIXED")]
    Fixed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TreeViewColumnSizing {
    type GlibType = ffi::GtkTreeViewColumnSizing;

    #[inline]
    fn into_glib(self) -> ffi::GtkTreeViewColumnSizing {
        match self {
            Self::GrowOnly => ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY,
            Self::Autosize => ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE,
            Self::Fixed => ffi::GTK_TREE_VIEW_COLUMN_FIXED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewColumnSizing> for TreeViewColumnSizing {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTreeViewColumnSizing) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY => Self::GrowOnly,
            ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE => Self::Autosize,
            ffi::GTK_TREE_VIEW_COLUMN_FIXED => Self::Fixed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewColumnSizing {
    #[inline]
    #[doc(alias = "gtk_tree_view_column_sizing_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_tree_view_column_sizing_get_type()) }
    }
}

impl glib::HasParamSpec for TreeViewColumnSizing {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TreeViewColumnSizing {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TreeViewColumnSizing {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TreeViewColumnSizing {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TreeViewColumnSizing> for glib::Value {
    #[inline]
    fn from(v: TreeViewColumnSizing) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewDropPosition")]
pub enum TreeViewDropPosition {
    #[doc(alias = "GTK_TREE_VIEW_DROP_BEFORE")]
    Before,
    #[doc(alias = "GTK_TREE_VIEW_DROP_AFTER")]
    After,
    #[doc(alias = "GTK_TREE_VIEW_DROP_INTO_OR_BEFORE")]
    IntoOrBefore,
    #[doc(alias = "GTK_TREE_VIEW_DROP_INTO_OR_AFTER")]
    IntoOrAfter,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TreeViewDropPosition {
    type GlibType = ffi::GtkTreeViewDropPosition;

    #[inline]
    fn into_glib(self) -> ffi::GtkTreeViewDropPosition {
        match self {
            Self::Before => ffi::GTK_TREE_VIEW_DROP_BEFORE,
            Self::After => ffi::GTK_TREE_VIEW_DROP_AFTER,
            Self::IntoOrBefore => ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
            Self::IntoOrAfter => ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewDropPosition> for TreeViewDropPosition {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTreeViewDropPosition) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TREE_VIEW_DROP_BEFORE => Self::Before,
            ffi::GTK_TREE_VIEW_DROP_AFTER => Self::After,
            ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE => Self::IntoOrBefore,
            ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER => Self::IntoOrAfter,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewDropPosition {
    #[inline]
    #[doc(alias = "gtk_tree_view_drop_position_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_tree_view_drop_position_get_type()) }
    }
}

impl glib::HasParamSpec for TreeViewDropPosition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TreeViewDropPosition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TreeViewDropPosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TreeViewDropPosition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TreeViewDropPosition> for glib::Value {
    #[inline]
    fn from(v: TreeViewDropPosition) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewGridLines")]
pub enum TreeViewGridLines {
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_NONE")]
    None,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_VERTICAL")]
    Vertical,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TreeViewGridLines {
    type GlibType = ffi::GtkTreeViewGridLines;

    #[inline]
    fn into_glib(self) -> ffi::GtkTreeViewGridLines {
        match self {
            Self::None => ffi::GTK_TREE_VIEW_GRID_LINES_NONE,
            Self::Horizontal => ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
            Self::Vertical => ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL,
            Self::Both => ffi::GTK_TREE_VIEW_GRID_LINES_BOTH,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewGridLines> for TreeViewGridLines {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkTreeViewGridLines) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_TREE_VIEW_GRID_LINES_NONE => Self::None,
            ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL => Self::Horizontal,
            ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL => Self::Vertical,
            ffi::GTK_TREE_VIEW_GRID_LINES_BOTH => Self::Both,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewGridLines {
    #[inline]
    #[doc(alias = "gtk_tree_view_grid_lines_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_tree_view_grid_lines_get_type()) }
    }
}

impl glib::HasParamSpec for TreeViewGridLines {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TreeViewGridLines {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TreeViewGridLines {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TreeViewGridLines {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TreeViewGridLines> for glib::Value {
    #[inline]
    fn from(v: TreeViewGridLines) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkUnit")]
pub enum Unit {
    #[doc(alias = "GTK_UNIT_NONE")]
    None,
    #[doc(alias = "GTK_UNIT_POINTS")]
    Points,
    #[doc(alias = "GTK_UNIT_INCH")]
    Inch,
    #[doc(alias = "GTK_UNIT_MM")]
    Mm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Unit {
    type GlibType = ffi::GtkUnit;

    #[inline]
    fn into_glib(self) -> ffi::GtkUnit {
        match self {
            Self::None => ffi::GTK_UNIT_NONE,
            Self::Points => ffi::GTK_UNIT_POINTS,
            Self::Inch => ffi::GTK_UNIT_INCH,
            Self::Mm => ffi::GTK_UNIT_MM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkUnit> for Unit {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkUnit) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_UNIT_NONE => Self::None,
            ffi::GTK_UNIT_POINTS => Self::Points,
            ffi::GTK_UNIT_INCH => Self::Inch,
            ffi::GTK_UNIT_MM => Self::Mm,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Unit {
    #[inline]
    #[doc(alias = "gtk_unit_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_unit_get_type()) }
    }
}

impl glib::HasParamSpec for Unit {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Unit {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Unit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Unit {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Unit> for glib::Value {
    #[inline]
    fn from(v: Unit) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkWrapMode")]
pub enum WrapMode {
    #[doc(alias = "GTK_WRAP_NONE")]
    None,
    #[doc(alias = "GTK_WRAP_CHAR")]
    Char,
    #[doc(alias = "GTK_WRAP_WORD")]
    Word,
    #[doc(alias = "GTK_WRAP_WORD_CHAR")]
    WordChar,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WrapMode {
    type GlibType = ffi::GtkWrapMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkWrapMode {
        match self {
            Self::None => ffi::GTK_WRAP_NONE,
            Self::Char => ffi::GTK_WRAP_CHAR,
            Self::Word => ffi::GTK_WRAP_WORD,
            Self::WordChar => ffi::GTK_WRAP_WORD_CHAR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWrapMode> for WrapMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkWrapMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_WRAP_NONE => Self::None,
            ffi::GTK_WRAP_CHAR => Self::Char,
            ffi::GTK_WRAP_WORD => Self::Word,
            ffi::GTK_WRAP_WORD_CHAR => Self::WordChar,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WrapMode {
    #[inline]
    #[doc(alias = "gtk_wrap_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_wrap_mode_get_type()) }
    }
}

impl glib::HasParamSpec for WrapMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WrapMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WrapMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WrapMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WrapMode> for glib::Value {
    #[inline]
    fn from(v: WrapMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
